{
    "docs": [
        {
            "location": "/webserver/04_request-handling",
            "text": " Each Handler has two parameters. ServerRequest and ServerResponse . Request provides access to the request method, URI, path, query parameters, headers and entity. Response provides an ability to set response code, headers, and entity. ",
            "title": "Process Request and Produce Response"
        },
        {
            "location": "/webserver/04_request-handling",
            "text": " The handler forwards the request to the downstream handlers by nexting . There are two options: call req.next() <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic req.next(); }) handler for any HTTP method using the /hello path business logic implementation forward the current request to the downstream handler call req.next(throwable) to forward the handling to the error handlers <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic (e.g., validating parameters) if (userParametersOk()) { req.next(); } else { req.next(new IllegalArgumentException(\"Invalid parameters.\"); } }) handler for any HTTP method using the /hello path custom logic forward the current request to the downstream handler forward the request to the error handler The handling logic can explicitly forward the execution to a different thread. This is the reason why returning from the handler can&#8217;t automatically trigger calling the next handler. ",
            "title": "Handler as a Filter"
        },
        {
            "location": "/webserver/04_request-handling",
            "text": " To complete the request handling, you must send a response by calling the res.send() method. <markup lang=\"java\" >.get(\"/hello\", (req, res) -&gt; { // terminating logic res.status(Http.Status.ACCEPTED_201); res.send(\"Saved!\"); }) handler that terminates the request handling for any HTTP method using the /hello path send the response ",
            "title": "Sending a response"
        },
        {
            "location": "/webserver/04_request-handling",
            "text": " Implement the logic to handle requests to WebServer in a Handler , which is a FunctionalInterface . Handlers: Process the request and send a response. Act as a filter and forward requests to downstream handlers using the request.next() method. Throw an exception or call request.next(exception) to begin error handling . Process Request and Produce Response Each Handler has two parameters. ServerRequest and ServerResponse . Request provides access to the request method, URI, path, query parameters, headers and entity. Response provides an ability to set response code, headers, and entity. Handler as a Filter The handler forwards the request to the downstream handlers by nexting . There are two options: call req.next() <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic req.next(); }) handler for any HTTP method using the /hello path business logic implementation forward the current request to the downstream handler call req.next(throwable) to forward the handling to the error handlers <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic (e.g., validating parameters) if (userParametersOk()) { req.next(); } else { req.next(new IllegalArgumentException(\"Invalid parameters.\"); } }) handler for any HTTP method using the /hello path custom logic forward the current request to the downstream handler forward the request to the error handler The handling logic can explicitly forward the execution to a different thread. This is the reason why returning from the handler can&#8217;t automatically trigger calling the next handler. Sending a response To complete the request handling, you must send a response by calling the res.send() method. <markup lang=\"java\" >.get(\"/hello\", (req, res) -&gt; { // terminating logic res.status(Http.Status.ACCEPTED_201); res.send(\"Saved!\"); }) handler that terminates the request handling for any HTTP method using the /hello path send the response ",
            "title": "Request Handling"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"Webserver JSON-P Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-json&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " To enable JSON-P support, first register it with the route builder. Then you can add routes that handle and return JSON. <markup lang=\"java\" title=\"Configure JsonSupport and use it for reading and writing of entities\" >Routing.builder() .register(JsonSupport.get()) .post(\"/sayhello\", Handler.of(JsonObject.class, this::sayHello)) .build(); Register JsonSupport to enable transformation from and to JsonObject objects Register a handler that receives a JsonObject as its input. <markup lang=\"java\" title=\"Handler that receives and returns JSON objects\" >private void sayHello(ServerRequest req, ServerResponse res, JsonObject json) { JsonObject msg = Json.createObjectBuilder() .add(\"message\", \"Hello \" + json.getString(\"name\")) .build(); res.send(msg); } JsonObject is passed to handler Create a JsonObject using JSON-P to hold return data Send JsonObject in response <markup lang=\"bash\" title=\"Example of posting JSON to sayHello endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/sayhello -d '{\"name\":\"Joe\"}' {\"message\":\"Hello Joe\"} ",
            "title": "Usage"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " To configure JSON-P JsonReaderFactory and JsonWriterFactory that are used by the JsonSupport instance, create the JsonSupport object: <markup lang=\"java\" title=\"Create JsonSupport with the provided configuration\" >JsonSupport.create(Map.of(JsonGenerator.PRETTY_PRINTING, false)) ",
            "title": "Configuring Json Reader/Writer factories"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " The WebServer supports JSON-P. When enabled, you can send and receive JSON-P objects transparently. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" title=\"Webserver JSON-P Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-json&lt;/artifactId&gt; &lt;/dependency&gt; Usage To enable JSON-P support, first register it with the route builder. Then you can add routes that handle and return JSON. <markup lang=\"java\" title=\"Configure JsonSupport and use it for reading and writing of entities\" >Routing.builder() .register(JsonSupport.get()) .post(\"/sayhello\", Handler.of(JsonObject.class, this::sayHello)) .build(); Register JsonSupport to enable transformation from and to JsonObject objects Register a handler that receives a JsonObject as its input. <markup lang=\"java\" title=\"Handler that receives and returns JSON objects\" >private void sayHello(ServerRequest req, ServerResponse res, JsonObject json) { JsonObject msg = Json.createObjectBuilder() .add(\"message\", \"Hello \" + json.getString(\"name\")) .build(); res.send(msg); } JsonObject is passed to handler Create a JsonObject using JSON-P to hold return data Send JsonObject in response <markup lang=\"bash\" title=\"Example of posting JSON to sayHello endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/sayhello -d '{\"name\":\"Joe\"}' {\"message\":\"Hello Joe\"} Configuring Json Reader/Writer factories To configure JSON-P JsonReaderFactory and JsonWriterFactory that are used by the JsonSupport instance, create the JsonSupport object: <markup lang=\"java\" title=\"Create JsonSupport with the provided configuration\" >JsonSupport.create(Map.of(JsonGenerator.PRETTY_PRINTING, false)) ",
            "title": "Json Support"
        },
        {
            "location": "/microprofile/02_server-configuration",
            "text": " By default, the server uses the MicroProfile Config, but you may also want to use Helidon configuration. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/02_server-configuration",
            "text": " There are 3 default MicroProfile Config sources: System.getProperties() System.getenv() all META-INF/microprofile-config.properties files on the class path In this example, the configuration is in a file, and it includes Helidon configuration options. <markup lang=\"properties\" title=\"META-INF/microprofile-config.properties - Server configuration\" ># default is localhost server.host=some.host # default is 7001 server.port=7011 # Helidon configuration (optional) # Length of queue for incoming connections. Default is 1024 server.backlog: 512 # TCP receive window. Default is 0 to use implementation default server.receive-buffer: 256 # Socket timeout milliseconds - defaults to 0 (infinite) server.timeout: 30000 # Default is CPU_COUNT * 2 server.workers=4 # Default is not to use SSL ssl: private-key: keystore-resource-path: \"certificate.p12\" keystore-passphrase: \"abcd\" For Helidon config, the default file is application.yaml on the classpath (e.g. src/main/resources/application.yaml). <markup lang=\"yaml\" title=\"application.yaml - Server configuration\" >server: sockets: - secure: port: 443 # supports all socket related properties of server backlog: 1024 receive-buffer: 0 timeout: 60000 ssl: .... - another: port: 12041 ",
            "title": "Configuring the Server"
        },
        {
            "location": "/webserver/10_metrics-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"Webserver Prometheus Support Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-prometheus&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/webserver/10_metrics-support",
            "text": " To enable Prometheus integration, register Prometheus support with the WebServer: <markup lang=\"java\" title=\"Configuring Prometheus\" >Routing.builder() .register(PrometheusSupport.create()) .register(\"/myapp\", new MyService()) .build(); Then you can interact with Prometheus collectors in your service. Metrics are available at /metrics <markup lang=\"java\" title=\"Define a Prometheus Counter\" >public class MyService implements Service { static final Counter accessCtr = Counter.build() .name(\"requests_total\").help(\"Total requests.\").register(); @Override public void update(Routing.Rules rules) { rules .any(this::countAccess) .get(\"/\", this::myGet); } private void countAccess(ServerRequest request, ServerResponse response) { accessCtr.inc(); request.next(); } } Register a Prometheus Counter with the default Collector Use the Counter in a request handler ",
            "title": "Configuring Prometheus"
        },
        {
            "location": "/webserver/10_metrics-support",
            "text": " The WebServer includes Prometheus support for metrics. Prerequisites Declare the following dependency in your project: <markup lang=\"xml\" title=\"Webserver Prometheus Support Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-prometheus&lt;/artifactId&gt; &lt;/dependency&gt; Configuring Prometheus To enable Prometheus integration, register Prometheus support with the WebServer: <markup lang=\"java\" title=\"Configuring Prometheus\" >Routing.builder() .register(PrometheusSupport.create()) .register(\"/myapp\", new MyService()) .build(); Then you can interact with Prometheus collectors in your service. Metrics are available at /metrics <markup lang=\"java\" title=\"Define a Prometheus Counter\" >public class MyService implements Service { static final Counter accessCtr = Counter.build() .name(\"requests_total\").help(\"Total requests.\").register(); @Override public void update(Routing.Rules rules) { rules .any(this::countAccess) .get(\"/\", this::myGet); } private void countAccess(ServerRequest request, ServerResponse response) { accessCtr.inc(); request.next(); } } Register a Prometheus Counter with the default Collector Use the Counter in a request handler ",
            "title": "Metrics Support"
        },
        {
            "location": "/webserver/10_metrics-support",
            "text": " The WebServer does not include a dedicated health check feature, but you can implement a health check by defining an appropriate endpoint. To create a health check that runs on a separate port from your main web application: Define a second socket in the WebServer&#8217;s configuration. Create a health service to handle requests on the socket. Add a route to the health service. <markup lang=\"yaml\" title=\"Define a health check socket in application.yaml\" >server: port: 8080 sockets: health: port: 9090 Name this socket \"health\" <markup lang=\"java\" title=\"Create a health service\" >public class HealthCheckService implements Service { HealthCheckService() { } @Override public void update(Routing.Rules rules) { rules.get(\"/health\", this::get); } public void get(ServerRequest req, ServerResponse res) { res.status(200).send(); } } <markup lang=\"java\" title=\"Define a route to the HealthCheckService service on the socket\" > // By default this picks up application.yaml from the classpath Config config = Config.create(); // Get WebServer config from the \"server\" section of application.yaml ServerConfiguration serverConfig = ServerConfiguration. fromConfig(config.get(\"server\")); WebServer server = WebServer.builder(createRouting()) .configuration(serverConfig) .addNamedRouting(\"health\", Routing.builder() .register(new HealthCheckService()) .build()) .build(); createRouting() creates a Routing object for your main application. See the Quickstart examples . Add routing for a named socket. This name must match the name of the socket used in the WebServer configuration. Register the health check service on that socket. You can access your health check at host:9090/health ",
            "title": "Implementing a Health Check"
        },
        {
            "location": "/config/01_introduction",
            "text": " The config component provides a Java API to load and process configuration properties in key/value form into a Config object which the application can use to retrieve config data. ",
            "title": "preambule"
        },
        {
            "location": "/config/01_introduction",
            "text": " A brief overview of the config system helps clarify its different parts and how they work together. Most applications will typically deal with more than one of these parts. The system reads configuration from a config source , a physical location (such as a file, a URL, or a String ) which holds config data. Each config source works with a config parser which translates a particular text format (for example, Java properties or YAML) into an in-memory tree which represents the configuration&#8217;s structure and values. An optional polling strategy detects and publishes changes to the underlying config source so the config source itself or your application can respond. Your application uses the Config object which results from building that in-memory tree to retrieve config data. The app can navigate explicitly among the nodes in the tree and fetch a node&#8217;s value <markup lang=\"java\" >Optional&lt;String&gt; pageSize = Config.get(\"web\").get(\"page-size\").value(); or it can address a node in the tree using the config key&#8217;s dotted name <markup lang=\"java\" >int pageSize = Config.get(\"web.page-size\").asInt(); As part of retrieving a value from a node, the config system applies config filters which can change what values are returned for selected keys. The Config object lets your application retrieve config data as: an Optional&lt;String&gt; value from a single node , the String value from a single node interpreted as a basic Java type (primitive or simple object) already known to the config system (such as a boolean or a Double ), or a complex Java type from a subtree of the config tree. The config system automatically knows how to return List and Map complex types, and you can provide config mappers to convert a config subtree to whatever Java types your application needs. ",
            "title": "Introducing the Config System"
        },
        {
            "location": "/config/01_introduction",
            "text": "<markup lang=\"xml\" title=\"Config Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config&lt;/artifactId&gt; &lt;version&gt;version-of-config-you-are-using&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ",
            "title": "Add Maven Dependency on Config"
        },
        {
            "location": "/config/01_introduction",
            "text": " If you are using Java 9 then create or update the module-info.java file for your application: <markup lang=\"java\" title=\"Config Dependency in module-info.java \" >module myModule { requires io.helidon.config; } ",
            "title": "Update module-info.java "
        },
        {
            "location": "/config/01_introduction",
            "text": "<markup title=\"Example src/main/resources/application.properties config file\" >greeting = Hello web.debug = true web.page-size = 20 web.ratio = 1.3 bl.initial-id = 10000000000 origin = props java.home=homeFromProps # will be ignored ",
            "title": "Create simple Config Properties File"
        },
        {
            "location": "/config/01_introduction",
            "text": " The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. ",
            "title": "Config Sources for the Default Config"
        },
        {
            "location": "/config/01_introduction",
            "text": " If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format <a id=\"\" title=\"\" target=\"_blank\" href=\"http://yaml.org\">http://yaml.org application.conf helidon-config-hcon HOCON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config#using-hocon-the-json-superset\">https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hcon JSON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://json.org/\">https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Built-in Support for Config Formats"
        },
        {
            "location": "/config/01_introduction",
            "text": "<markup lang=\"java\" title=\"Create and Use Default Config from Java\" >import io.helidon.config.Config; ... Config config = Config.create(); System.out.println(String.format( \"greeting is %s\" + \"web.debug is %b\" + \"web.page-size is %d\" + \"web.ratio is %f\" + \"bl.initial-id is %d\" + \"origin is %s\" + \"java.home is %s\", config.get(\"greeting\").asString(), config.get(\"web.debug\").asBoolean(), config.get(\"web.page-size\").asInt(), config.get(\"web.ratio\").asDouble(), config.get(\"bl.initial-id\").asLong(), config.get(\"origin\").asString(), config.get(\"java.home\").asString())); Import Config . Create the root of the Config tree from the default sources. Retrieve various values by their dotted names and decode them as the appropriate Java types. When you build and run your project, the output will look like this: <markup >greeting is Hello web.debug is true web.page-size is 20 web.ratio is 1.300000 bl.initial-id is 10000000000 origin is props java.home is /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home Config Sources for the Default Config The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. Built-in Support for Config Formats If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format <a id=\"\" title=\"\" target=\"_blank\" href=\"http://yaml.org\">http://yaml.org application.conf helidon-config-hcon HOCON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config#using-hocon-the-json-superset\">https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hcon JSON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://json.org/\">https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Write Code using the Default Config"
        },
        {
            "location": "/config/01_introduction",
            "text": " An easy way to start with the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html\">Config API is to follow these four steps: add config-related dependencies to your pom.xml revise your module-info.java to refer to config (if you are using Java 9) create a simple config properties file retrieve and use the default Config from your app Add Maven Dependency on Config <markup lang=\"xml\" title=\"Config Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config&lt;/artifactId&gt; &lt;version&gt;version-of-config-you-are-using&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Update module-info.java If you are using Java 9 then create or update the module-info.java file for your application: <markup lang=\"java\" title=\"Config Dependency in module-info.java \" >module myModule { requires io.helidon.config; } Create simple Config Properties File <markup title=\"Example src/main/resources/application.properties config file\" >greeting = Hello web.debug = true web.page-size = 20 web.ratio = 1.3 bl.initial-id = 10000000000 origin = props java.home=homeFromProps # will be ignored Write Code using the Default Config <markup lang=\"java\" title=\"Create and Use Default Config from Java\" >import io.helidon.config.Config; ... Config config = Config.create(); System.out.println(String.format( \"greeting is %s\" + \"web.debug is %b\" + \"web.page-size is %d\" + \"web.ratio is %f\" + \"bl.initial-id is %d\" + \"origin is %s\" + \"java.home is %s\", config.get(\"greeting\").asString(), config.get(\"web.debug\").asBoolean(), config.get(\"web.page-size\").asInt(), config.get(\"web.ratio\").asDouble(), config.get(\"bl.initial-id\").asLong(), config.get(\"origin\").asString(), config.get(\"java.home\").asString())); Import Config . Create the root of the Config tree from the default sources. Retrieve various values by their dotted names and decode them as the appropriate Java types. When you build and run your project, the output will look like this: <markup >greeting is Hello web.debug is true web.page-size is 20 web.ratio is 1.300000 bl.initial-id is 10000000000 origin is props java.home is /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home Config Sources for the Default Config The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. Built-in Support for Config Formats If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format <a id=\"\" title=\"\" target=\"_blank\" href=\"http://yaml.org\">http://yaml.org application.conf helidon-config-hcon HOCON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config#using-hocon-the-json-superset\">https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hcon JSON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://json.org/\">https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Your First Config Application"
        },
        {
            "location": "/config/01_introduction",
            "text": " Introducing the Config System A brief overview of the config system helps clarify its different parts and how they work together. Most applications will typically deal with more than one of these parts. The system reads configuration from a config source , a physical location (such as a file, a URL, or a String ) which holds config data. Each config source works with a config parser which translates a particular text format (for example, Java properties or YAML) into an in-memory tree which represents the configuration&#8217;s structure and values. An optional polling strategy detects and publishes changes to the underlying config source so the config source itself or your application can respond. Your application uses the Config object which results from building that in-memory tree to retrieve config data. The app can navigate explicitly among the nodes in the tree and fetch a node&#8217;s value <markup lang=\"java\" >Optional&lt;String&gt; pageSize = Config.get(\"web\").get(\"page-size\").value(); or it can address a node in the tree using the config key&#8217;s dotted name <markup lang=\"java\" >int pageSize = Config.get(\"web.page-size\").asInt(); As part of retrieving a value from a node, the config system applies config filters which can change what values are returned for selected keys. The Config object lets your application retrieve config data as: an Optional&lt;String&gt; value from a single node , the String value from a single node interpreted as a basic Java type (primitive or simple object) already known to the config system (such as a boolean or a Double ), or a complex Java type from a subtree of the config tree. The config system automatically knows how to return List and Map complex types, and you can provide config mappers to convert a config subtree to whatever Java types your application needs. Your First Config Application An easy way to start with the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html\">Config API is to follow these four steps: add config-related dependencies to your pom.xml revise your module-info.java to refer to config (if you are using Java 9) create a simple config properties file retrieve and use the default Config from your app Add Maven Dependency on Config <markup lang=\"xml\" title=\"Config Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config&lt;/artifactId&gt; &lt;version&gt;version-of-config-you-are-using&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Update module-info.java If you are using Java 9 then create or update the module-info.java file for your application: <markup lang=\"java\" title=\"Config Dependency in module-info.java \" >module myModule { requires io.helidon.config; } Create simple Config Properties File <markup title=\"Example src/main/resources/application.properties config file\" >greeting = Hello web.debug = true web.page-size = 20 web.ratio = 1.3 bl.initial-id = 10000000000 origin = props java.home=homeFromProps # will be ignored Write Code using the Default Config <markup lang=\"java\" title=\"Create and Use Default Config from Java\" >import io.helidon.config.Config; ... Config config = Config.create(); System.out.println(String.format( \"greeting is %s\" + \"web.debug is %b\" + \"web.page-size is %d\" + \"web.ratio is %f\" + \"bl.initial-id is %d\" + \"origin is %s\" + \"java.home is %s\", config.get(\"greeting\").asString(), config.get(\"web.debug\").asBoolean(), config.get(\"web.page-size\").asInt(), config.get(\"web.ratio\").asDouble(), config.get(\"bl.initial-id\").asLong(), config.get(\"origin\").asString(), config.get(\"java.home\").asString())); Import Config . Create the root of the Config tree from the default sources. Retrieve various values by their dotted names and decode them as the appropriate Java types. When you build and run your project, the output will look like this: <markup >greeting is Hello web.debug is true web.page-size is 20 web.ratio is 1.300000 bl.initial-id is 10000000000 origin is props java.home is /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home Config Sources for the Default Config The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. Built-in Support for Config Formats If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format <a id=\"\" title=\"\" target=\"_blank\" href=\"http://yaml.org\">http://yaml.org application.conf helidon-config-hcon HOCON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config#using-hocon-the-json-superset\">https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hcon JSON format <a id=\"\" title=\"\" target=\"_blank\" href=\"https://json.org/\">https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Getting Started"
        },
        {
            "location": "/config/01_introduction",
            "text": " Although the default configuration is very simple to use, your application can take as much control as it needs over loading configuration data, accessing the data once loaded, and extending and modifying the behavior of the config system. You do this by: creating and invoking methods on a Config.Builder object to construct a Config instance Using a builder, the application can control everything about how the config system creates the resulting Config instance: config sources, parsers, polling strategy, filters, overrides, mappers, whether or not environment variables and Java system properties serve as config sources. The JavaDoc explains how to use the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html\"> Config.Builder . or creating a meta-configuration file on the runtime classpath to control how the config system prepares the default configuration. Once created, the Config object provides many methods the application can use to retrieve config data as various Java types. See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html\"> Config JavaDoc for complete details. The links in the following tables lead you to more information about various other config topics. Controlling How Config is Loaded Topic Documentation Where config comes from Config sources , meta-configuration What format config data is expressed in Config parsers , supported formats How to filter, override, and dereference values Filters and overrides What happens when config data changes Config polling How to deal with loading errors Config retry policies Accessing Configuration Data Topic Documentation How config data is translated into Java types Config mappers How to navigate config trees Navigation Extending and Fine-tuning the Config System Topic Documentation Writing extensions Extensions ",
            "title": "Next Steps"
        },
        {
            "location": "/security/02_providers",
            "text": " All configuration options: key default value description realm  realm Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users A list of users (login, password and roles). Currently to externalize this you must use builder approach. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-basic-auth: users: - login: \"jack\" password: \"jackIsGreat\" roles: [\"user\", \"admin\"] Example configuration with a single user (may have more) using secured config filter (to encrypt passwords) - in this example, the password is intentionally in clear text to show its value (see secure config) <markup lang=\"yaml\" >- http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] ",
            "title": "Configuration Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpBasicAuthProvider.builder() .realm(\"helidon\") .subjectType(SubjectType.SERVICE) .userStore(aUserStore) .build(); ",
            "title": "Builder Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Basic authentication support authentication of request and identity propagation for outbound calls. Outbound security with basic authentication only works if the request is authenticated with basic authentication (e.g. we re-use the username and password from inbound request). Basic authentication is an HTTP header named Authorization with value of basic base64(username:password) . This provider also supports \"challenging\" the client to provide basic authentication if missing from request. See <a id=\"\" title=\"\" target=\"_blank\" href=\"https://tools.ietf.org/html/rfc7617\">https://tools.ietf.org/html/rfc7617 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security Maven artifactId helidon-security-provider-http-auth Provider package io.helidon.security.provider.httpauth Provider class HttpBasicAuthProvider Provider key http-basic-auth This provider is: Authentication Provider Authorization Provider Outbound Security Provider Audit Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description realm  realm Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users A list of users (login, password and roles). Currently to externalize this you must use builder approach. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-basic-auth: users: - login: \"jack\" password: \"jackIsGreat\" roles: [\"user\", \"admin\"] Example configuration with a single user (may have more) using secured config filter (to encrypt passwords) - in this example, the password is intentionally in clear text to show its value (see secure config) <markup lang=\"yaml\" >- http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder Based Approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpBasicAuthProvider.builder() .realm(\"helidon\") .subjectType(SubjectType.SERVICE) .userStore(aUserStore) .build(); ",
            "title": "HTTP Basic Authentication Provider"
        },
        {
            "location": "/security/02_providers",
            "text": " All configuration options: key default value description realm  realm Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users A list of users (login, password and roles). Currently to externalize this you must use builder approach. algorithm MD5 Only MD5 supported nonce-timeout-millis 1 day Number of milliseconds for the nonce timeout server-secret random A string to use as a server secret - this is to use digest auth between multiple servers (e.g. when in a cluster). Used to encrypt nonce. This must not be known outside of this app, as others may create digest requests we would trust. qop NONE only AUTH supported. If left empty, uses the legacy approach (older RFC version). AUTH-INT is not supported. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-digest-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] ",
            "title": "Configuration based approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpDigestAuthProvider.builder() .realm(\"helidon\") .digestServerSecret(\"aPassword\".toCharArray()) .userStore(buildUserStore()) ",
            "title": "Builder based approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Digest authentication provider supports only authentication of inbound requests (no outbound). This provider also supports \"challenging\" the client to provide digest authentication if missing from request. See <a id=\"\" title=\"\" target=\"_blank\" href=\"https://tools.ietf.org/html/rfc7616\">https://tools.ietf.org/html/rfc7616 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security Maven artifactId helidon-security-provider-http-auth Provider package io.helidon.security.provider.httpauth Provider class HttpDigestAuthProvider Provider key http-digest-auth This provider is: Authentication Provider Authorization Provider Outbound Security Provider Audit Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration based approach All configuration options: key default value description realm  realm Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users A list of users (login, password and roles). Currently to externalize this you must use builder approach. algorithm MD5 Only MD5 supported nonce-timeout-millis 1 day Number of milliseconds for the nonce timeout server-secret random A string to use as a server secret - this is to use digest auth between multiple servers (e.g. when in a cluster). Used to encrypt nonce. This must not be known outside of this app, as others may create digest requests we would trust. qop NONE only AUTH supported. If left empty, uses the legacy approach (older RFC version). AUTH-INT is not supported. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-digest-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder based approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpDigestAuthProvider.builder() .realm(\"helidon\") .digestServerSecret(\"aPassword\".toCharArray()) .userStore(buildUserStore()) ",
            "title": "HTTP Digest Authentication"
        },
        {
            "location": "/security/02_providers",
            "text": " All configuration options: key default value description optional  false If set to true, provider will abstain rather then fail if header not available authenticate true If set to false, authentication will not be attempted propagate true If set to false, identity propagation will not be done principal-type USER Can be USER or SERVICE atn-token Token extraction and propagation, you can define which header to use and how to extract it outbound-token atn-token If outbound token should be created differently than inbound Example configuration: <markup lang=\"yaml\" >- header-atn: optional: true principal-type: SERVICE atn-token: header: \"X-AUTH-USER\" outbound-token: header: \"Authorization\" format: \"bearer %1$s\" ",
            "title": "Configuration Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Example of a builder that configures the provider the same way as the above configuration approach. <markup lang=\"java\" >HeaderAtnProvider.builder() .optional(true) .subjectType(SubjectType.SERVICE) .atnTokenHandler(TokenHandler.builder() .tokenHeader(\"X-AUTH-USER\") .build()) .outboundTokenHandler(TokenHandler.builder() .tokenHeader(\"Authorization\") .tokenFormat(\"bearer %1$s\") .build()) .build(); ",
            "title": "Builder Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " This provider inspects a specified request header and extracts the username/service name from it and asserts it as current subject&#8217;s principal. This can be used when we use perimether authentication (e.g. there is a gateway that takes care of authentication and propagates the user in a header). Property Value Maven groupId io.helidon.security Maven artifactId helidon-security-provider-header-atn Provider package io.helidon.security.provider.header Provider class HeaderAtnProvider Provider key header-atn This provider is: Authentication Provider Authorization Provider Outbound Security Provider Audit Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-header-atn&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description optional  false If set to true, provider will abstain rather then fail if header not available authenticate true If set to false, authentication will not be attempted propagate true If set to false, identity propagation will not be done principal-type USER Can be USER or SERVICE atn-token Token extraction and propagation, you can define which header to use and how to extract it outbound-token atn-token If outbound token should be created differently than inbound Example configuration: <markup lang=\"yaml\" >- header-atn: optional: true principal-type: SERVICE atn-token: header: \"X-AUTH-USER\" outbound-token: header: \"Authorization\" format: \"bearer %1$s\" Builder Based Approach Example of a builder that configures the provider the same way as the above configuration approach. <markup lang=\"java\" >HeaderAtnProvider.builder() .optional(true) .subjectType(SubjectType.SERVICE) .atnTokenHandler(TokenHandler.builder() .tokenHeader(\"X-AUTH-USER\") .build()) .outboundTokenHandler(TokenHandler.builder() .tokenHeader(\"Authorization\") .tokenFormat(\"bearer %1$s\") .build()) .build(); ",
            "title": "Header Authentication Provider"
        },
        {
            "location": "/security/02_providers",
            "text": " standard: based on <a id=\"\" title=\"\" target=\"_blank\" href=\"https://tools.ietf.org/html/draft-cavage-http-signatures-03\">https://tools.ietf.org/html/draft-cavage-http-signatures-03 key-id: an arbitrary string used to locate signature configuration - when a request is received the provider locates validation configuration based on this id (e.g. HMAC shared secret or RSA public key). Commonly used meanings are: key fingerprint (RSA); API Key ",
            "title": "Signature basics"
        },
        {
            "location": "/security/02_providers",
            "text": " We act as a server and another party is calling us with a signed HTTP request. We validate the signature and assume identity of the caller. Builder example, starting from inside out: <markup lang=\"java\" title=\"Inbound signature configuration\" >// Configuration of public key certificate to validate inbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.from(Paths.get(\"keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .certAlias(\"service_cert\") .build(); // Create inbound client definition (e.g. map key-id to a public key and principal name) InboundClientDefinition rsaInbound = InboundClientDefinition.builder(\"service1-rsa\") .principalName(\"Service1\") .publicKeyConfig(keyConfig) .build(); // Now create a HTTP signature provider with inbound support (with a single supported signature) HttpSignProvider.builder() .addInbound(rsaInbound) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { inbound { keys: [ { key-id = \"service1-hmac\" # name of principal of the connecting party principal-name = \"Service1\" # SERVICE or USER, defaults to SERVICE principal-type = SERVICE # defaults to the one we configure (e.g. if hmac.secret is configured # it is hmac-sha256; if public-key is configured, it is rsa-sha256) algorithm = \"hmac-sha256\" # shared secret for symmetric signatures hmac.secret = \"${CLEAR=encryptMe}\" }, { key-id = \"service1-rsa\" principal-name = \"Service1\" # configuration of public key to validate signature public-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # defaults to PKCS12 keystore-type = \"PKCS12\" # password of the keystore # the ${CLEAR=} is a feature of keystore-passphrase = \"${CLEAR=password}\" # alias of the certificate to get public key from cert-alias = \"service_cert\" } } ] } } ",
            "title": "Inbound signatures"
        },
        {
            "location": "/security/02_providers",
            "text": " We act as a client and we sign our outgoing requests. Builder example, starting from inside out (rsa only, as hmac is significantly simpler): <markup lang=\"java\" title=\"Outbound signature configuration\" >// Configuration of private key to sign outbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.from(Paths.get(\"src/main/resources/keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .keyAlias(\"myPrivateKey\") .build(); OutboundTarget rsaTarget = OutboundTarget.builder(\"service2-rsa\") .addHost(\"service2\") // considering service registry .addPath(\"/service2-rsa\") .customObject(OutboundTargetDefinition.class, OutboundTargetDefinition.builder(\"service1-rsa\") .privateKeyConfig(keyConfig) .build()) .build(); // Now create a HTTP signature provider with outbound support (with a single supported signature) HttpSignProvider.builder() .outbound(OutboundConfig.builder() .addTarget(rsaTarget) .build()) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { outbound: [ { # Logical name of this outbound configuration name = \"service2-trust-circle\" # If ommited or one value is \"*\", all are supported transports = [\"http\", \"https\"] # If ommited or one value is \"*\", all are supported, may contain * as a sequence \"any\" characters/nubmers hosts = [\"service2\"] # If ommited, all are supported - regular expression paths = [\"/service2\"] # Configuration of signature (signing the request) signature { key-id = \"service2-shared-secret\" # HMAC shared secret (algorithm hmac-sha256) hmac.secret = \"${CLEAR=somePasswordForHmacShouldBeEncrypted}\" } }, { name = \"service2-rsa\" hosts = [\"service2\"] paths = [\"/service2-rsa\"] http://[] signature { key-id = \"service1-rsa\" # RSA private key (algorithm rsa-sha256) private-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # Keystore type # PKCS12, JSK or RSA (not really a keystore, but directly the linux style private key unencrypted) # defaults to jdk default keystore-type = \"PKCS12\" # password of the keystore keystore-passphrase = \"password\" # alias of the key to sign request key-alias = \"myPrivateKey\" } } } ] } ",
            "title": "Outbound signatures"
        },
        {
            "location": "/security/02_providers",
            "text": " Support for HTTP Signatures (both inbound and outbound). <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-http-signature&lt;/artifactId&gt; &lt;/dependency&gt; Signature basics standard: based on <a id=\"\" title=\"\" target=\"_blank\" href=\"https://tools.ietf.org/html/draft-cavage-http-signatures-03\">https://tools.ietf.org/html/draft-cavage-http-signatures-03 key-id: an arbitrary string used to locate signature configuration - when a request is received the provider locates validation configuration based on this id (e.g. HMAC shared secret or RSA public key). Commonly used meanings are: key fingerprint (RSA); API Key Inbound signatures We act as a server and another party is calling us with a signed HTTP request. We validate the signature and assume identity of the caller. Builder example, starting from inside out: <markup lang=\"java\" title=\"Inbound signature configuration\" >// Configuration of public key certificate to validate inbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.from(Paths.get(\"keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .certAlias(\"service_cert\") .build(); // Create inbound client definition (e.g. map key-id to a public key and principal name) InboundClientDefinition rsaInbound = InboundClientDefinition.builder(\"service1-rsa\") .principalName(\"Service1\") .publicKeyConfig(keyConfig) .build(); // Now create a HTTP signature provider with inbound support (with a single supported signature) HttpSignProvider.builder() .addInbound(rsaInbound) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { inbound { keys: [ { key-id = \"service1-hmac\" # name of principal of the connecting party principal-name = \"Service1\" # SERVICE or USER, defaults to SERVICE principal-type = SERVICE # defaults to the one we configure (e.g. if hmac.secret is configured # it is hmac-sha256; if public-key is configured, it is rsa-sha256) algorithm = \"hmac-sha256\" # shared secret for symmetric signatures hmac.secret = \"${CLEAR=encryptMe}\" }, { key-id = \"service1-rsa\" principal-name = \"Service1\" # configuration of public key to validate signature public-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # defaults to PKCS12 keystore-type = \"PKCS12\" # password of the keystore # the ${CLEAR=} is a feature of keystore-passphrase = \"${CLEAR=password}\" # alias of the certificate to get public key from cert-alias = \"service_cert\" } } ] } } Outbound signatures We act as a client and we sign our outgoing requests. Builder example, starting from inside out (rsa only, as hmac is significantly simpler): <markup lang=\"java\" title=\"Outbound signature configuration\" >// Configuration of private key to sign outbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.from(Paths.get(\"src/main/resources/keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .keyAlias(\"myPrivateKey\") .build(); OutboundTarget rsaTarget = OutboundTarget.builder(\"service2-rsa\") .addHost(\"service2\") // considering service registry .addPath(\"/service2-rsa\") .customObject(OutboundTargetDefinition.class, OutboundTargetDefinition.builder(\"service1-rsa\") .privateKeyConfig(keyConfig) .build()) .build(); // Now create a HTTP signature provider with outbound support (with a single supported signature) HttpSignProvider.builder() .outbound(OutboundConfig.builder() .addTarget(rsaTarget) .build()) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { outbound: [ { # Logical name of this outbound configuration name = \"service2-trust-circle\" # If ommited or one value is \"*\", all are supported transports = [\"http\", \"https\"] # If ommited or one value is \"*\", all are supported, may contain * as a sequence \"any\" characters/nubmers hosts = [\"service2\"] # If ommited, all are supported - regular expression paths = [\"/service2\"] # Configuration of signature (signing the request) signature { key-id = \"service2-shared-secret\" # HMAC shared secret (algorithm hmac-sha256) hmac.secret = \"${CLEAR=somePasswordForHmacShouldBeEncrypted}\" } }, { name = \"service2-rsa\" hosts = [\"service2\"] paths = [\"/service2-rsa\"] http://[] signature { key-id = \"service1-rsa\" # RSA private key (algorithm rsa-sha256) private-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # Keystore type # PKCS12, JSK or RSA (not really a keystore, but directly the linux style private key unencrypted) # defaults to jdk default keystore-type = \"PKCS12\" # password of the keystore keystore-passphrase = \"password\" # alias of the key to sign request key-alias = \"myPrivateKey\" } } } ] } ",
            "title": "HTTP Signatures"
        },
        {
            "location": "/security/02_providers",
            "text": " Checks whether user/service is in role(s) Configuration Key: role-validator Annotations: @RolesAllowed, @Roles <markup lang=\"java\" title=\"Example\" >@Roles(\"user_role\") @Roles(value = \"service_role\", subjectType = SubjectType.SERVICE) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Role Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " Checks whether user has the defined scopes Configuration Key: scope-validator Annotations: @Scope <markup lang=\"java\" title=\"Example\" >@Scope(\"calendar_read\") @Scope(\"calendar_edit\") @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Scope Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " Policy executor using Java EE policy expression language (EL) Configuration Key: policy-javax-el Annotations: @PolicyStatement <markup lang=\"java\" title=\"Example\" >@PolicyStatement(\"${env.time.year &gt;= 2017}\") @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Expression Language Policy Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " Supports time of day and day of week checks Configuration Key: time-validator Annotations: @DaysOfWeek, @TimesOfDay <markup lang=\"java\" title=\"Example\" >@TimeOfDay(from = \"08:15:00\", to = \"12:00:00\") @TimeOfDay(from = \"12:30:00\", to = \"17:30:00\") @DaysOfWeek({DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY}) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Time Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " This provider is an authorization provider validating various attributes against configured validators. Any attribute of the following objects can be used: - environment (such as time of request) - e.g. env.time.year - subject (user) - e.g. subject.principal.id - subject (service) - e.g. service.principal.id - object (must be explicitly invoked by developer in code, as object cannot be automatically added to security context) - e.g. object.owner This provider checks that all defined ABAC validators are validated. If there is a definition for a validator (e.g. an annotation) that is not checked, the request is denied. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-abac&lt;/artifactId&gt; &lt;/dependency&gt; The following validators are implemented: Roles Scopes EL Policy Time <markup lang=\"java\" title=\"Example of using an object\" >@Authenticated @Path(\"/abac\") public class AbacResource { @GET @Authorized(explicit = true) @PolicyStatement(\"${env.time.year &gt;= 2017 &amp;&amp; object.owner == subject.principal.id}\") public Response process(@Context SecurityContext context) { // probably looked up from a database SomeResource res = new SomeResource(\"user\"); AuthorizationResponse atzResponse = context.authorize(res); if (atzResponse.isPermitted()) { //do the update return Response.ok().entity(\"fine, sir\").build(); } else { return Response.status(Response.Status.FORBIDDEN) .entity(atzResponse.getDescription().orElse(\"Access not granted\")) .build(); } } } Role Validator Checks whether user/service is in role(s) Configuration Key: role-validator Annotations: @RolesAllowed, @Roles <markup lang=\"java\" title=\"Example\" >@Roles(\"user_role\") @Roles(value = \"service_role\", subjectType = SubjectType.SERVICE) @Authenticated @Path(\"/abac\") public class AbacResource { } Scope Validator Checks whether user has the defined scopes Configuration Key: scope-validator Annotations: @Scope <markup lang=\"java\" title=\"Example\" >@Scope(\"calendar_read\") @Scope(\"calendar_edit\") @Authenticated @Path(\"/abac\") public class AbacResource { } Expression Language Policy Validator Policy executor using Java EE policy expression language (EL) Configuration Key: policy-javax-el Annotations: @PolicyStatement <markup lang=\"java\" title=\"Example\" >@PolicyStatement(\"${env.time.year &gt;= 2017}\") @Authenticated @Path(\"/abac\") public class AbacResource { } Time Validator Supports time of day and day of week checks Configuration Key: time-validator Annotations: @DaysOfWeek, @TimesOfDay <markup lang=\"java\" title=\"Example\" >@TimeOfDay(from = \"08:15:00\", to = \"12:00:00\") @TimeOfDay(from = \"12:30:00\", to = \"17:30:00\") @DaysOfWeek({DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY}) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "ABAC (Attribute based access control) Authorization Provider"
        },
        {
            "location": "/security/02_providers",
            "text": " The following providers are implemented: HTTP Basic Authentication HTTP Digest Authentication Header Assertion HTTP Signatures ABAC Authorization Google Login Authentication Provider - please see security examples OIDC (Open ID Connect) Authentication provider (with Oracle IDCS extension) - please see security examples HTTP Basic Authentication Provider Basic authentication support authentication of request and identity propagation for outbound calls. Outbound security with basic authentication only works if the request is authenticated with basic authentication (e.g. we re-use the username and password from inbound request). Basic authentication is an HTTP header named Authorization with value of basic base64(username:password) . This provider also supports \"challenging\" the client to provide basic authentication if missing from request. See <a id=\"\" title=\"\" target=\"_blank\" href=\"https://tools.ietf.org/html/rfc7617\">https://tools.ietf.org/html/rfc7617 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security Maven artifactId helidon-security-provider-http-auth Provider package io.helidon.security.provider.httpauth Provider class HttpBasicAuthProvider Provider key http-basic-auth This provider is: Authentication Provider Authorization Provider Outbound Security Provider Audit Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description realm  realm Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users A list of users (login, password and roles). Currently to externalize this you must use builder approach. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-basic-auth: users: - login: \"jack\" password: \"jackIsGreat\" roles: [\"user\", \"admin\"] Example configuration with a single user (may have more) using secured config filter (to encrypt passwords) - in this example, the password is intentionally in clear text to show its value (see secure config) <markup lang=\"yaml\" >- http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder Based Approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpBasicAuthProvider.builder() .realm(\"helidon\") .subjectType(SubjectType.SERVICE) .userStore(aUserStore) .build(); HTTP Digest Authentication Digest authentication provider supports only authentication of inbound requests (no outbound). This provider also supports \"challenging\" the client to provide digest authentication if missing from request. See <a id=\"\" title=\"\" target=\"_blank\" href=\"https://tools.ietf.org/html/rfc7616\">https://tools.ietf.org/html/rfc7616 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security Maven artifactId helidon-security-provider-http-auth Provider package io.helidon.security.provider.httpauth Provider class HttpDigestAuthProvider Provider key http-digest-auth This provider is: Authentication Provider Authorization Provider Outbound Security Provider Audit Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration based approach All configuration options: key default value description realm  realm Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users A list of users (login, password and roles). Currently to externalize this you must use builder approach. algorithm MD5 Only MD5 supported nonce-timeout-millis 1 day Number of milliseconds for the nonce timeout server-secret random A string to use as a server secret - this is to use digest auth between multiple servers (e.g. when in a cluster). Used to encrypt nonce. This must not be known outside of this app, as others may create digest requests we would trust. qop NONE only AUTH supported. If left empty, uses the legacy approach (older RFC version). AUTH-INT is not supported. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-digest-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder based approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpDigestAuthProvider.builder() .realm(\"helidon\") .digestServerSecret(\"aPassword\".toCharArray()) .userStore(buildUserStore()) Header Authentication Provider This provider inspects a specified request header and extracts the username/service name from it and asserts it as current subject&#8217;s principal. This can be used when we use perimether authentication (e.g. there is a gateway that takes care of authentication and propagates the user in a header). Property Value Maven groupId io.helidon.security Maven artifactId helidon-security-provider-header-atn Provider package io.helidon.security.provider.header Provider class HeaderAtnProvider Provider key header-atn This provider is: Authentication Provider Authorization Provider Outbound Security Provider Audit Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-header-atn&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description optional  false If set to true, provider will abstain rather then fail if header not available authenticate true If set to false, authentication will not be attempted propagate true If set to false, identity propagation will not be done principal-type USER Can be USER or SERVICE atn-token Token extraction and propagation, you can define which header to use and how to extract it outbound-token atn-token If outbound token should be created differently than inbound Example configuration: <markup lang=\"yaml\" >- header-atn: optional: true principal-type: SERVICE atn-token: header: \"X-AUTH-USER\" outbound-token: header: \"Authorization\" format: \"bearer %1$s\" Builder Based Approach Example of a builder that configures the provider the same way as the above configuration approach. <markup lang=\"java\" >HeaderAtnProvider.builder() .optional(true) .subjectType(SubjectType.SERVICE) .atnTokenHandler(TokenHandler.builder() .tokenHeader(\"X-AUTH-USER\") .build()) .outboundTokenHandler(TokenHandler.builder() .tokenHeader(\"Authorization\") .tokenFormat(\"bearer %1$s\") .build()) .build(); HTTP Signatures Support for HTTP Signatures (both inbound and outbound). <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-http-signature&lt;/artifactId&gt; &lt;/dependency&gt; Signature basics standard: based on <a id=\"\" title=\"\" target=\"_blank\" href=\"https://tools.ietf.org/html/draft-cavage-http-signatures-03\">https://tools.ietf.org/html/draft-cavage-http-signatures-03 key-id: an arbitrary string used to locate signature configuration - when a request is received the provider locates validation configuration based on this id (e.g. HMAC shared secret or RSA public key). Commonly used meanings are: key fingerprint (RSA); API Key Inbound signatures We act as a server and another party is calling us with a signed HTTP request. We validate the signature and assume identity of the caller. Builder example, starting from inside out: <markup lang=\"java\" title=\"Inbound signature configuration\" >// Configuration of public key certificate to validate inbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.from(Paths.get(\"keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .certAlias(\"service_cert\") .build(); // Create inbound client definition (e.g. map key-id to a public key and principal name) InboundClientDefinition rsaInbound = InboundClientDefinition.builder(\"service1-rsa\") .principalName(\"Service1\") .publicKeyConfig(keyConfig) .build(); // Now create a HTTP signature provider with inbound support (with a single supported signature) HttpSignProvider.builder() .addInbound(rsaInbound) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { inbound { keys: [ { key-id = \"service1-hmac\" # name of principal of the connecting party principal-name = \"Service1\" # SERVICE or USER, defaults to SERVICE principal-type = SERVICE # defaults to the one we configure (e.g. if hmac.secret is configured # it is hmac-sha256; if public-key is configured, it is rsa-sha256) algorithm = \"hmac-sha256\" # shared secret for symmetric signatures hmac.secret = \"${CLEAR=encryptMe}\" }, { key-id = \"service1-rsa\" principal-name = \"Service1\" # configuration of public key to validate signature public-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # defaults to PKCS12 keystore-type = \"PKCS12\" # password of the keystore # the ${CLEAR=} is a feature of keystore-passphrase = \"${CLEAR=password}\" # alias of the certificate to get public key from cert-alias = \"service_cert\" } } ] } } Outbound signatures We act as a client and we sign our outgoing requests. Builder example, starting from inside out (rsa only, as hmac is significantly simpler): <markup lang=\"java\" title=\"Outbound signature configuration\" >// Configuration of private key to sign outbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.from(Paths.get(\"src/main/resources/keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .keyAlias(\"myPrivateKey\") .build(); OutboundTarget rsaTarget = OutboundTarget.builder(\"service2-rsa\") .addHost(\"service2\") // considering service registry .addPath(\"/service2-rsa\") .customObject(OutboundTargetDefinition.class, OutboundTargetDefinition.builder(\"service1-rsa\") .privateKeyConfig(keyConfig) .build()) .build(); // Now create a HTTP signature provider with outbound support (with a single supported signature) HttpSignProvider.builder() .outbound(OutboundConfig.builder() .addTarget(rsaTarget) .build()) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { outbound: [ { # Logical name of this outbound configuration name = \"service2-trust-circle\" # If ommited or one value is \"*\", all are supported transports = [\"http\", \"https\"] # If ommited or one value is \"*\", all are supported, may contain * as a sequence \"any\" characters/nubmers hosts = [\"service2\"] # If ommited, all are supported - regular expression paths = [\"/service2\"] # Configuration of signature (signing the request) signature { key-id = \"service2-shared-secret\" # HMAC shared secret (algorithm hmac-sha256) hmac.secret = \"${CLEAR=somePasswordForHmacShouldBeEncrypted}\" } }, { name = \"service2-rsa\" hosts = [\"service2\"] paths = [\"/service2-rsa\"] http://[] signature { key-id = \"service1-rsa\" # RSA private key (algorithm rsa-sha256) private-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # Keystore type # PKCS12, JSK or RSA (not really a keystore, but directly the linux style private key unencrypted) # defaults to jdk default keystore-type = \"PKCS12\" # password of the keystore keystore-passphrase = \"password\" # alias of the key to sign request key-alias = \"myPrivateKey\" } } } ] } ABAC (Attribute based access control) Authorization Provider This provider is an authorization provider validating various attributes against configured validators. Any attribute of the following objects can be used: - environment (such as time of request) - e.g. env.time.year - subject (user) - e.g. subject.principal.id - subject (service) - e.g. service.principal.id - object (must be explicitly invoked by developer in code, as object cannot be automatically added to security context) - e.g. object.owner This provider checks that all defined ABAC validators are validated. If there is a definition for a validator (e.g. an annotation) that is not checked, the request is denied. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-provider-abac&lt;/artifactId&gt; &lt;/dependency&gt; The following validators are implemented: Roles Scopes EL Policy Time <markup lang=\"java\" title=\"Example of using an object\" >@Authenticated @Path(\"/abac\") public class AbacResource { @GET @Authorized(explicit = true) @PolicyStatement(\"${env.time.year &gt;= 2017 &amp;&amp; object.owner == subject.principal.id}\") public Response process(@Context SecurityContext context) { // probably looked up from a database SomeResource res = new SomeResource(\"user\"); AuthorizationResponse atzResponse = context.authorize(res); if (atzResponse.isPermitted()) { //do the update return Response.ok().entity(\"fine, sir\").build(); } else { return Response.status(Response.Status.FORBIDDEN) .entity(atzResponse.getDescription().orElse(\"Access not granted\")) .build(); } } } Role Validator Checks whether user/service is in role(s) Configuration Key: role-validator Annotations: @RolesAllowed, @Roles <markup lang=\"java\" title=\"Example\" >@Roles(\"user_role\") @Roles(value = \"service_role\", subjectType = SubjectType.SERVICE) @Authenticated @Path(\"/abac\") public class AbacResource { } Scope Validator Checks whether user has the defined scopes Configuration Key: scope-validator Annotations: @Scope <markup lang=\"java\" title=\"Example\" >@Scope(\"calendar_read\") @Scope(\"calendar_edit\") @Authenticated @Path(\"/abac\") public class AbacResource { } Expression Language Policy Validator Policy executor using Java EE policy expression language (EL) Configuration Key: policy-javax-el Annotations: @PolicyStatement <markup lang=\"java\" title=\"Example\" >@PolicyStatement(\"${env.time.year &gt;= 2017}\") @Authenticated @Path(\"/abac\") public class AbacResource { } Time Validator Supports time of day and day of week checks Configuration Key: time-validator Annotations: @DaysOfWeek, @TimesOfDay <markup lang=\"java\" title=\"Example\" >@TimeOfDay(from = \"08:15:00\", to = \"12:00:00\") @TimeOfDay(from = \"12:30:00\", to = \"17:30:00\") @DaysOfWeek({DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY}) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Implemented Security Providers"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Although config values are originally text, you can use the config system&#8217;s built-in conversions or add your own to translate text into Java primitive types and simple objects (such as Double ) and to express parts of the config tree as complex types ( List , Map , and custom types specific to your application). This section introduces how to use the built-in mappings and your own custom ones to convert to simple and complext types. ",
            "title": "preambule"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html\"> Config class itself provides many conversions to Java types. See the JavaDoc for the complete list. The methods which support Java primitive types and their related classes follow a common pattern. The examples in the table below deal with conversion to a boolean but the same pattern applies to many data types listed in the JavaDoc. Assume a local variable has been assigned something like <markup lang=\"java\" >Config config = Config.get(\"someKey\"); Built-in Conversions to Simple Types (e.g., boolean) Java type Example usage 1 boolean boolean b = config.asBoolean(); 2 boolean defaultedB = config.asBoolean(true); 3 Supplier&lt;Boolean&gt; Boolean b = config.asBooleanSupplier().get(); Optional&lt;Boolean&gt; Boolean b = config.asOptionalBoolean().orElse(Boolean.TRUE); 4 Supplier&lt;Optional&lt;Boolean&gt;&gt; Boolean b = config.asOptionalBooleanSupplier().get().orElse(Boolean.TRUE); Notes on Built-in Conversions to Simple Types 1 All conversions can throw MissingValueException (if no value exists at the requested key) and ConfigMappingException (if some error occurred performing the data mapping). 2 The Config.asXXX methods internally use the Java-provided XXX.parseXXX methods, so here a missing or unparseable string gives false because that is how Boolean.parseBoolean behaves. 3 User code defaults the value to true . 4 User code defaults the value to Boolean.TRUE if absent; otherwise parses the value using Boolean.parseBoolean . The numerous conversions defined on the Config class for other types (integers, doubles, etc.) will satisfy many of your application&#8217;s needs. The <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigMappers.html\"> ConfigMappers class includes other related mappings from String (rather than from Config ) to Java types (described in the JavaDoc). For additional simple type mapping, you can use these methods defined on Config : <markup lang=\"java\" >T as(Class&lt;? extends T&gt; type); T as(Class&lt;? extends T&gt; type, T defaultValue); which maps a single String config value to a type. The next example, and later ones below showing complex type mapping, use the example application.properties configuration from the config introduction. Part of that example includes this line: <markup >bl.initial-id = 10000000000 Your application can use Config.as to interpret the value as a BigDecimal : <markup lang=\"java\" >BigDecimal initialId = config.get(\"bl.initial-id\").as(BigDecimal.class); ",
            "title": "Converting Configuration to Simple Types"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The Config class exposes several methods for mapping a structured config node to a Java List or Map . The <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html\">JavaDoc contains complete details, but briefly your application can convert a structured Config node into: a List&lt;T&gt; of a given type, with or without default values, an Optional&lt;List&lt;T&gt;&gt; , a Map&lt;String, String&gt; in which each key is the fully-qualified key String for a config entry and the value is its String value, or an Optional&lt;Map&lt;String, String&gt;&gt; . ",
            "title": "Built-in Conversions to List and Map "
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Any time your application has a Config instance to map to the target class it invokes Config.map passing an instance of the corresponding ConfigMapper implementation: <markup lang=\"java\" >Config config = Config.get(\"web\"); WebConfig web = config.map(new WebConfigMapper()); You do not necessarily need a new instance of the mapper every time you want to use it. In this approach, everywhere your application needs to perform this conversion it specifies the mapper to use. If you decided to change which mapper to use you would need to update each of those places in your application. ",
            "title": "Use Custom Mapper Explicitly: Config.map method"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " In this approach, your application: Tells each Config.Builder that needs to know about the custom mapper by either: registering an instance of your mapper by invoking Config.Builder.addMapper , or implementing <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigMapperProvider.html\"> ConfigMapperProvider so it returns an instance of your mapper (see the JavaDoc for complete information) and creating or editing the file io.helidon.config.spi.ConfigMapperProvider so it contains a line with the fully-qualified class name of your ConfigMapperProvider . The config system will use the Java service loader to find and invoke all ConfigMapperProvider classes listed and add the mappers they provide to each Config.Builder automatically. Converts using the mapper by invoking the Config.as method which accepts the target type to convert to, not the mapper itself that does the conversion. If your application converts to the same target type in several places in the code, this approach allows you to change which mapper it uses by changing only the registration of the mapper, not each use of it. ",
            "title": "Register Custom Mapper Once, Use Implicitly: Config.as method"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The following examples build on the example configuration from the application.properties example file in the introduction. <markup lang=\"java\" title=\"Java POJO to Hold web Properties Config\" >public class WebConfig { private boolean debug; private int pageSize; private double ratio; public WebConfig(boolean debug, int pageSize, double ratio) { this.debug = debug; this.pageSize = pageSize; this.ratio = ratio; } public boolean isDebug() { return debug; } public int getPageSize() { return pageSize; } public double getRatio() { return ratio; } } <markup lang=\"java\" title=\"Custom Mapper Class\" >public class WebConfigMapper implements ConfigMapper&lt;WebConfig&gt; { @Override public WebConfig apply(Config config) throws ConfigMappingException, MissingValueException { WebConfig web = new WebConfig( config.get(\"debug\").asBoolean(false), config.get(\"page-size\").asInt(10), config.get(\"ratio\").asDouble(1.0) ); return web; } } <markup lang=\"java\" title=\"Explicitly Using the Mapper\" >... Config config = Config.withSources(classpath(\"application.properties\")) .build(); WebConfig web = config.get(\"web\") .map(new WebConfigMapper()); <markup lang=\"java\" title=\"Registering and Implicitly Using the Mapper\" >... Config config = Config.withSources(classpath(\"application.properties\")) .addMapper(WebConfig.class, new WebConfigMapper()) .build(); WebConfig web = config.get(\"web\") .as(WebConfig.class); Either of the two approaches just described will always work without requiring you to change the POJO class. ",
            "title": "Continuing the Web Example"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Often your code will be simpler if you can treat parts of the configuration as custom, application-specific Java objects, rather than as a group of String keys and values. You will need customized conversions to do so. The config system provides many ways to accomplish this, described in the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/package-summary.html#conversions\"> io.helidon.config package JavaDoc . Some of those approaches require that the target class&#8201;&#8212;&#8201;the class to which you want to convert the configuration data&#8201;&#8212;&#8201;have certain characteristics or that you add a method to the class to help do the mapping. You might want to avoid changing the target class or you might not even be able to if you do not control its source. Here are two approaches that will always work without requiring changes to the target class. For both you write your own custom <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigMapper.html\"> ConfigMapper class. The difference is in how your application triggers the use of that mapper. Use Custom Mapper Explicitly: Config.map method Any time your application has a Config instance to map to the target class it invokes Config.map passing an instance of the corresponding ConfigMapper implementation: <markup lang=\"java\" >Config config = Config.get(\"web\"); WebConfig web = config.map(new WebConfigMapper()); You do not necessarily need a new instance of the mapper every time you want to use it. In this approach, everywhere your application needs to perform this conversion it specifies the mapper to use. If you decided to change which mapper to use you would need to update each of those places in your application. Register Custom Mapper Once, Use Implicitly: Config.as method In this approach, your application: Tells each Config.Builder that needs to know about the custom mapper by either: registering an instance of your mapper by invoking Config.Builder.addMapper , or implementing <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigMapperProvider.html\"> ConfigMapperProvider so it returns an instance of your mapper (see the JavaDoc for complete information) and creating or editing the file io.helidon.config.spi.ConfigMapperProvider so it contains a line with the fully-qualified class name of your ConfigMapperProvider . The config system will use the Java service loader to find and invoke all ConfigMapperProvider classes listed and add the mappers they provide to each Config.Builder automatically. Converts using the mapper by invoking the Config.as method which accepts the target type to convert to, not the mapper itself that does the conversion. If your application converts to the same target type in several places in the code, this approach allows you to change which mapper it uses by changing only the registration of the mapper, not each use of it. Continuing the Web Example The following examples build on the example configuration from the application.properties example file in the introduction. <markup lang=\"java\" title=\"Java POJO to Hold web Properties Config\" >public class WebConfig { private boolean debug; private int pageSize; private double ratio; public WebConfig(boolean debug, int pageSize, double ratio) { this.debug = debug; this.pageSize = pageSize; this.ratio = ratio; } public boolean isDebug() { return debug; } public int getPageSize() { return pageSize; } public double getRatio() { return ratio; } } <markup lang=\"java\" title=\"Custom Mapper Class\" >public class WebConfigMapper implements ConfigMapper&lt;WebConfig&gt; { @Override public WebConfig apply(Config config) throws ConfigMappingException, MissingValueException { WebConfig web = new WebConfig( config.get(\"debug\").asBoolean(false), config.get(\"page-size\").asInt(10), config.get(\"ratio\").asDouble(1.0) ); return web; } } <markup lang=\"java\" title=\"Explicitly Using the Mapper\" >... Config config = Config.withSources(classpath(\"application.properties\")) .build(); WebConfig web = config.get(\"web\") .map(new WebConfigMapper()); <markup lang=\"java\" title=\"Registering and Implicitly Using the Mapper\" >... Config config = Config.withSources(classpath(\"application.properties\")) .addMapper(WebConfig.class, new WebConfigMapper()) .build(); WebConfig web = config.get(\"web\") .as(WebConfig.class); Either of the two approaches just described will always work without requiring you to change the POJO class. ",
            "title": "Custom Conversions"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The hierarchical features section describes the tree structure used to represent config data. The config system can map subtrees of a config tree to complex Java types. Built-in Conversions to List and Map The Config class exposes several methods for mapping a structured config node to a Java List or Map . The <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html\">JavaDoc contains complete details, but briefly your application can convert a structured Config node into: a List&lt;T&gt; of a given type, with or without default values, an Optional&lt;List&lt;T&gt;&gt; , a Map&lt;String, String&gt; in which each key is the fully-qualified key String for a config entry and the value is its String value, or an Optional&lt;Map&lt;String, String&gt;&gt; . Custom Conversions Often your code will be simpler if you can treat parts of the configuration as custom, application-specific Java objects, rather than as a group of String keys and values. You will need customized conversions to do so. The config system provides many ways to accomplish this, described in the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/package-summary.html#conversions\"> io.helidon.config package JavaDoc . Some of those approaches require that the target class&#8201;&#8212;&#8201;the class to which you want to convert the configuration data&#8201;&#8212;&#8201;have certain characteristics or that you add a method to the class to help do the mapping. You might want to avoid changing the target class or you might not even be able to if you do not control its source. Here are two approaches that will always work without requiring changes to the target class. For both you write your own custom <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigMapper.html\"> ConfigMapper class. The difference is in how your application triggers the use of that mapper. Use Custom Mapper Explicitly: Config.map method Any time your application has a Config instance to map to the target class it invokes Config.map passing an instance of the corresponding ConfigMapper implementation: <markup lang=\"java\" >Config config = Config.get(\"web\"); WebConfig web = config.map(new WebConfigMapper()); You do not necessarily need a new instance of the mapper every time you want to use it. In this approach, everywhere your application needs to perform this conversion it specifies the mapper to use. If you decided to change which mapper to use you would need to update each of those places in your application. Register Custom Mapper Once, Use Implicitly: Config.as method In this approach, your application: Tells each Config.Builder that needs to know about the custom mapper by either: registering an instance of your mapper by invoking Config.Builder.addMapper , or implementing <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigMapperProvider.html\"> ConfigMapperProvider so it returns an instance of your mapper (see the JavaDoc for complete information) and creating or editing the file io.helidon.config.spi.ConfigMapperProvider so it contains a line with the fully-qualified class name of your ConfigMapperProvider . The config system will use the Java service loader to find and invoke all ConfigMapperProvider classes listed and add the mappers they provide to each Config.Builder automatically. Converts using the mapper by invoking the Config.as method which accepts the target type to convert to, not the mapper itself that does the conversion. If your application converts to the same target type in several places in the code, this approach allows you to change which mapper it uses by changing only the registration of the mapper, not each use of it. Continuing the Web Example The following examples build on the example configuration from the application.properties example file in the introduction. <markup lang=\"java\" title=\"Java POJO to Hold web Properties Config\" >public class WebConfig { private boolean debug; private int pageSize; private double ratio; public WebConfig(boolean debug, int pageSize, double ratio) { this.debug = debug; this.pageSize = pageSize; this.ratio = ratio; } public boolean isDebug() { return debug; } public int getPageSize() { return pageSize; } public double getRatio() { return ratio; } } <markup lang=\"java\" title=\"Custom Mapper Class\" >public class WebConfigMapper implements ConfigMapper&lt;WebConfig&gt; { @Override public WebConfig apply(Config config) throws ConfigMappingException, MissingValueException { WebConfig web = new WebConfig( config.get(\"debug\").asBoolean(false), config.get(\"page-size\").asInt(10), config.get(\"ratio\").asDouble(1.0) ); return web; } } <markup lang=\"java\" title=\"Explicitly Using the Mapper\" >... Config config = Config.withSources(classpath(\"application.properties\")) .build(); WebConfig web = config.get(\"web\") .map(new WebConfigMapper()); <markup lang=\"java\" title=\"Registering and Implicitly Using the Mapper\" >... Config config = Config.withSources(classpath(\"application.properties\")) .addMapper(WebConfig.class, new WebConfigMapper()) .build(); WebConfig web = config.get(\"web\") .as(WebConfig.class); Either of the two approaches just described will always work without requiring you to change the POJO class. ",
            "title": "Converting Configuration to Complex Types"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If you can change the target class you can add any one of the following methods or constructors to the POJO class which the config system will find and use for mapping. Methods Supporting Auto-mapping static WebConfig from(Config); static WebConfig from(String); static WebConfig valueOf(Config); static WebConfig valueOf(String); static WebConfig fromConfig(Config); static WebConfig fromString(String); Constructors Supporting Auto-mapping WebConfig(Config); WebConfig(String); If the config system finds any of these methods or constructors when the application invokes <markup lang=\"java\" >WebConfig wc = config.as(WebConfig.class); it will invoke the one it found to map the config data to a new instance of the target class. You do not need to write a separate class to do the mapping or register it with the Config.Builder for the config instance. ",
            "title": "Adding the Mapping to the POJO"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " You can limit the changes to the POJO class by adding a single builder method to the POJO which returns a builder class for the POJO: <markup lang=\"java\" >public class WebConfig { ... static WebConfigBuilder builder() { return new WebConfigBuilder(); } ... } The builder class WebConfigBuilder is expected to be a Java Bean with bean properties named for the config properties of interest, and a method WebConfig build() which creates the mapped instance from the builder&#8217;s own bean properties. When your application invokes config.as(WebConfig.class) the config system finds and invokes the WebConfig.builder() method, assigns the bean properties on the returned builder from the config subtree rooted at config , and invokes the builder&#8217;s build() method yielding the resulting WebConfig instance. ",
            "title": "Writing a Builder Method and Class for the POJO"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If the target Java class you want to use meets certain conditions&#8201;&#8212;&#8201;or if you can change it to meet one of those conditions&#8201;&#8212;&#8201;you might not need to write a separate mapper class. Instead, you add the mapping logic to the POJO itself in one of several ways and the config system uses Java reflection to search for those ways to perform the mapping. Your application facilitates this implicit mapping either by adding to the POJO class or by providing a builder class for it. Adding the Mapping to the POJO If you can change the target class you can add any one of the following methods or constructors to the POJO class which the config system will find and use for mapping. Methods Supporting Auto-mapping static WebConfig from(Config); static WebConfig from(String); static WebConfig valueOf(Config); static WebConfig valueOf(String); static WebConfig fromConfig(Config); static WebConfig fromString(String); Constructors Supporting Auto-mapping WebConfig(Config); WebConfig(String); If the config system finds any of these methods or constructors when the application invokes <markup lang=\"java\" >WebConfig wc = config.as(WebConfig.class); it will invoke the one it found to map the config data to a new instance of the target class. You do not need to write a separate class to do the mapping or register it with the Config.Builder for the config instance. Writing a Builder Method and Class for the POJO You can limit the changes to the POJO class by adding a single builder method to the POJO which returns a builder class for the POJO: <markup lang=\"java\" >public class WebConfig { ... static WebConfigBuilder builder() { return new WebConfigBuilder(); } ... } The builder class WebConfigBuilder is expected to be a Java Bean with bean properties named for the config properties of interest, and a method WebConfig build() which creates the mapped instance from the builder&#8217;s own bean properties. When your application invokes config.as(WebConfig.class) the config system finds and invokes the WebConfig.builder() method, assigns the bean properties on the returned builder from the config subtree rooted at config , and invokes the builder&#8217;s build() method yielding the resulting WebConfig instance. ",
            "title": "Advanced Conversions using Explicit Mapping Logic"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If your POJO target class is already a JavaBean&#8201;&#8212;&#8201;or you can modify it to become one&#8201;&#8212;&#8201;you might be able to avoid writing any explicit mapping code yourself. The config system invokes the no-args constructor on the target class to create a new instance. It treats each public setter method and each public non-final field as a JavaBean property. The config system processes any non-primitive property recursively as a JavaBean. In this way the config system builds up the target object from the config data. By default, the system matches potential JavaBean property names with config keys in the configuration. Use the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Value.html\"> Config.Value annnotation to control some of the JavaBean processing for a given property. Config.Value Annotation Attribute Usage key Indicates which config key should match this JavaBean property withDefault String used for the bean property default value if none is set in the config withDefaultSupplier Supplier of the default bean property value if nont is set in the config To exclude a bean property from the config system bean processing annotate it with <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Transient.html\"> Config.Transient . Here is an example using the app portion of the example configuration from the introduction. <markup lang=\"java\" title=\"Java bean to load app propeties into via setters\" >public class AppConfig { private Instant timestamp; private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; public AppConfig() { } public void setGreeting(String greeting) { this.greeting = greeting; } public String getGreeting() { return greeting; } @Config.Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } public int getPageSize() { return pageSize; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } @Config.Transient public void setTimestamp(Instant timestamp) { this.timestamp = timestamp; } public Instant getTimestamp() { return timestamp; } public static class BasicRangeSupplier implements Supplier&lt;List&lt;Integer&gt;&gt; { @Override public List&lt;Integer&gt; get() { return List.of(-10, 10); } } } Public no-parameter constructor. Property greeting is not customized and will be set from the config node with the key greeting , if present in the config. Property pageSize is matched to the config key page-size . If the page-size config node does not exist, the pageSize bean property defaults to 10 . Property basicRange is matched to the config key basic-range . If the basic-range config node does not exist, a BasicRangeSupplier instance will provide the default value. The timestamp bean property is never set, even if the config contains a node with the key timestamp . BasicRangeSupplier is used to supply the List&lt;Integer&gt; default value. Here is an example of code loading config and mapping part of it to the AppConfig bean above. <markup lang=\"java\" title=\"Map app config node into AppConfig class\" >Config config = Config.from(classpath(\"application.conf\")); AppConfig app = config.get(\"app\") .as(AppConfig.class); //assert that all values are loaded from file assert app.getGreeting().equals(\"Hello\"); assert app.getPageSize() == 20; assert app.getBasicRange().size() == 2 &amp;&amp; app.getBasicRange().get(0) == -20 &amp;&amp; app.getBasicRange().get(1) == 20; //assert that Transient property is not set assert app.getTimestamp() == null; The config system finds no registered ConfigMapper for AppConfig and so applies the JavaBean pattern to convert the config to an AppConfig instance. Because the bean property timestamp was marked as transient, the config system did not set it. ",
            "title": "POJO as JavaBean"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Here is one way to use this feature: <markup lang=\"java\" title=\"JavaBean for app properties, via a Builder \" >public class AppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static Builder builder() { return new Builder(); } public static class Builder { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private Builder() { } public void setGreeting(String greeting) { this.greeting = greeting; } @Config.Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public AppConfig build() { return new AppConfig(greeting, pageSize, basicRange); } } } The target class&#8217;s constructor can be private in this case because new instances are created from the inner class Builder which has access to `AppConfig&#8217;s private members. The target class contains public static method builder() which returns an object that itself exposes the method AppConfig build() , so the config system recognizes it. The config system treats the AppConfig.Builder (not the enclosing target class) as a JavaBean. The builder&#8217;s property greeting is not customized and is set from config node with greeting key, if one exists. The builder&#8217;s property pageSize maps to the config key page-size and defaults to 10 if absent. The builder&#8217;s property basicRange maps to the config key basic-range and uses a BasicRangeSupplier instance to get a default value if needed. Finally, the config system invokes the builder&#8217;s public method build() , creating the new instance of AppConfig for use by the application. ",
            "title": "Add builder() to Target Class"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If you cannot or do not want to add the builder() method to the target class, you can instead associate a separate builder to be processed as a JavaBean with the target class. This example shows the target type as a Java interface instead of a class. Either will work. <markup lang=\"java\" title=\"Target Type IAppConfig \" >public interface IAppConfig { String getGreeting(); int getPageSize(); List&lt;Integer&gt; getBasicRange(); } <markup lang=\"java\" title=\"Separate BuilderImpl with an implementation AppConfigImpl of IAppConfig\" >public class BuilderImpl { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; public BuilderImpl() { } @Config.Value(key = \"greeting\") public BuilderImpl greeting(String greeting) { this.greeting = greeting; return this; } @Config.Value(key = \"page-size\", withDefault = \"10\") public BuilderImpl pageSize(int pageSize) { this.pageSize = pageSize; return this; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public BuilderImpl basicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; return this; } public IAppConfig build() { return new AppConfigImpl(greeting, pageSize, basicRange); } /** * Private implementation provided by {@link BuilderImpl}. */ private static class AppConfigImpl implements IAppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfigImpl(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } @Override public String getGreeting() { return greeting; } @Override public int getPageSize() { return pageSize; } @Override public List&lt;Integer&gt; getBasicRange() { return basicRange; } } } Class BuilderImpl must be public including, its public no-args constructor, because the config system instantiates it. The builder can use the builder pattern (the methods return the builder itself so the caller can chain calls together) instead of the usual JavaBean setter method pattern. In that case, decorate each builder method (e.g, greeting ) using @Config.Value to associate it with the correct config key. The builder&#8217;s build() is declared to return IAppConfig and in fact returns an instance of AppConfigImpl which implements IAppConfig . The AppConfigImpl class can be private to the builder because the builder itself instantiates it and all other code will use the IAppConfig interface to access the mapped config data. Because the config system cannot infer a link between the target class and the separate builder, the application makes that link explicit to the Config.Builder : <markup lang=\"java\" title=\"Register BuilderImpl as IAppConfig mapper\" >Config config = Config.withSources(classpath(\"application.conf\")) .addMapper(IAppConfig.class, ConfigMappers.from(IAppConfig.class, BuilderImpl.class)) .build(); IAppConfig app = config.get(\"app\") .as(IAppConfig.class); Programmatically registers the mapper for the IAppConfig interface. Creates a config mapper for IAppConfig that uses BuilderImpl by invoking the convenience method ConfigMappers.from(type, builder) . Config system uses BuilderImpl to map the config subtree to IAppConfig . ",
            "title": "Write a Builder Separate from the Target Class"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If the target class includes the public static method builder() that returns any object, then the config system will make sure that the return type has a method build() which returns an instance of the target class. If so, the config system treats the builder as a JavaBean and invokes the builder() method to instantiate the builder class, treats the builder as a JavaBean and maps the Config subtree to it, invokes the builder&#8217;s build() method to create the new instance of the target class. There are two ways to use this feature: 1. Augment the target class with the public static builder() method. 2. Write a separate builder class and tell the Config.Builder to associate the target class and the builder class. Add builder() to Target Class Here is one way to use this feature: <markup lang=\"java\" title=\"JavaBean for app properties, via a Builder \" >public class AppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static Builder builder() { return new Builder(); } public static class Builder { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private Builder() { } public void setGreeting(String greeting) { this.greeting = greeting; } @Config.Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public AppConfig build() { return new AppConfig(greeting, pageSize, basicRange); } } } The target class&#8217;s constructor can be private in this case because new instances are created from the inner class Builder which has access to `AppConfig&#8217;s private members. The target class contains public static method builder() which returns an object that itself exposes the method AppConfig build() , so the config system recognizes it. The config system treats the AppConfig.Builder (not the enclosing target class) as a JavaBean. The builder&#8217;s property greeting is not customized and is set from config node with greeting key, if one exists. The builder&#8217;s property pageSize maps to the config key page-size and defaults to 10 if absent. The builder&#8217;s property basicRange maps to the config key basic-range and uses a BasicRangeSupplier instance to get a default value if needed. Finally, the config system invokes the builder&#8217;s public method build() , creating the new instance of AppConfig for use by the application. Write a Builder Separate from the Target Class If you cannot or do not want to add the builder() method to the target class, you can instead associate a separate builder to be processed as a JavaBean with the target class. This example shows the target type as a Java interface instead of a class. Either will work. <markup lang=\"java\" title=\"Target Type IAppConfig \" >public interface IAppConfig { String getGreeting(); int getPageSize(); List&lt;Integer&gt; getBasicRange(); } <markup lang=\"java\" title=\"Separate BuilderImpl with an implementation AppConfigImpl of IAppConfig\" >public class BuilderImpl { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; public BuilderImpl() { } @Config.Value(key = \"greeting\") public BuilderImpl greeting(String greeting) { this.greeting = greeting; return this; } @Config.Value(key = \"page-size\", withDefault = \"10\") public BuilderImpl pageSize(int pageSize) { this.pageSize = pageSize; return this; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public BuilderImpl basicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; return this; } public IAppConfig build() { return new AppConfigImpl(greeting, pageSize, basicRange); } /** * Private implementation provided by {@link BuilderImpl}. */ private static class AppConfigImpl implements IAppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfigImpl(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } @Override public String getGreeting() { return greeting; } @Override public int getPageSize() { return pageSize; } @Override public List&lt;Integer&gt; getBasicRange() { return basicRange; } } } Class BuilderImpl must be public including, its public no-args constructor, because the config system instantiates it. The builder can use the builder pattern (the methods return the builder itself so the caller can chain calls together) instead of the usual JavaBean setter method pattern. In that case, decorate each builder method (e.g, greeting ) using @Config.Value to associate it with the correct config key. The builder&#8217;s build() is declared to return IAppConfig and in fact returns an instance of AppConfigImpl which implements IAppConfig . The AppConfigImpl class can be private to the builder because the builder itself instantiates it and all other code will use the IAppConfig interface to access the mapped config data. Because the config system cannot infer a link between the target class and the separate builder, the application makes that link explicit to the Config.Builder : <markup lang=\"java\" title=\"Register BuilderImpl as IAppConfig mapper\" >Config config = Config.withSources(classpath(\"application.conf\")) .addMapper(IAppConfig.class, ConfigMappers.from(IAppConfig.class, BuilderImpl.class)) .build(); IAppConfig app = config.get(\"app\") .as(IAppConfig.class); Programmatically registers the mapper for the IAppConfig interface. Creates a config mapper for IAppConfig that uses BuilderImpl by invoking the convenience method ConfigMappers.from(type, builder) . Config system uses BuilderImpl to map the config subtree to IAppConfig . ",
            "title": "Builder as JavaBean"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Another option is to annotate the parameters to a factory method or to a constructor on the target class. You can add a factory method to the target class, a public static method from with parameters annotated to link them to the corresponding config keys. Or you can add or modify a constructor with parameters, similarly annotated to form the link from each parameter to the corresponding config key. Warning Be sure to annotate each parameter of the from method or constructor with @Value and specify the key to use for the mapping. The parameter names in the Java code are not always available at runtime to map to config keys. (They might be arg0 , arg1 , etc.) <markup lang=\"java\" title=\"Target Class with Factory Method from \" >public class AppConfig { private final String greeting; private final int pageSize; private final List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static AppConfig from( @Config.Value(key = \"greeting\") String greeting, @Config.Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { return new AppConfig(greeting, pageSize, basicRange); } } The target class constructor can be private because the factory method on the same class has access to it. The config system invokes the factory method from(&#8230;&#8203;) , passing arguments it has fetched from the correspondingly-named config subtrees. The factory method returns the new initialized AppConfig instance. Note the consistent use of @Config.Value(key = \"&#8230;&#8203;\") on each parameter. Because the property greeting does not specify a default value the property is mandatory and must appear in the configuration source. Otherwise the config system throws a ConfigMappingException . Alternatively, you can use an annotated constructor instead of a static factory method. Revising the example above, make the constructor public, annotate its parameters, and remove the now-unneeded from factory method. <markup lang=\"java\" title=\"Target Class with Annotated Public Constructor\" >public class AppConfig { ... public AppConfig( @Config.Value(key = \"greeting\") String greeting, @Config.Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } Constructor is public . Each parameter has the ConfigValue annotation to at least specify the config key name. When the application invokes config.as(AppConfig.class) , the config system locates the public annotated constructor and invokes it, passing as arguments the data it fetches from the configuration matching the annotation key names with the configuration keys. ",
            "title": "Target Class with Annotated Factory Method or Constructor"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The config system can also interpret your classes as JavaBeans and use the normal bean naming conventions to map configuration data to your POJO classes, using one of these patterns: POJO as JavaBean - The config system treats the target class itself as a JavaBean, assigning values from the config to the bean properties of the POJO class. builder as JavaBean - The config system invokes the POJO&#8217;s builder() method to obtain a builder for that POJO type and treats the builder class as a JavaBean, assigning values from the config to the builder&#8217;s bean properties and then invoking the builder&#8217;s build method to create an instance of the target POJO class. POJO with factory method or decorated constructor - The config system finds a from method or a constructor on the POJO class itself which accepts annotated arguments, then invokes that method or constructor passing the specified arguments based on the config. The from method returns an instance of the POJO class initialized with the values passed as arguments. The following sections describe these patterns in more detail. POJO as JavaBean If your POJO target class is already a JavaBean&#8201;&#8212;&#8201;or you can modify it to become one&#8201;&#8212;&#8201;you might be able to avoid writing any explicit mapping code yourself. The config system invokes the no-args constructor on the target class to create a new instance. It treats each public setter method and each public non-final field as a JavaBean property. The config system processes any non-primitive property recursively as a JavaBean. In this way the config system builds up the target object from the config data. By default, the system matches potential JavaBean property names with config keys in the configuration. Use the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Value.html\"> Config.Value annnotation to control some of the JavaBean processing for a given property. Config.Value Annotation Attribute Usage key Indicates which config key should match this JavaBean property withDefault String used for the bean property default value if none is set in the config withDefaultSupplier Supplier of the default bean property value if nont is set in the config To exclude a bean property from the config system bean processing annotate it with <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Transient.html\"> Config.Transient . Here is an example using the app portion of the example configuration from the introduction. <markup lang=\"java\" title=\"Java bean to load app propeties into via setters\" >public class AppConfig { private Instant timestamp; private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; public AppConfig() { } public void setGreeting(String greeting) { this.greeting = greeting; } public String getGreeting() { return greeting; } @Config.Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } public int getPageSize() { return pageSize; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } @Config.Transient public void setTimestamp(Instant timestamp) { this.timestamp = timestamp; } public Instant getTimestamp() { return timestamp; } public static class BasicRangeSupplier implements Supplier&lt;List&lt;Integer&gt;&gt; { @Override public List&lt;Integer&gt; get() { return List.of(-10, 10); } } } Public no-parameter constructor. Property greeting is not customized and will be set from the config node with the key greeting , if present in the config. Property pageSize is matched to the config key page-size . If the page-size config node does not exist, the pageSize bean property defaults to 10 . Property basicRange is matched to the config key basic-range . If the basic-range config node does not exist, a BasicRangeSupplier instance will provide the default value. The timestamp bean property is never set, even if the config contains a node with the key timestamp . BasicRangeSupplier is used to supply the List&lt;Integer&gt; default value. Here is an example of code loading config and mapping part of it to the AppConfig bean above. <markup lang=\"java\" title=\"Map app config node into AppConfig class\" >Config config = Config.from(classpath(\"application.conf\")); AppConfig app = config.get(\"app\") .as(AppConfig.class); //assert that all values are loaded from file assert app.getGreeting().equals(\"Hello\"); assert app.getPageSize() == 20; assert app.getBasicRange().size() == 2 &amp;&amp; app.getBasicRange().get(0) == -20 &amp;&amp; app.getBasicRange().get(1) == 20; //assert that Transient property is not set assert app.getTimestamp() == null; The config system finds no registered ConfigMapper for AppConfig and so applies the JavaBean pattern to convert the config to an AppConfig instance. Because the bean property timestamp was marked as transient, the config system did not set it. Builder as JavaBean If the target class includes the public static method builder() that returns any object, then the config system will make sure that the return type has a method build() which returns an instance of the target class. If so, the config system treats the builder as a JavaBean and invokes the builder() method to instantiate the builder class, treats the builder as a JavaBean and maps the Config subtree to it, invokes the builder&#8217;s build() method to create the new instance of the target class. There are two ways to use this feature: 1. Augment the target class with the public static builder() method. 2. Write a separate builder class and tell the Config.Builder to associate the target class and the builder class. Add builder() to Target Class Here is one way to use this feature: <markup lang=\"java\" title=\"JavaBean for app properties, via a Builder \" >public class AppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static Builder builder() { return new Builder(); } public static class Builder { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private Builder() { } public void setGreeting(String greeting) { this.greeting = greeting; } @Config.Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public AppConfig build() { return new AppConfig(greeting, pageSize, basicRange); } } } The target class&#8217;s constructor can be private in this case because new instances are created from the inner class Builder which has access to `AppConfig&#8217;s private members. The target class contains public static method builder() which returns an object that itself exposes the method AppConfig build() , so the config system recognizes it. The config system treats the AppConfig.Builder (not the enclosing target class) as a JavaBean. The builder&#8217;s property greeting is not customized and is set from config node with greeting key, if one exists. The builder&#8217;s property pageSize maps to the config key page-size and defaults to 10 if absent. The builder&#8217;s property basicRange maps to the config key basic-range and uses a BasicRangeSupplier instance to get a default value if needed. Finally, the config system invokes the builder&#8217;s public method build() , creating the new instance of AppConfig for use by the application. Write a Builder Separate from the Target Class If you cannot or do not want to add the builder() method to the target class, you can instead associate a separate builder to be processed as a JavaBean with the target class. This example shows the target type as a Java interface instead of a class. Either will work. <markup lang=\"java\" title=\"Target Type IAppConfig \" >public interface IAppConfig { String getGreeting(); int getPageSize(); List&lt;Integer&gt; getBasicRange(); } <markup lang=\"java\" title=\"Separate BuilderImpl with an implementation AppConfigImpl of IAppConfig\" >public class BuilderImpl { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; public BuilderImpl() { } @Config.Value(key = \"greeting\") public BuilderImpl greeting(String greeting) { this.greeting = greeting; return this; } @Config.Value(key = \"page-size\", withDefault = \"10\") public BuilderImpl pageSize(int pageSize) { this.pageSize = pageSize; return this; } @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public BuilderImpl basicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; return this; } public IAppConfig build() { return new AppConfigImpl(greeting, pageSize, basicRange); } /** * Private implementation provided by {@link BuilderImpl}. */ private static class AppConfigImpl implements IAppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfigImpl(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } @Override public String getGreeting() { return greeting; } @Override public int getPageSize() { return pageSize; } @Override public List&lt;Integer&gt; getBasicRange() { return basicRange; } } } Class BuilderImpl must be public including, its public no-args constructor, because the config system instantiates it. The builder can use the builder pattern (the methods return the builder itself so the caller can chain calls together) instead of the usual JavaBean setter method pattern. In that case, decorate each builder method (e.g, greeting ) using @Config.Value to associate it with the correct config key. The builder&#8217;s build() is declared to return IAppConfig and in fact returns an instance of AppConfigImpl which implements IAppConfig . The AppConfigImpl class can be private to the builder because the builder itself instantiates it and all other code will use the IAppConfig interface to access the mapped config data. Because the config system cannot infer a link between the target class and the separate builder, the application makes that link explicit to the Config.Builder : <markup lang=\"java\" title=\"Register BuilderImpl as IAppConfig mapper\" >Config config = Config.withSources(classpath(\"application.conf\")) .addMapper(IAppConfig.class, ConfigMappers.from(IAppConfig.class, BuilderImpl.class)) .build(); IAppConfig app = config.get(\"app\") .as(IAppConfig.class); Programmatically registers the mapper for the IAppConfig interface. Creates a config mapper for IAppConfig that uses BuilderImpl by invoking the convenience method ConfigMappers.from(type, builder) . Config system uses BuilderImpl to map the config subtree to IAppConfig . Target Class with Annotated Factory Method or Constructor Another option is to annotate the parameters to a factory method or to a constructor on the target class. You can add a factory method to the target class, a public static method from with parameters annotated to link them to the corresponding config keys. Or you can add or modify a constructor with parameters, similarly annotated to form the link from each parameter to the corresponding config key. Warning Be sure to annotate each parameter of the from method or constructor with @Value and specify the key to use for the mapping. The parameter names in the Java code are not always available at runtime to map to config keys. (They might be arg0 , arg1 , etc.) <markup lang=\"java\" title=\"Target Class with Factory Method from \" >public class AppConfig { private final String greeting; private final int pageSize; private final List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static AppConfig from( @Config.Value(key = \"greeting\") String greeting, @Config.Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { return new AppConfig(greeting, pageSize, basicRange); } } The target class constructor can be private because the factory method on the same class has access to it. The config system invokes the factory method from(&#8230;&#8203;) , passing arguments it has fetched from the correspondingly-named config subtrees. The factory method returns the new initialized AppConfig instance. Note the consistent use of @Config.Value(key = \"&#8230;&#8203;\") on each parameter. Because the property greeting does not specify a default value the property is mandatory and must appear in the configuration source. Otherwise the config system throws a ConfigMappingException . Alternatively, you can use an annotated constructor instead of a static factory method. Revising the example above, make the constructor public, annotate its parameters, and remove the now-unneeded from factory method. <markup lang=\"java\" title=\"Target Class with Annotated Public Constructor\" >public class AppConfig { ... public AppConfig( @Config.Value(key = \"greeting\") String greeting, @Config.Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Config.Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } Constructor is public . Each parameter has the ConfigValue annotation to at least specify the config key name. When the application invokes config.as(AppConfig.class) , the config system locates the public annotated constructor and invokes it, passing as arguments the data it fetches from the configuration matching the annotation key names with the configuration keys. ",
            "title": "Conversions using JavaBean Deserialization"
        },
        {
            "location": "/webserver/01_introduction",
            "text": " WebServer provides an asynchonous and reactive API for creating web applications. The API is inspired by popular NodeJS and Java frameworks. ",
            "title": "preambule"
        },
        {
            "location": "/webserver/01_introduction",
            "text": " Here is the code for a minimalist web application that runs on a random free port: <markup lang=\"java\" > public static void main(String[] args) throws Exception { WebServer webServer = WebServer .create(Routing.builder() .any((req, res) -&gt; res.send(\"It works!\")) .build()) .start() .toCompletableFuture() .get(10, TimeUnit.SECONDS); System.out.println(\"Server started at: http://localhost:\" + webServer.port()); } For any kind of request, at any path, respond with It works! . Start the server. Wait for the server to start while throwing possible errors as exceptions. The server is bound to a random free port. ",
            "title": "Quick Start"
        },
        {
            "location": "/webserver/01_introduction",
            "text": " Declare the following dependencies in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-netty&lt;/artifactId&gt; &lt;/dependency&gt; Dependency on WebServer. TCP Server implementation module, in this case, the Netty-based one. ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/06_static-content-support",
            "text": " Use the StaticContentSupport class to serve files and classpath resources. StaticContentSupport can be created for any readable directory or classpath context root and registered on a path in Routing . You can combine dynamic handlers with StaticContentSupport objects: if no file matches the request path, then the request is forwarded to the next handler. <markup lang=\"java\" >Routing.builder() .register(\"/pictures\", StaticContentSupport.create(Paths.get(\"/some/WEB/pics\")) .register(\"/\", StaticContentSupport.builder(\"/static-content\") .welcomeFileName(\"index.html\") .build()); Create a new StaticContentSupport object to serve data from the file system, and associate it with the \"/pictures\" context path. Create a StaticContentSupport object to serve resources from the contextual ClassLoader . The specific classloader can be also defined. A builder lets you provide more configuration values. index.html is the file that is returned if a directory is requested. A StaticContentSupport object can be created using create(&#8230;&#8203;) factory methods or a builder . The builder lets you provide more configuration values, including welcome file-name and mappings of filename extensions to media types. ",
            "title": "Static Content Support"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " There are two steps to configure security with web server: Create security instance and register it with server Protect routes of web server with various security features <markup lang=\"java\" title=\"Example using builders\" >// web server's Routing Routing.builder() // This is step 1 - register security instance with web server processing // security - instance of security either from config or from a builder // gateDefaults - default enforcement for each route that hase a security gate // (to be changed in the future to \"securedDefaults\" and \"secured\") .register(WebSecurity.from(security).gateDefaults(WebSecurity.authenticate())) // this is step 2 - protect a route // protect this route with authentication (from defaults) and role \"user\" .get(\"/service1\", WebSecurity.rolesAllowed(\"user\"), (req, res) -&gt; { processService1Request(req, res); }) .build(); <markup lang=\"java\" title=\"Example using configuration\" >Routing.builder() // helper method to load both security and web server security from configuration .register(WebSecurity.from(config)) // continue with web server route configuration .build(); <markup lang=\"conf\" title=\"Example using configuration - configuration (HOCON)\" ># This may change in the future - to align with web server configuration, once it is supported security.web-server { # Configuration of integration with web server defaults { authenticate = true } paths: [ { path = \"/service1\" methods = [\"get\"] roles-allowed = [\"user\"] } ] } ",
            "title": "Bootstrapping"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " Integration of reactive web server <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-webserver&lt;/artifactId&gt; &lt;/dependency&gt; Bootstrapping There are two steps to configure security with web server: Create security instance and register it with server Protect routes of web server with various security features <markup lang=\"java\" title=\"Example using builders\" >// web server's Routing Routing.builder() // This is step 1 - register security instance with web server processing // security - instance of security either from config or from a builder // gateDefaults - default enforcement for each route that hase a security gate // (to be changed in the future to \"securedDefaults\" and \"secured\") .register(WebSecurity.from(security).gateDefaults(WebSecurity.authenticate())) // this is step 2 - protect a route // protect this route with authentication (from defaults) and role \"user\" .get(\"/service1\", WebSecurity.rolesAllowed(\"user\"), (req, res) -&gt; { processService1Request(req, res); }) .build(); <markup lang=\"java\" title=\"Example using configuration\" >Routing.builder() // helper method to load both security and web server security from configuration .register(WebSecurity.from(config)) // continue with web server route configuration .build(); <markup lang=\"conf\" title=\"Example using configuration - configuration (HOCON)\" ># This may change in the future - to align with web server configuration, once it is supported security.web-server { # Configuration of integration with web server defaults { authenticate = true } paths: [ { path = \"/service1\" methods = [\"get\"] roles-allowed = [\"user\"] } ] } ",
            "title": "Web server"
        },
        {
            "location": "/security/03_containers-integration",
            "text": "<markup lang=\"java\" title=\"Integrate with Jersey\" >ResourceConfig resourceConfig = new ResourceConfig() // register JAX-RS resource .register(JaxRsResource.class) // integrate security .register(new io.helidon.security.jersey.SecurityFeature(security)); ",
            "title": "Inbound security"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " Integration of Jersey (JAX-RS implementation) both for inbound and outbound security. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-jersey&lt;/artifactId&gt; &lt;/dependency&gt; Inbound security <markup lang=\"java\" title=\"Integrate with Jersey\" >ResourceConfig resourceConfig = new ResourceConfig() // register JAX-RS resource .register(JaxRsResource.class) // integrate security .register(new io.helidon.security.jersey.SecurityFeature(security)); ",
            "title": "Jersey"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " The current approach does not have a configuration option. The security must be configured through annotations. Security currently supports @Authenticated and @Authorized. When a resource is annotated with one of these annotations (application class, resource class, or resource method), security will be triggered. <markup lang=\"java\" title=\"Securing a resource method\" >// this is sufficient for security to be triggered, see javadoc for further details @Authenticated @Path(\"/{name}\") @GET @Produces(MediaType.TEXT_PLAIN) // due to Jersey approach to path matching, we need two methods to match both the \"root\" and \"root\" + subpaths public String getHelloName(@PathParam(\"name\") String name) { return \"Hello \" + name + \", your current subject: \" + securityContext.getSubject(); } ",
            "title": "Protecting a resource"
        },
        {
            "location": "/security/03_containers-integration",
            "text": "<markup lang=\"java\" title=\"Call remote target with outbound security\" >// I expect you have injected the ClientSecurityFeature as shown above Client client = ClientBuilder.newClient() // integrate security .register(new ClientSecurityFeature()); try { // call the resource, will propagate identity as configured in Security String response = client.target(\"http://www.google.com\") .request() // configure the security context for this request (as client and targets may be re-used) .property(ClientSecurityFeature.PROPERTY_CONTEXT, securityContext) .get(String.class); } finally { client.close(); } ",
            "title": "Outbound security"
        },
        {
            "location": "/security/03_containers-integration",
            "text": "<markup lang=\"java\" title=\"Support in a JAX-RS resource\" >// inject io.helidon.security.SecurityContext @Context private SecurityContext securityContext; Outbound security <markup lang=\"java\" title=\"Call remote target with outbound security\" >// I expect you have injected the ClientSecurityFeature as shown above Client client = ClientBuilder.newClient() // integrate security .register(new ClientSecurityFeature()); try { // call the resource, will propagate identity as configured in Security String response = client.target(\"http://www.google.com\") .request() // configure the security context for this request (as client and targets may be re-used) .property(ClientSecurityFeature.PROPERTY_CONTEXT, securityContext) .get(String.class); } finally { client.close(); } ",
            "title": "Access context"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " The following containers are integrated with Cloud Security: Web server Integration of reactive web server <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-webserver&lt;/artifactId&gt; &lt;/dependency&gt; Bootstrapping There are two steps to configure security with web server: Create security instance and register it with server Protect routes of web server with various security features <markup lang=\"java\" title=\"Example using builders\" >// web server's Routing Routing.builder() // This is step 1 - register security instance with web server processing // security - instance of security either from config or from a builder // gateDefaults - default enforcement for each route that hase a security gate // (to be changed in the future to \"securedDefaults\" and \"secured\") .register(WebSecurity.from(security).gateDefaults(WebSecurity.authenticate())) // this is step 2 - protect a route // protect this route with authentication (from defaults) and role \"user\" .get(\"/service1\", WebSecurity.rolesAllowed(\"user\"), (req, res) -&gt; { processService1Request(req, res); }) .build(); <markup lang=\"java\" title=\"Example using configuration\" >Routing.builder() // helper method to load both security and web server security from configuration .register(WebSecurity.from(config)) // continue with web server route configuration .build(); <markup lang=\"conf\" title=\"Example using configuration - configuration (HOCON)\" ># This may change in the future - to align with web server configuration, once it is supported security.web-server { # Configuration of integration with web server defaults { authenticate = true } paths: [ { path = \"/service1\" methods = [\"get\"] roles-allowed = [\"user\"] } ] } Jersey Integration of Jersey (JAX-RS implementation) both for inbound and outbound security. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-jersey&lt;/artifactId&gt; &lt;/dependency&gt; Inbound security <markup lang=\"java\" title=\"Integrate with Jersey\" >ResourceConfig resourceConfig = new ResourceConfig() // register JAX-RS resource .register(JaxRsResource.class) // integrate security .register(new io.helidon.security.jersey.SecurityFeature(security)); Protecting a resource The current approach does not have a configuration option. The security must be configured through annotations. Security currently supports @Authenticated and @Authorized. When a resource is annotated with one of these annotations (application class, resource class, or resource method), security will be triggered. <markup lang=\"java\" title=\"Securing a resource method\" >// this is sufficient for security to be triggered, see javadoc for further details @Authenticated @Path(\"/{name}\") @GET @Produces(MediaType.TEXT_PLAIN) // due to Jersey approach to path matching, we need two methods to match both the \"root\" and \"root\" + subpaths public String getHelloName(@PathParam(\"name\") String name) { return \"Hello \" + name + \", your current subject: \" + securityContext.getSubject(); } Access context <markup lang=\"java\" title=\"Support in a JAX-RS resource\" >// inject io.helidon.security.SecurityContext @Context private SecurityContext securityContext; Outbound security <markup lang=\"java\" title=\"Call remote target with outbound security\" >// I expect you have injected the ClientSecurityFeature as shown above Client client = ClientBuilder.newClient() // integrate security .register(new ClientSecurityFeature()); try { // call the resource, will propagate identity as configured in Security String response = client.target(\"http://www.google.com\") .request() // configure the security context for this request (as client and targets may be re-used) .property(ClientSecurityFeature.PROPERTY_CONTEXT, securityContext) .get(String.class); } finally { client.close(); } ",
            "title": "Cloud Security Container Integrations"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 有两个快速入门示例，一个用于Helidon SE，另一个用于Helidon MP（MicroProfile）。 使用Maven模版生成示例。生成的Maven项目中包含对Docker和Kubernetes的支持。 ",
            "title": "preambule"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 如果您还没有准备好环境配置等条件，请确保您已满足 系统前置条件 ",
            "title": "前置条件"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 使用Helidon Maven模版中的一个（或两个）生成项目源码。这两个示例都产生了支持相同REST API的REST服务，但它们以不同方式实现： Helidon SE示例直接使用Helidon WebServer组件实现REST服务。它展示了配置WebServer和实现基本路由规则的基础知识。 Helidon MP示例使用Helidon MicroProfile服务器提供的JAX-RS支持实现REST服务。 <markup lang=\"bash\" title=\"Helidon SE 样例\" >mvn archetype:generate -DinteractiveMode=false \\ -DarchetypeGroupId=io.helidon.archetypes \\ -DarchetypeArtifactId=helidon-quickstart-se \\ -DarchetypeVersion=0.10.1-SNAPSHOT \\ -DgroupId=io.helidon.examples \\ -DartifactId=quickstart-se \\ -Dpackage=io.helidon.examples.quickstart.se <markup lang=\"bash\" title=\"Helidon MP 样例\" >mvn archetype:generate -DinteractiveMode=false \\ -DarchetypeGroupId=io.helidon.archetypes \\ -DarchetypeArtifactId=helidon-quickstart-mp \\ -DarchetypeVersion=0.10.1-SNAPSHOT \\ -DgroupId=io.helidon.examples \\ -DartifactId=quickstart-mp \\ -Dpackage=io.helidon.examples.quickstart.mp 模版在当前目录中生成Maven项目（比如，quickstart-mp）。切换到此目录： <markup lang=\"bash\" >cd quickstart-* 如果要将生成的项目用作自己应用程序的启动器，那么你可以用适合你的应用程序的值替换groupId，artifactId和package。 ",
            "title": "生成工程"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 比如： <markup lang=\"bash\" >mvn package ",
            "title": "构建此应用程序"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 该项目为该示例构建了一个应用程序jar，并将所有运行时依赖项保存在`target/libs`目录中。 这意味着您可以通过运行应用程序生成的jar文件轻松启动应用程序： <markup lang=\"bash\" title=\"Helidon SE 样例\" >java -jar target/quickstart-se.jar <markup lang=\"bash\" title=\"Helidon MP 样例\" >java -jar target/quickstart-mp.jar ",
            "title": "运行此应用程序"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 这两个示例都支持相同的REST接口，因此您以相同的方式尝试这两个示例。 该示例是一个非常简单的“Hello World”问候语服务。它支持生成问候消息的GET请求，以及更改问候语本身的PUT请求。 请求响应使用JSON格式进行编码。例如： <markup >curl -X GET http://localhost:8080/greet {\"message\":\"Hello World!\"} curl -X GET http://localhost:8080/greet/Joe {\"message\":\"Hello Joe!\"} curl -X PUT http://localhost:8080/greet/greeting/Hola {\"greeting\":\"Hola\"} curl -X GET http://localhost:8080/greet/Jose {\"message\":\"Hola Jose!\"} ",
            "title": "试试运行的应用程序"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 该项目还包含一个Dockerfile，因此您可以轻松地构建和运行docker镜像。 因为示例的运行时依赖性已经在`target/libs`中，所以Dockerfile非常简单（参考`target/Dockerfile`）。 要构建Docker镜像，您需要在系统上安装并确保Docker处于运行状态。 <markup lang=\"bash\" title=\"Helidon SE 样例\" >docker build -t quickstart-se target <markup lang=\"bash\" title=\"Helidon MP 样例\" >docker build -t quickstart-mp target ",
            "title": "构建Docker镜像"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": "<markup lang=\"bash\" title=\"Helidon SE 样例\" >docker run --rm -p 8080:8080 quickstart-se:latest <markup lang=\"bash\" title=\"Helidon MP 样例\" >docker run --rm -p 8080:8080 quickstart-mp:latest 然后您可以像以前一样尝试应用程序。 ",
            "title": "运行Docker镜像"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 如果您无权访问Kubernetes群集，则可以 在本地电脑桌面上安装一个群集 。 然后发布这个样例程序： <markup lang=\"bash\" title=\"验证与群集的连接\" >kubectl cluster-info kubectl get nodes <markup lang=\"bash\" title=\"将应用程序部署到Kubernetes\" >kubectl create -f target/app.yaml kubectl get pods # 等待启动pod运行 ",
            "title": "将此应用程序发布至Kubernetes"
        },
        {
            "location": "/getting-started/02_base-example",
            "text": " 启动Kubernetes代理服务器，以便您可以通过localhost连接到您的服务： <markup lang=\"bash\" title=\"启动kubctl代理\" >kubectl proxy 接下来获取服务的信息。 <markup lang=\"bash\" title=\"Helidon SE 样例\" >kubectl get service quickstart-se <markup lang=\"bash\" title=\"Helidon MP 样例\" >kubectl get service quickstart-mp 注意端口号。您现在可以像以前一样使用应用程序，但这里是使用第二个端口号（NodePort）而不是8080.例如： <markup >curl -X GET http://localhost:31431/greet 当你完成练习后，记得清理。 <markup lang=\"bash\" title=\"从Kubernetes中删除该应用程序\" >kubectl delete -f target/app.yaml ",
            "title": "在Kubernetes上运用应用程序"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " Configure the WebServer using the Helidon configuration framework, either programmatically or via a configuration file. ",
            "title": "preambule"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " The easiest way to configure the WebServer is in your application code. <markup lang=\"java\" >ServerConfiguration configuration = ServerConfiguration.builder() .bindAddress(InetAddress.getLocalHost()) .port(8080) .build(); WebServer webServer = WebServer.create(configuration, routing); ",
            "title": "Configuring the WebServer in your code"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " You can also define the configuration in a file. <markup lang=\"hocon\" title=\"WebServer configuration file application.conf \" >webserver { port: 8080, bind-address: \"0.0.0.0\", } Then, in your application code, load the configuration from that file. <markup lang=\"java\" title=\"WebServer initialization using the application.conf file located on the classpath\" >ServerConfiguration configuration = ServerConfiguration.fromConfig( Config.builder() .source(ClasspathConfigSource.from(\"application.conf\")) .build()); WebServer webServer = WebServer.create(configuration, routing); ",
            "title": "Configuring the WebServer in a configuration file"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " See all configuration options <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/webserver/ServerConfiguration.html\">here . ",
            "title": "Configuration options"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Routing lets you use request matching criteria to bind requests to a handler that implements your custom business logic. Matching criteria include one or more HTTP Method(s) and, optionally, a request path matcher . Use the RequestPredicate class to specify more routing criteria. ",
            "title": "preambule"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Routing also supports Error Routing which binds Java Throwable to the handling logic. Configure HTTP request routing using Routing.Builder . <markup lang=\"java\" title=\"Using Routing.Builder to specify how HTTP requests are handled\" >Routing routing = Routing.builder() .get(\"/hello\", (req, res) -&gt; res.send(\"Hello World!\")) .build(); WebServer webServer = WebServer.create(configuration, routing); Handle all GETs to /hello path. Send the Hello World! string. Add the routing to the WebServer. ",
            "title": "Basics"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Routing.Builder lets you specify how to handle each HTTP method. For example: HTTP Method Routing.Builder example GET .get((req, res) -&gt; { /* handler */ }) PUT .put((req, res) -&gt; { /* handler */ }) POST .post((req, res) -&gt; { /* handler */ }) HEAD .head((req, res) -&gt; { /* handler */ }) DELETE .delete((req, res) -&gt; { /* handler */ }) TRACE .trace((req, res) -&gt; { /* handler */ }) OPTIONS .options((req, res) -&gt; { /* handler */ }) any method .any((req, res) -&gt; { /* handler */ }) multiple methods .anyOf(List.of(Http.Method.GET, Http.Method.POST), (req, res) -&gt; { /* handler */ }) ",
            "title": "HTTP Method Routing"
        },
        {
            "location": "/webserver/03_routing",
            "text": " You can combine HTTP method routing with request path matching. <markup lang=\"java\" >Routing.builder() .post(\"/some/path\", (req, res) -&gt; { /* handler */ }) You can use path pattern instead of path with the following syntax: /foo/bar/baz - Exact path match against resolved path even with non-usual characters /foo/{}/baz - {} Unnamed regular expression segment ([^/]+) /foo/{var}/baz - Named regular expression segment ([^/]+) /foo/{var:\\d+} - Named regular expression segment with a specified expression /foo/{:\\d+} - Unnamed regular expression segment with a specified expression /foo/{+var} - Convenience shortcut for {var:.+}. A matcher is not a true URI template (as defined by RFC) but this convenience is in sync with the Apiary templates /foo/{+} - Convenience shortcut for unnamed segment with regular expression {:.+} /foo[/bar] - An optional block, which translates to the /foo(/bar)? regular expression Path (matcher) routing is exact . For example, a /foo/bar request is not routed to .post('/foo', &#8230;&#8203;) . Always start path and path patterns with the / character. ",
            "title": "Path Matcher Routing"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Use the RequestPredicate utility class to identify more criteria. You can construct (build) a predicate based on typical request criteria such as content type, or the existence of a header or cookie. You can also construct a handler that only processes requests accepted by the predicate. All other requests are nexted , meaning that they are routed to the next valid handler. <markup lang=\"java\" >.post(\"/foo\", RequestPredicate.whenRequest() .containsHeader(\"my-gr8-header\") .accepts(MediaType.TEXT_PLAIN) .and(this::isUserAuthenticated) .thenApply((req, resp) -&gt; { // Some logic }) .otherwise((req, resp) -&gt; { /* Otherwise logic */ }); // Optional. Default logic is req.next() ",
            "title": "Request Predicate"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " An in-memory config tree, once loaded, is immutable, even though the data in the underlying config sources can change over time. Your application can find out metadata about a loaded in-memory config and can track changes in config sources. ",
            "title": "preambule"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Even though in-memory config trees are immutable, the config system internally records which config sources it used to load each config tree and some metadata about the configuration. Your application can be aware of updates to the underlying config sources by: using the metadata the config system maintains, responding to changes when the config sources are updated, or using Supplier s of particular config values to obtain the always-current value for a key. ",
            "title": "Overview"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " The config system records when it loads each configuration into memory. Your application can retrieve it by invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#timestamp--\">timestamp method : <markup lang=\"java\" >java.time.Instance loadTime = myConfig.timestamp(); on any config node. ",
            "title": "Loading Time"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " The config system maintains a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Context.html\"> Config.Context for each Config node. Your application can retrieve the context by invoking the Config.context() method and then use it for these operations: Uses of Config.Context Method Usage Instant timestamp() Returns the load time of the last loaded configuration that used the context. Config last() Returns the most recently loaded configuration that used the context. Config reload() Reloads the entire config tree from the current contents of the same config sources used to load the tree in which the current node resides. Note that the config context describes or replaces a currently-loaded config tree. It by itself does not help your application decide when reloading the config might be useful. ",
            "title": "Config Context"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Loading Time The config system records when it loads each configuration into memory. Your application can retrieve it by invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#timestamp--\">timestamp method : <markup lang=\"java\" >java.time.Instance loadTime = myConfig.timestamp(); on any config node. Config Context The config system maintains a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Context.html\"> Config.Context for each Config node. Your application can retrieve the context by invoking the Config.context() method and then use it for these operations: Uses of Config.Context Method Usage Instant timestamp() Returns the load time of the last loaded configuration that used the context. Config last() Returns the most recently loaded configuration that used the context. Config reload() Reloads the entire config tree from the current contents of the same config sources used to load the tree in which the current node resides. Note that the config context describes or replaces a currently-loaded config tree. It by itself does not help your application decide when reloading the config might be useful. ",
            "title": "Using Config Metadata"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " When the application creates a config source, it can set up change detection for that source. This is called polling in the Helidon API but specific change detection algorithms might not use actual polling. You choose a specific <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy for each config source you want to monitor. See the section on polling strategies in the config extensions doc page for more information. The config system provides some built-in polling strategies, exposed as these methods on the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html\"> PollingStrategies class: regular(Duration interval) - a general-purpose scheduled polling strategy with a specified, constant polling interval. watch(Path watchedPath) - a filesystem-specific strategy to watch specified path. You can use this strategy with the file and classpath built-in config sources. nop() - a no-op strategy This example builds a Config object from three sources, each set up with a different polling strategy: <markup lang=\"java\" title=\"Build a Config with a different PollingStrategy for each config source\" >Config config = Config.from( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies.regular(Duration.ofSeconds(2))) .optional(), ConfigSources.file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch) .optional(), ConfigSources.classpath(\"application.properties\") .pollingStrategy(PollingStrategies::nop)); Optional file source conf/dev.properties will be checked for changes every 2 seconds. Optional file source conf/config.properties will be watched by the Java WatchService for changes on filesystem. The classpath resource application.properties will not be checked for changes. PollingStrategies.nop() polling strategy is default. The polling strategies internally inform the config system when they detect changes in the monitored config sources (except that the nop strategy does nothing). ",
            "title": "Setting up Config Source Change Detection"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " A simple approach is for your application to register a function that should run when any change occurs. <markup lang=\"java\" title=\"Subscribe on greeting property changes via onChange method\" >config.get(\"greeting\") .onChange((changedNode) -&gt; { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); return true; }); Navigate to the Config node on which you want to register. Invoke the onChange method, passing a function ( Function&lt;Config, Boolean&gt; ). The config system invokes that function each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting . The function should return true to continue being run on subsequent changes, false to stop. ",
            "title": "Registering Actions"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " The config system also supports the flow publisher/subscriber model for applications that need more control over the pace at which the config system delivers config change events. Each Config instance exposes the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#changes--\"> Config.changes() method which returns a Flow.Publisher&lt;Config&gt; . Your application can invoke this method, then invoke subscribe on the returned Flow.Publisher , passing your own Flow.Subscriber implementation. The config system will invoke your subscriber&#8217;s methods as appropriate, most notably calling onNext whenever it detects a change in one of the underlying config sources for the config node of interest. Mote that your subscriber will be notified when a change occurs anywhere in the subtree represented by the Config node. <markup lang=\"java\" title=\"Subscribe on greeting property changes\" >config.get(\"greeting\") .changes() .subscribe(new Flow.Subscriber&lt;&gt;() { Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { this.subscription = subscription; subscription.request(1); } @Override public void onNext(Config changedNode) { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); subscription.request(1); } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } }); Navigate to the Config node on which you want to register. Invoke changes to get the Flow.Publisher of changes to the subtree rooted at the Config node. Subscribe to the publisher passing a custom Flow.Subscriber&lt;Config&gt; implementation. Request the first event delivery in onSubscribe method. The config system invokes onNext each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting , regardless of where in the subtree the change actually occurred. Remember to request the next event delivery in onNext . The config system does not currently invoke onError . The config system invokes onComplete if all config sources indicate there will be no other change event . Note Your application does not need to subscribe to the new Config instance passed to your onNext method. The original subscription remains in force for changes to the \"new\" instance. ",
            "title": "Subscribing to Events"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " To know when config sources have changed, your application must register its interest on the Config node of interest. The config system will then notify your application of any change within the subtree rooted at that node. In particular, if you register on the root node, then the config system notifies your code of changes anywhere in the config tree. You can register in either of two ways: register an action to be run upon each change, or subscribe to a Flow.Publisher that notifies of changes. Registering Actions A simple approach is for your application to register a function that should run when any change occurs. <markup lang=\"java\" title=\"Subscribe on greeting property changes via onChange method\" >config.get(\"greeting\") .onChange((changedNode) -&gt; { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); return true; }); Navigate to the Config node on which you want to register. Invoke the onChange method, passing a function ( Function&lt;Config, Boolean&gt; ). The config system invokes that function each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting . The function should return true to continue being run on subsequent changes, false to stop. Subscribing to Events The config system also supports the flow publisher/subscriber model for applications that need more control over the pace at which the config system delivers config change events. Each Config instance exposes the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#changes--\"> Config.changes() method which returns a Flow.Publisher&lt;Config&gt; . Your application can invoke this method, then invoke subscribe on the returned Flow.Publisher , passing your own Flow.Subscriber implementation. The config system will invoke your subscriber&#8217;s methods as appropriate, most notably calling onNext whenever it detects a change in one of the underlying config sources for the config node of interest. Mote that your subscriber will be notified when a change occurs anywhere in the subtree represented by the Config node. <markup lang=\"java\" title=\"Subscribe on greeting property changes\" >config.get(\"greeting\") .changes() .subscribe(new Flow.Subscriber&lt;&gt;() { Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { this.subscription = subscription; subscription.request(1); } @Override public void onNext(Config changedNode) { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); subscription.request(1); } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } }); Navigate to the Config node on which you want to register. Invoke changes to get the Flow.Publisher of changes to the subtree rooted at the Config node. Subscribe to the publisher passing a custom Flow.Subscriber&lt;Config&gt; implementation. Request the first event delivery in onSubscribe method. The config system invokes onNext each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting , regardless of where in the subtree the change actually occurred. Remember to request the next event delivery in onNext . The config system does not currently invoke onError . The config system invokes onComplete if all config sources indicate there will be no other change event . Note Your application does not need to subscribe to the new Config instance passed to your onNext method. The original subscription remains in force for changes to the \"new\" instance. ",
            "title": "Registering a Config Change Response"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Evolving API This section describes the Config.changes() method. It is marked as deprecated because it returns an io.helidon.reactive.Flow.Publisher object. In a future Helidon release that requires Java 9 or later this method will be undeprecated and changed&#8201;&#8212;&#8201;or a similar method will be added&#8201;&#8212;&#8201;so that the return type is java.util.concurrent.Flow.Publisher instead. Any code you write using the existing Config.changes() method might need to change at that time. Although in-memory config trees do not change once loaded, applications can respond to changes in the underlying config sources by: setting up change detection for the config sources used to build a configuration, and registering a response to be run when a source changes. Your code&#8217;s response can react to the changes in whatever way makes sense for your application. The following sections describe these steps in detail. Setting up Config Source Change Detection When the application creates a config source, it can set up change detection for that source. This is called polling in the Helidon API but specific change detection algorithms might not use actual polling. You choose a specific <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy for each config source you want to monitor. See the section on polling strategies in the config extensions doc page for more information. The config system provides some built-in polling strategies, exposed as these methods on the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html\"> PollingStrategies class: regular(Duration interval) - a general-purpose scheduled polling strategy with a specified, constant polling interval. watch(Path watchedPath) - a filesystem-specific strategy to watch specified path. You can use this strategy with the file and classpath built-in config sources. nop() - a no-op strategy This example builds a Config object from three sources, each set up with a different polling strategy: <markup lang=\"java\" title=\"Build a Config with a different PollingStrategy for each config source\" >Config config = Config.from( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies.regular(Duration.ofSeconds(2))) .optional(), ConfigSources.file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch) .optional(), ConfigSources.classpath(\"application.properties\") .pollingStrategy(PollingStrategies::nop)); Optional file source conf/dev.properties will be checked for changes every 2 seconds. Optional file source conf/config.properties will be watched by the Java WatchService for changes on filesystem. The classpath resource application.properties will not be checked for changes. PollingStrategies.nop() polling strategy is default. The polling strategies internally inform the config system when they detect changes in the monitored config sources (except that the nop strategy does nothing). Registering a Config Change Response To know when config sources have changed, your application must register its interest on the Config node of interest. The config system will then notify your application of any change within the subtree rooted at that node. In particular, if you register on the root node, then the config system notifies your code of changes anywhere in the config tree. You can register in either of two ways: register an action to be run upon each change, or subscribe to a Flow.Publisher that notifies of changes. Registering Actions A simple approach is for your application to register a function that should run when any change occurs. <markup lang=\"java\" title=\"Subscribe on greeting property changes via onChange method\" >config.get(\"greeting\") .onChange((changedNode) -&gt; { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); return true; }); Navigate to the Config node on which you want to register. Invoke the onChange method, passing a function ( Function&lt;Config, Boolean&gt; ). The config system invokes that function each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting . The function should return true to continue being run on subsequent changes, false to stop. Subscribing to Events The config system also supports the flow publisher/subscriber model for applications that need more control over the pace at which the config system delivers config change events. Each Config instance exposes the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#changes--\"> Config.changes() method which returns a Flow.Publisher&lt;Config&gt; . Your application can invoke this method, then invoke subscribe on the returned Flow.Publisher , passing your own Flow.Subscriber implementation. The config system will invoke your subscriber&#8217;s methods as appropriate, most notably calling onNext whenever it detects a change in one of the underlying config sources for the config node of interest. Mote that your subscriber will be notified when a change occurs anywhere in the subtree represented by the Config node. <markup lang=\"java\" title=\"Subscribe on greeting property changes\" >config.get(\"greeting\") .changes() .subscribe(new Flow.Subscriber&lt;&gt;() { Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { this.subscription = subscription; subscription.request(1); } @Override public void onNext(Config changedNode) { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); subscription.request(1); } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } }); Navigate to the Config node on which you want to register. Invoke changes to get the Flow.Publisher of changes to the subtree rooted at the Config node. Subscribe to the publisher passing a custom Flow.Subscriber&lt;Config&gt; implementation. Request the first event delivery in onSubscribe method. The config system invokes onNext each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting , regardless of where in the subtree the change actually occurred. Remember to request the next event delivery in onNext . The config system does not currently invoke onError . The config system invokes onComplete if all config sources indicate there will be no other change event . Note Your application does not need to subscribe to the new Config instance passed to your onNext method. The original subscription remains in force for changes to the \"new\" instance. ",
            "title": "Responding to Changes in Config Sources"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Some applications do not need to respond to changes as they happen. Instead it&#8217;s sufficient that they simply have access to the current value for a particular key in the configuration. Each asXXX method on the Config class has a companion asXXXSupplier method. These supplier methods return Supplier&lt;XXX&gt; , and when your application invokes the supplier&#8217;s get method the config system returns the then-current value as stored in the config source. <markup lang=\"java\" title=\"Access greeting property as Supplier&lt;String&gt; \" >// Construct a Config with the appropriate PollingStrategy on each config source. Supplier&lt;String&gt; greetingSupplier = config.get(\"greeting\") .asStringSupplier(); System.out.println(\"Always actual greeting value: \" + greetingSupplier.get()); Navigate to the Config node for which you want access to the always-current value. Retrieve and store the returned supplier for later use. Invoke the supplier&#8217;s get() method to retrieve the current value of the node. Important Supplier support requires that you build the Config object from sources that have proper polling strategies set up. ",
            "title": "Accessing Always-current Values"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " This section discusses several advanced topics related to Helidon configuration. ",
            "title": "preambule"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The config system supports using a file system directory as a config source. Each non-directory file in the directory becomes a config entry: the file name is the key and the contents of that file are used as the corresponding config String value. The following example shows, for example, one way to load Kubernetes secrets mounted on the pod&#8217;s filesystem. If the directory conf/secrets contains these two files <markup title=\"File secrets/username \" >jose <markup title=\"File secrets/password \" >^ery$ecretP&amp;ssword your application can load this as configuration as follows: <markup lang=\"java\" title=\"Using directory config source\" >Config secrets = Config.withSources( ConfigSources.directory(\"conf/secrets\")) .disableEnvironmentVariablesSource() .disableSystemPropertiesSource() .build(); assert secrets.get(\"username\").asString() .equals(\"jose\"); assert secrets.get(\"password\").asString() .equals(\"^ery$ecretP&amp;ssword\"); Loads all files from the conf/secrets directory. No need to use environment variables or system properties as sources in building the Config . The loaded config maps the key username to the value jose &#8230;&#8203; &#8230;&#8203;and the key password to ^ery$ecretP&amp;ssword . Remember that your application can process the contents of a given file as configuration. See the config sources section and the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#file-java.lang.String-\"> ConfigSources.file JavaDoc. ",
            "title": "Directory Config Source"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config anotherConfig = Config.from(classpath(\"application.conf\")); Config config = Config.from( ConfigSources.from(anotherConfig.get(\"data\"))); ",
            "title": "Subtree of Another Config "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.from( ConfigSources.from(System.getProperties()).build()); ",
            "title": " Properties Object"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.from( ConfigSources.from(\"app.greeting = Hi\", \"text/x-java-properties\")); ",
            "title": " String of a Given Media Type"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.from( ConfigSources.from(Map.of(\"app.page-size\", \"20\")) .lax() .build()); ",
            "title": " Map "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.from( ConfigSources.from(ObjectNode.builder() .addList(\"app.basic-range\", ListNode.builder() .addValue(\"-20\") .addValue(\"20\") .build()) .build())); ConfigSources.from variants for Properties or Map arguments return a ConfigSources.MapBuilder instance. A similar from variant accepts a Readable instead of a String . MapBuilder by default throws an exception if a key appears more than once in the map. The lax() method relaxes this; the config system logs a warning instead. ",
            "title": " ad hoc Config Nodes"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The config system provides several ways to create a Config tree from data already in memory. See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html\"> ConfigSources javadoc for further details. The numerous variants of the from method construct ConfigSource or Builder&lt;ConfigSource&gt; instances. Subtree of Another Config <markup lang=\"java\" >Config anotherConfig = Config.from(classpath(\"application.conf\")); Config config = Config.from( ConfigSources.from(anotherConfig.get(\"data\"))); Properties Object <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(System.getProperties()).build()); String of a Given Media Type <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(\"app.greeting = Hi\", \"text/x-java-properties\")); Map <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(Map.of(\"app.page-size\", \"20\")) .lax() .build()); ad hoc Config Nodes <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(ObjectNode.builder() .addList(\"app.basic-range\", ListNode.builder() .addValue(\"-20\") .addValue(\"20\") .build()) .build())); ConfigSources.from variants for Properties or Map arguments return a ConfigSources.MapBuilder instance. A similar from variant accepts a Readable instead of a String . MapBuilder by default throws an exception if a key appears more than once in the map. The lax() method relaxes this; the config system logs a warning instead. ",
            "title": "In-memory Config Sources"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#prefixed-java.lang.String-java.util.function.Supplier-\"> ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.from( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\").asString() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\").asString() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. ",
            "title": "Prefixed Config Sources"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The ConfigSources.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.from(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeConfigSource . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.MergingStrategy.html\"> ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.from( ConfigSources.from(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.from(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. ",
            "title": "Merging Strategies"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Prefixed Config Sources Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#prefixed-java.lang.String-java.util.function.Supplier-\"> ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.from( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\").asString() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\").asString() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. Merging Strategies The ConfigSources.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.from(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeConfigSource . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.MergingStrategy.html\"> ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.from( ConfigSources.from(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.from(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. ",
            "title": "Handling Key Collisions"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Although the examples above use a single source, you can build a single Config from multiple sources. Handling Key Collisions Prefixed Config Sources Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#prefixed-java.lang.String-java.util.function.Supplier-\"> ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.from( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\").asString() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\").asString() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. Merging Strategies The ConfigSources.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.from(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeConfigSource . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.MergingStrategy.html\"> ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.from( ConfigSources.from(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.from(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. ",
            "title": "Multi-Source Config s and Composite Config Sources"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java java.nio.file.Files.probeContentType(Path) API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) ",
            "title": "By Inference"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.from(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. ",
            "title": "By Application Directive"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " By Inference Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java java.nio.file.Files.probeContentType(Path) API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) By Application Directive Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.from(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. ",
            "title": "Identifying the Media Type"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. ",
            "title": "By Inference from media-type "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.from(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. ",
            "title": "By Application Directive"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " By Inference from media-type Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. By Application Directive Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.from(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. ",
            "title": "Locating a Parser"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " As the <a id=\"\" title=\"\" target=\"_blank\" href=\"config/02_config-sources.html\">config sources and parsers section describes, these two work together to read and translate configuration data from some external form into the corresponding in-memory config tree. Although most applications are explicit about the config sources they use in building a Config , the config system often has to figure out what parser to use. It does so by: determining, the best that it can, the media type of the source, and locating a parser that can translate that media type. Identifying the Media Type By Inference Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java java.nio.file.Files.probeContentType(Path) API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) By Application Directive Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.from(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. Locating a Parser By Inference from media-type Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. By Application Directive Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.from(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. ",
            "title": "How Config Chooses Parsers"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" title=\"Specify JSON as media type for node\" >Config config = Config.from( classpath(\"application.yaml\") .mediaTypeMapping( key -&gt; \"app\".equals(key.toString()) ? \"application/json\" : null)); assert config.get(\"secrets.username\").asString() .equals(\"jose\"); assert config.get(\"secrets.password\").asString() .equals(\"^ery$ecretP&amp;ssword\"); assert config.get(\"app\").type() == Type.OBJECT; assert config.get(\"app.greeting\") .asString().equals(\"Hello\"); assert config.get(\"app.page-size\") .asInt() == 20; assert config.get(\"app.basic-range.0\") .asInt() == -20; assert config.get(\"app.basic-range.1\") .asInt() == 20; The source builder&#8217;s mediaTypeMapping method accepts a function which returns the appropriate media types (if any) for config keys. The function says to treat the app property value as a JSON document and leave other nodes unchanged. Other properties are loaded as expected. Property app is now an structured object node. Because the function passed to mediaTypeMapping identifies the app node as a JSON document, the config system selects the config parser that is registered with the builder which also handles the JSON media type. Also, note that the config system replaces the original String value node with an object node resulting from parsing that String value as JSON. ",
            "title": "Specify Key-to-media-type Mapping"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Alternatively, your application could map config keys to the specific parsers you want to use for parsing those keys' values. <markup lang=\"java\" title=\"Specify JSON formatted property' parser instance\" >Config config = Config.from( ConfigSources.classpath(\"application.yaml\") .parserMapping( key -&gt; \"app\".equals(key.toString()) ? HoconConfigParserBuilder.buildDefault() : null)); Uses the parserMapping method to map keys to parser instances. Tells the config system to use the HOCON parser for translating the String value of the app key. (HCON is a superset of JSON.) As before, the config system replaces the value node in the containing config tree with the config tree resulting from the additional parse. ",
            "title": "Specify Key-to-parser Mapping"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " A config value node might contain an entire config document in String form, but in a format different from the containing document. Your application can tell the config system to parse such a node as config in a different format and replace the String value node in the original tree with the config tree that results from parsing that String . In this example, a YAML document contains a JSON document as a leaf. <markup lang=\"yaml\" title=\"YAML file with included JSON formated property\" >secrets: username: \"jose\" password: \"^ery$ecretP&amp;ssword\" app: &gt; { \"greeting\": \"Hello\", \"page-size\": 20, \"basic-range\": [ -20, 20 ] } The property app is itself formatted as a JSON document. Specify Key-to-media-type Mapping <markup lang=\"java\" title=\"Specify JSON as media type for node\" >Config config = Config.from( classpath(\"application.yaml\") .mediaTypeMapping( key -&gt; \"app\".equals(key.toString()) ? \"application/json\" : null)); assert config.get(\"secrets.username\").asString() .equals(\"jose\"); assert config.get(\"secrets.password\").asString() .equals(\"^ery$ecretP&amp;ssword\"); assert config.get(\"app\").type() == Type.OBJECT; assert config.get(\"app.greeting\") .asString().equals(\"Hello\"); assert config.get(\"app.page-size\") .asInt() == 20; assert config.get(\"app.basic-range.0\") .asInt() == -20; assert config.get(\"app.basic-range.1\") .asInt() == 20; The source builder&#8217;s mediaTypeMapping method accepts a function which returns the appropriate media types (if any) for config keys. The function says to treat the app property value as a JSON document and leave other nodes unchanged. Other properties are loaded as expected. Property app is now an structured object node. Because the function passed to mediaTypeMapping identifies the app node as a JSON document, the config system selects the config parser that is registered with the builder which also handles the JSON media type. Also, note that the config system replaces the original String value node with an object node resulting from parsing that String value as JSON. Specify Key-to-parser Mapping Alternatively, your application could map config keys to the specific parsers you want to use for parsing those keys' values. <markup lang=\"java\" title=\"Specify JSON formatted property' parser instance\" >Config config = Config.from( ConfigSources.classpath(\"application.yaml\") .parserMapping( key -&gt; \"app\".equals(key.toString()) ? HoconConfigParserBuilder.buildDefault() : null)); Uses the parserMapping method to map keys to parser instances. Tells the config system to use the HOCON parser for translating the String value of the app key. (HCON is a superset of JSON.) As before, the config system replaces the value node in the containing config tree with the config tree resulting from the additional parse. ",
            "title": "Parsing a Config Value as Config"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your application loads the configuration specified by a meta-config file by: invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#load-io.helidon.config.Config-\"> ConfigSources.load(Config) method, passing a config object read from the meta-config source as the argument; invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#loadSources-java.util.function.Supplier&#8230;&#8203;\"> Config.loadSources method, or invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#loadSourcesFrom-java.util.function.Supplier&#8230;&#8203;\"> Config.loadSourcesFrom method. These methods return either a Config tree or a Config.Builder which your application can further fine-tune before using to construct a Config tree. The config system interprets the meta-config as directions for how to build a config tree, rather than as the config data itself. ",
            "title": "Loading Config by Specifying a Meta-configuration File"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The introduction section shows how to use Config.create() to load config from one of several possible default config files. That same method also searches for one of severl possible default meta-config files from which to load config sources to be used for the default config. The Config.create() method determines the default configuration from the following search: Attempt to load meta-config from at most one of the following, checked in this order: meta-config.yaml - meta configuration file in YAML format meta-config.conf - meta configuration file in HOCON format meta-config.json - meta configuration file in JSON format meta-config.properties - meta configuration file in Java Properties format Otherwise, load config from: environment variables, and Java system properties, and at most one of the following, checking in this order: application.yaml - configuration file in YAML format application.conf - configuration file in HOCON format application.json - configuration file in JSON format application.properties - configuration file in Java Properties format Remember that the config system will check for these default meta-config and config files only if the classpath includes the corresponding parsers. The introduction section on built-in formats section describes this further. ",
            "title": "Loading Config from an Implicit Meta-configuration File"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/internal/FileConfigSource.FileBuilder.html\"> FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. ",
            "title": "Built-in Types"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Each meta-configuration file must contain the top-level sources property that is an array (ordered list) of config sources. The meta-config file can contain other top-level keys as well but the config system ignores them when it interprets the contents as meta-configuration. Each sources property must contain exactly one of following top level properties: Meta-configuration Required Top-level Property Property Name Usage type a predefined type (see below ), or a custom config source ID class a custom config source implementation, or a builder class with a build() method that returns ConfigSource If you specify both type and class , the config system ignores the class setting. In addition, each sources property can optionally have a properties property which assigns type-specific attributes for the config source being defined. Built-in Types The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/internal/FileConfigSource.FileBuilder.html\"> FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. ",
            "title": "Meta-configuration File Format"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } ",
            "title": "Custom Source Types using class "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. ",
            "title": "Custom Source Type using type "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " You can use meta-config to set up custom config source types as well as the built-in ones described above. Meta-config supports this in two ways: by class name by custom type name Custom Source Types using class Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } Custom Source Type using type You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. ",
            "title": "Meta-config for Custom Source Types"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Here is how your application can use meta-configuration in a particular resource on the classpath to load a Config tree: <markup lang=\"java\" title=\"Loading Config using Meta-configuration\" >ConfigSource sourceFromMetaConfig = ConfigSources.load( classpath(\"config-meta-all.conf\")).build(); Config config = Config.from(sourceFromMetaConfig); The ConfigSources.load method creates a config source for the eventual config from the config source argument which specifies the meta-config. This example uses meta-config from a resource on the classpath but you can use meta-config from any valid config source. The load method populates the sourceFromMetaConfig ConfigSource from all the actual sources declared in the meta-configuration. The returned ConfigSource is ready for use in creating a Config instance. ",
            "title": "Loading Config using Meta-configuration"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your meta-config can include the set-up for polling strategies and retry policies if the config source supports them. Declare them in a way similar to how you declare the config sources themselves: by type or class and with accompanying properties . Meta-config Support for Built-in Polling Strategies Strategy Type Usage Properties regular Periodic polling - See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html#regular-java.time.Duration-\"> PollingStrategies.regular method interval ( Duration ) - indicating how often to poll; e.g., PT15S represents 15 seconds watch Filesystem monitoring - See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html#watch-java.nio.file.Path-\"> PollingStrategies.watch method path - file system path to the classpath , file , or directory to monitor Meta-config Support for Built-in Retry Policies Policy Type Usage Properties repeat Regularly-scheduled - see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/configRetryPolicies.html#repeat-int-\"> RetryPolicies.repeat . Optional: delay ( Duration ) - initial delay between retries delay-factor ( double ) - delay is repeatedly multiplied by this each retry to compute the delay for each successive retry call-timeout ( Duration ) - timeout for a single invocation to load the source overall-timeout ( Duration ) - total timeout for all retry calls and delays To specify a custom polling strategy or custom retry policy, specify class (instead of type ) and give the fully-qualified class name for the implementation class. If your custom class needs parameters to control its behavior the config system uses io.helidon.config.ConfigMapper to initialize the class instance. See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/RetryPolicy.html\"> RetryPolicy and <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy JavaDoc sections. ",
            "title": "Meta-config for Polling Strategies and Retry Policies"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Instead of including code in your application to construct config trees from builders, sources, etc., you can instead prepare meta-configuration in a file that declares the sources to load and their attributes. You can either specify the meta-config file in your application or allow the config sytem to search for and load meta-config from a preset list of possible sources. Loading Config by Specifying a Meta-configuration File Your application loads the configuration specified by a meta-config file by: invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#load-io.helidon.config.Config-\"> ConfigSources.load(Config) method, passing a config object read from the meta-config source as the argument; invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#loadSources-java.util.function.Supplier&#8230;&#8203;\"> Config.loadSources method, or invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#loadSourcesFrom-java.util.function.Supplier&#8230;&#8203;\"> Config.loadSourcesFrom method. These methods return either a Config tree or a Config.Builder which your application can further fine-tune before using to construct a Config tree. The config system interprets the meta-config as directions for how to build a config tree, rather than as the config data itself. Loading Config from an Implicit Meta-configuration File The introduction section shows how to use Config.create() to load config from one of several possible default config files. That same method also searches for one of severl possible default meta-config files from which to load config sources to be used for the default config. The Config.create() method determines the default configuration from the following search: Attempt to load meta-config from at most one of the following, checked in this order: meta-config.yaml - meta configuration file in YAML format meta-config.conf - meta configuration file in HOCON format meta-config.json - meta configuration file in JSON format meta-config.properties - meta configuration file in Java Properties format Otherwise, load config from: environment variables, and Java system properties, and at most one of the following, checking in this order: application.yaml - configuration file in YAML format application.conf - configuration file in HOCON format application.json - configuration file in JSON format application.properties - configuration file in Java Properties format Remember that the config system will check for these default meta-config and config files only if the classpath includes the corresponding parsers. The introduction section on built-in formats section describes this further. Meta-configuration File Format Each meta-configuration file must contain the top-level sources property that is an array (ordered list) of config sources. The meta-config file can contain other top-level keys as well but the config system ignores them when it interprets the contents as meta-configuration. Each sources property must contain exactly one of following top level properties: Meta-configuration Required Top-level Property Property Name Usage type a predefined type (see below ), or a custom config source ID class a custom config source implementation, or a builder class with a build() method that returns ConfigSource If you specify both type and class , the config system ignores the class setting. In addition, each sources property can optionally have a properties property which assigns type-specific attributes for the config source being defined. Built-in Types The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/internal/FileConfigSource.FileBuilder.html\"> FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. Meta-config for Custom Source Types You can use meta-config to set up custom config source types as well as the built-in ones described above. Meta-config supports this in two ways: by class name by custom type name Custom Source Types using class Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } Custom Source Type using type You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. Loading Config using Meta-configuration Here is how your application can use meta-configuration in a particular resource on the classpath to load a Config tree: <markup lang=\"java\" title=\"Loading Config using Meta-configuration\" >ConfigSource sourceFromMetaConfig = ConfigSources.load( classpath(\"config-meta-all.conf\")).build(); Config config = Config.from(sourceFromMetaConfig); The ConfigSources.load method creates a config source for the eventual config from the config source argument which specifies the meta-config. This example uses meta-config from a resource on the classpath but you can use meta-config from any valid config source. The load method populates the sourceFromMetaConfig ConfigSource from all the actual sources declared in the meta-configuration. The returned ConfigSource is ready for use in creating a Config instance. Meta-config for Polling Strategies and Retry Policies Your meta-config can include the set-up for polling strategies and retry policies if the config source supports them. Declare them in a way similar to how you declare the config sources themselves: by type or class and with accompanying properties . Meta-config Support for Built-in Polling Strategies Strategy Type Usage Properties regular Periodic polling - See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html#regular-java.time.Duration-\"> PollingStrategies.regular method interval ( Duration ) - indicating how often to poll; e.g., PT15S represents 15 seconds watch Filesystem monitoring - See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html#watch-java.nio.file.Path-\"> PollingStrategies.watch method path - file system path to the classpath , file , or directory to monitor Meta-config Support for Built-in Retry Policies Policy Type Usage Properties repeat Regularly-scheduled - see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/configRetryPolicies.html#repeat-int-\"> RetryPolicies.repeat . Optional: delay ( Duration ) - initial delay between retries delay-factor ( double ) - delay is repeatedly multiplied by this each retry to compute the delay for each successive retry call-timeout ( Duration ) - timeout for a single invocation to load the source overall-timeout ( Duration ) - total timeout for all retry calls and delays To specify a custom polling strategy or custom retry policy, specify class (instead of type ) and give the fully-qualified class name for the implementation class. If your custom class needs parameters to control its behavior the config system uses io.helidon.config.ConfigMapper to initialize the class instance. See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/RetryPolicy.html\"> RetryPolicy and <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy JavaDoc sections. ",
            "title": "Loading Config using Meta-configuration"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Directory Config Source The config system supports using a file system directory as a config source. Each non-directory file in the directory becomes a config entry: the file name is the key and the contents of that file are used as the corresponding config String value. The following example shows, for example, one way to load Kubernetes secrets mounted on the pod&#8217;s filesystem. If the directory conf/secrets contains these two files <markup title=\"File secrets/username \" >jose <markup title=\"File secrets/password \" >^ery$ecretP&amp;ssword your application can load this as configuration as follows: <markup lang=\"java\" title=\"Using directory config source\" >Config secrets = Config.withSources( ConfigSources.directory(\"conf/secrets\")) .disableEnvironmentVariablesSource() .disableSystemPropertiesSource() .build(); assert secrets.get(\"username\").asString() .equals(\"jose\"); assert secrets.get(\"password\").asString() .equals(\"^ery$ecretP&amp;ssword\"); Loads all files from the conf/secrets directory. No need to use environment variables or system properties as sources in building the Config . The loaded config maps the key username to the value jose &#8230;&#8203; &#8230;&#8203;and the key password to ^ery$ecretP&amp;ssword . Remember that your application can process the contents of a given file as configuration. See the config sources section and the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#file-java.lang.String-\"> ConfigSources.file JavaDoc. In-memory Config Sources The config system provides several ways to create a Config tree from data already in memory. See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html\"> ConfigSources javadoc for further details. The numerous variants of the from method construct ConfigSource or Builder&lt;ConfigSource&gt; instances. Subtree of Another Config <markup lang=\"java\" >Config anotherConfig = Config.from(classpath(\"application.conf\")); Config config = Config.from( ConfigSources.from(anotherConfig.get(\"data\"))); Properties Object <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(System.getProperties()).build()); String of a Given Media Type <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(\"app.greeting = Hi\", \"text/x-java-properties\")); Map <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(Map.of(\"app.page-size\", \"20\")) .lax() .build()); ad hoc Config Nodes <markup lang=\"java\" >Config config = Config.from( ConfigSources.from(ObjectNode.builder() .addList(\"app.basic-range\", ListNode.builder() .addValue(\"-20\") .addValue(\"20\") .build()) .build())); ConfigSources.from variants for Properties or Map arguments return a ConfigSources.MapBuilder instance. A similar from variant accepts a Readable instead of a String . MapBuilder by default throws an exception if a key appears more than once in the map. The lax() method relaxes this; the config system logs a warning instead. Multi-Source Config s and Composite Config Sources Although the examples above use a single source, you can build a single Config from multiple sources. Handling Key Collisions Prefixed Config Sources Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#prefixed-java.lang.String-java.util.function.Supplier-\"> ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.from( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\").asString() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\").asString() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. Merging Strategies The ConfigSources.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.from(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeConfigSource . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.MergingStrategy.html\"> ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.from( ConfigSources.from(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.from(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. How Config Chooses Parsers As the <a id=\"\" title=\"\" target=\"_blank\" href=\"config/02_config-sources.html\">config sources and parsers section describes, these two work together to read and translate configuration data from some external form into the corresponding in-memory config tree. Although most applications are explicit about the config sources they use in building a Config , the config system often has to figure out what parser to use. It does so by: determining, the best that it can, the media type of the source, and locating a parser that can translate that media type. Identifying the Media Type By Inference Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java java.nio.file.Files.probeContentType(Path) API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) By Application Directive Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.from(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. Locating a Parser By Inference from media-type Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. By Application Directive Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.from(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. Parsing a Config Value as Config A config value node might contain an entire config document in String form, but in a format different from the containing document. Your application can tell the config system to parse such a node as config in a different format and replace the String value node in the original tree with the config tree that results from parsing that String . In this example, a YAML document contains a JSON document as a leaf. <markup lang=\"yaml\" title=\"YAML file with included JSON formated property\" >secrets: username: \"jose\" password: \"^ery$ecretP&amp;ssword\" app: &gt; { \"greeting\": \"Hello\", \"page-size\": 20, \"basic-range\": [ -20, 20 ] } The property app is itself formatted as a JSON document. Specify Key-to-media-type Mapping <markup lang=\"java\" title=\"Specify JSON as media type for node\" >Config config = Config.from( classpath(\"application.yaml\") .mediaTypeMapping( key -&gt; \"app\".equals(key.toString()) ? \"application/json\" : null)); assert config.get(\"secrets.username\").asString() .equals(\"jose\"); assert config.get(\"secrets.password\").asString() .equals(\"^ery$ecretP&amp;ssword\"); assert config.get(\"app\").type() == Type.OBJECT; assert config.get(\"app.greeting\") .asString().equals(\"Hello\"); assert config.get(\"app.page-size\") .asInt() == 20; assert config.get(\"app.basic-range.0\") .asInt() == -20; assert config.get(\"app.basic-range.1\") .asInt() == 20; The source builder&#8217;s mediaTypeMapping method accepts a function which returns the appropriate media types (if any) for config keys. The function says to treat the app property value as a JSON document and leave other nodes unchanged. Other properties are loaded as expected. Property app is now an structured object node. Because the function passed to mediaTypeMapping identifies the app node as a JSON document, the config system selects the config parser that is registered with the builder which also handles the JSON media type. Also, note that the config system replaces the original String value node with an object node resulting from parsing that String value as JSON. Specify Key-to-parser Mapping Alternatively, your application could map config keys to the specific parsers you want to use for parsing those keys' values. <markup lang=\"java\" title=\"Specify JSON formatted property' parser instance\" >Config config = Config.from( ConfigSources.classpath(\"application.yaml\") .parserMapping( key -&gt; \"app\".equals(key.toString()) ? HoconConfigParserBuilder.buildDefault() : null)); Uses the parserMapping method to map keys to parser instances. Tells the config system to use the HOCON parser for translating the String value of the app key. (HCON is a superset of JSON.) As before, the config system replaces the value node in the containing config tree with the config tree resulting from the additional parse. Loading Config using Meta-configuration Instead of including code in your application to construct config trees from builders, sources, etc., you can instead prepare meta-configuration in a file that declares the sources to load and their attributes. You can either specify the meta-config file in your application or allow the config sytem to search for and load meta-config from a preset list of possible sources. Loading Config by Specifying a Meta-configuration File Your application loads the configuration specified by a meta-config file by: invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html#load-io.helidon.config.Config-\"> ConfigSources.load(Config) method, passing a config object read from the meta-config source as the argument; invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#loadSources-java.util.function.Supplier&#8230;&#8203;\"> Config.loadSources method, or invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#loadSourcesFrom-java.util.function.Supplier&#8230;&#8203;\"> Config.loadSourcesFrom method. These methods return either a Config tree or a Config.Builder which your application can further fine-tune before using to construct a Config tree. The config system interprets the meta-config as directions for how to build a config tree, rather than as the config data itself. Loading Config from an Implicit Meta-configuration File The introduction section shows how to use Config.create() to load config from one of several possible default config files. That same method also searches for one of severl possible default meta-config files from which to load config sources to be used for the default config. The Config.create() method determines the default configuration from the following search: Attempt to load meta-config from at most one of the following, checked in this order: meta-config.yaml - meta configuration file in YAML format meta-config.conf - meta configuration file in HOCON format meta-config.json - meta configuration file in JSON format meta-config.properties - meta configuration file in Java Properties format Otherwise, load config from: environment variables, and Java system properties, and at most one of the following, checking in this order: application.yaml - configuration file in YAML format application.conf - configuration file in HOCON format application.json - configuration file in JSON format application.properties - configuration file in Java Properties format Remember that the config system will check for these default meta-config and config files only if the classpath includes the corresponding parsers. The introduction section on built-in formats section describes this further. Meta-configuration File Format Each meta-configuration file must contain the top-level sources property that is an array (ordered list) of config sources. The meta-config file can contain other top-level keys as well but the config system ignores them when it interprets the contents as meta-configuration. Each sources property must contain exactly one of following top level properties: Meta-configuration Required Top-level Property Property Name Usage type a predefined type (see below ), or a custom config source ID class a custom config source implementation, or a builder class with a build() method that returns ConfigSource If you specify both type and class , the config system ignores the class setting. In addition, each sources property can optionally have a properties property which assigns type-specific attributes for the config source being defined. Built-in Types The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/internal/FileConfigSource.FileBuilder.html\"> FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. Meta-config for Custom Source Types You can use meta-config to set up custom config source types as well as the built-in ones described above. Meta-config supports this in two ways: by class name by custom type name Custom Source Types using class Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } Custom Source Type using type You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. Loading Config using Meta-configuration Here is how your application can use meta-configuration in a particular resource on the classpath to load a Config tree: <markup lang=\"java\" title=\"Loading Config using Meta-configuration\" >ConfigSource sourceFromMetaConfig = ConfigSources.load( classpath(\"config-meta-all.conf\")).build(); Config config = Config.from(sourceFromMetaConfig); The ConfigSources.load method creates a config source for the eventual config from the config source argument which specifies the meta-config. This example uses meta-config from a resource on the classpath but you can use meta-config from any valid config source. The load method populates the sourceFromMetaConfig ConfigSource from all the actual sources declared in the meta-configuration. The returned ConfigSource is ready for use in creating a Config instance. Meta-config for Polling Strategies and Retry Policies Your meta-config can include the set-up for polling strategies and retry policies if the config source supports them. Declare them in a way similar to how you declare the config sources themselves: by type or class and with accompanying properties . Meta-config Support for Built-in Polling Strategies Strategy Type Usage Properties regular Periodic polling - See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html#regular-java.time.Duration-\"> PollingStrategies.regular method interval ( Duration ) - indicating how often to poll; e.g., PT15S represents 15 seconds watch Filesystem monitoring - See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html#watch-java.nio.file.Path-\"> PollingStrategies.watch method path - file system path to the classpath , file , or directory to monitor Meta-config Support for Built-in Retry Policies Policy Type Usage Properties repeat Regularly-scheduled - see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/configRetryPolicies.html#repeat-int-\"> RetryPolicies.repeat . Optional: delay ( Duration ) - initial delay between retries delay-factor ( double ) - delay is repeatedly multiplied by this each retry to compute the delay for each successive retry call-timeout ( Duration ) - timeout for a single invocation to load the source overall-timeout ( Duration ) - total timeout for all retry calls and delays To specify a custom polling strategy or custom retry policy, specify class (instead of type ) and give the fully-qualified class name for the implementation class. If your custom class needs parameters to control its behavior the config system uses io.helidon.config.ConfigMapper to initialize the class instance. See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/RetryPolicy.html\"> RetryPolicy and <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy JavaDoc sections. ",
            "title": "Advanced Config Sources and Config Parsers"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " As described in the hierarchical features section each config node (except the root) has a non-null key. Here is the formal definition of what keys can be: <markup lang=\"abnf\" title=\"The ABNF syntax of config key\" >config-key = *1( key-token *( \".\" key-token ) ) key-token = *( unescaped / escaped ) unescaped = %x00-2D / %x2F-7D / %x7F-10FFFF ; %x2E ('.') and %x7E ('~') are excluded from 'unescaped' escaped = \"~\" ( \"0\" / \"1\" ) ; representing '~' and '.', respectively Important To emphasize, the dot character (&#8220;.&#8221;) has special meaning as a name separator in keys. To include a dot as a character in a key escape it as &#8220;~1&#8221;. To include a tilda escape it as &#8220;~0&#8221;. For example, the following configuration file contains two object nodes with names oracle and oracle.com . <markup lang=\"json\" title=\"Example application.json with dot character in key\" >{ \"oracle\" : { \"com\" : true, \"cz\" : false }, \"oracle.com\" : { \"secured\" : true } } <markup lang=\"java\" title=\"Working with configuration with dot character in node name\" >Config config = Config.from(classpath(\"application.json\")); // node `oracle` assert config.get(\"oracle.com\").asBoolean() == true; assert config.get(\"oracle\").get(\"com\").asBoolean() == true; assert config.get(\"oracle.com\").type() == Type.VALUE; assert config.get(\"oracle.com\").name().equals(\"com\"); // node `oracle.com` assert config.get(\"oracle~1com.secured\").asBoolean() == true; assert config.get(Key.escapeName(\"oracle.com\")) .get(\"secured\").asBoolean() == true; assert config.get(Key.escapeName(\"oracle.com\")).type() == Type.OBJECT; assert config.get(Key.escapeName(\"oracle.com\")).name().equals(\"oracle.com\"); Work with the first oracle object as usual. As always you can use the fully-qualified key oracle.com or chain get(key) calls to access the com property value. Config node \"oracle\" / \"com\" is a leaf node (has type VALUE )&#8230;&#8203; &#8230;&#8203; and has the name com (the last token in its key). The second object has name oracle.com . The code must escape the dot in the node&#8217;s name using oracle~1com . Or, use the utility method Config.Key.escapeName(name) to escape dots or tildes that might be in the node&#8217;s name, in this example in oracle.com . The config node \"oracle.com\" has type OBJECT &#8230;&#8203; &#8230;&#8203;and name \"oracle.com\" . ",
            "title": "Configuration Key"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Each filter accepts a key and the value as defined in the source, and returns the value to be used. The filter can leave the value unchanged or alter it, as it sees fit. The built-in <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigFilters.html#valueResolving--\">value-resolving filter enables the token substitution described below. See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigFilter.html\"> ConfigFilter JavaDoc for more information. ",
            "title": "Filters"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The overrides feature allows you to create an external document containing key/value pairs which replace the value otherwise returned for the name, and then add that document as an override source to a config builder. There are some key differences between overrides and filters. * Because overrides are loaded from sources those sources can change while your application runs and so the overrides they that prescribe can change. * The override document can use wildcards in key expressions. * Overrides can affect only keys that already exist in the original source; filters can supply values even if the key is absent from the config source. Each override entry consists of a Java properties-format definition. The key is an expression (which can use wildcards) to match config keys read from the current config sources, and the override value is the new value for any key matching the key expression from that entry. Order is important. The config system tests every key expression/value pair one by one in the order they appear in the overrides sources. Once the config system finds an override entry in which the key expression matches the configuration key, the system returns that entry&#8217;s value for the key being processed. See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/OverrideSource.html\"> OverrideSource JavaDoc for more detail. ",
            "title": "Overrides"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " A token reference is a key token starting with $ , optionally enclosed between { and } , i.e. $ref , ${ref} . Even a key composed of more than one token can be referenced in another key, i.e. ${env.ref} . As an example use case, you can use token references to declare the default values (see resolving-tokens.yaml below), while the references may be resolved in another config source, which identifies a current environment (see env.yaml examples below). You can then use the same overrides for different environments, say test and prod . The configuration in each environment is then overridden with a different values using wildcards (see overrides.properties below). <markup lang=\"java\" title=\"Initialize Config with Override Definition from overrides.properties file\" >Config config = Config.builder() .overrides(OverrideSources.file(\"conf/overrides.properties\")) .sources(file(\"conf/env.yaml\"), classpath(\"resolving-tokens.yaml\")) .build(); Loads overrides from the specified file. A deployment-specific environment configuration file. A default configuration containing token references that are resolved using the environment-specific override. ",
            "title": "Tokens"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " When your application retrieves a config value, the config system can transform it before returning the value, according to filters , overrides , and tokens . The config system provides some built-in instances of these you can use, and you can add your own as described in the sections which describe filters and overrides . Your application can add filters and overrides explicitly to a config builder and the config system by default uses the Java service loader mechanism to locate all available filters and overrides and add them automatically to all config builders (unless your code disables that behavior for a given builder). Filters Each filter accepts a key and the value as defined in the source, and returns the value to be used. The filter can leave the value unchanged or alter it, as it sees fit. The built-in <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigFilters.html#valueResolving--\">value-resolving filter enables the token substitution described below. See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigFilter.html\"> ConfigFilter JavaDoc for more information. Overrides The overrides feature allows you to create an external document containing key/value pairs which replace the value otherwise returned for the name, and then add that document as an override source to a config builder. There are some key differences between overrides and filters. * Because overrides are loaded from sources those sources can change while your application runs and so the overrides they that prescribe can change. * The override document can use wildcards in key expressions. * Overrides can affect only keys that already exist in the original source; filters can supply values even if the key is absent from the config source. Each override entry consists of a Java properties-format definition. The key is an expression (which can use wildcards) to match config keys read from the current config sources, and the override value is the new value for any key matching the key expression from that entry. Order is important. The config system tests every key expression/value pair one by one in the order they appear in the overrides sources. Once the config system finds an override entry in which the key expression matches the configuration key, the system returns that entry&#8217;s value for the key being processed. See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/OverrideSource.html\"> OverrideSource JavaDoc for more detail. Tokens A token reference is a key token starting with $ , optionally enclosed between { and } , i.e. $ref , ${ref} . Even a key composed of more than one token can be referenced in another key, i.e. ${env.ref} . As an example use case, you can use token references to declare the default values (see resolving-tokens.yaml below), while the references may be resolved in another config source, which identifies a current environment (see env.yaml examples below). You can then use the same overrides for different environments, say test and prod . The configuration in each environment is then overridden with a different values using wildcards (see overrides.properties below). <markup lang=\"java\" title=\"Initialize Config with Override Definition from overrides.properties file\" >Config config = Config.builder() .overrides(OverrideSources.file(\"conf/overrides.properties\")) .sources(file(\"conf/env.yaml\"), classpath(\"resolving-tokens.yaml\")) .build(); Loads overrides from the specified file. A deployment-specific environment configuration file. A default configuration containing token references that are resolved using the environment-specific override. ",
            "title": "Filter, Overrides, and Token Substitution"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The two methods PollingStrategies.regular(Duration) and PollingStrategies.watch(Path) return builders for their respective strategies. Both builders expose the executor method which your application can invoke, passing a java.util.concurrent.ScheduledExecutorService instance it wants used for the polling work. By default each polling strategy instance uses a separate thread pool executor. The following example shares the same executor for two different polling strategy instances. <markup lang=\"java\" title=\"Customize polling strategy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); Config config = Config.from( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy( PollingStrategies.regular(Duration.ofSeconds(2)) .executor(executor)), ConfigSources.file(\"conf/config.properties\") .pollingStrategy( path -&gt; PollingStrategies.watch(path) .executor(executor))); Prepares a thread pool executor with core pool size set 2 to be shared by all polling strategies. Selects the built-in periodic polling strategy. Tells the config system to use the specific executor to poll the dev.properties config source. Uses the Java filesystem WatchService to monitor the specified path. Tells the config system to use the same executor to monitor the path. ",
            "title": "Executors for Polling Strategy"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Recall that when a polling strategy detects a change in a source, it informs interested parties of the changes. By default each Config.Builder arranges for the resulting Config tree to use a shared executor that reuses available threads from a pool, creating new threads as needed. The same executor is used for actually reloading the source. Your application can invoke the polling strategy builder&#8217;s changesExecutor method to tell the builder to use a different Executor . (As an aside, your application can also control the size of the buffer used for holding source change events by invoking the builder&#8217;s changesMaxBuffer method. The default is 256.) <markup lang=\"java\" title=\"Customize config and override sources' executors\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.builder() .overrides( OverrideSources.file(\"conf/overrides.properties\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .sources( ConfigSources.file(\"conf/env.yaml\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .build(); Prepares a thread pool executor to be shared by selected sources. Tells the builder that the resulting overrides source should use the specified Executor for notifying interested parties of changes and for reloading the override source. Specifies an event buffer size of 4. Uses the same Executor and event buffer size for the config source as for the override source above. ",
            "title": "Publishers for Source Change Events"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " When your application supplies multiple sources to a config builder, as with Config.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and Config.from(List&lt;Supplier&lt;ConfigSource&gt;&gt;) , the config system automatically uses a composite config source which aggregates the separate sources but also listens for changes to any of the individual sources so it can delegate the change notification. For this change detection and notification the config system, by default, uses an executor with a dedicated thread pool that is shared across all Config instances. Your application can invoke the builder&#8217;s changesExecutor method to use a different ScheduledExecutorService instance. The builder returned by the from methods mentioned above is a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.CompositeBuilder.html\">CompositeBuilder which extends Config.Builder . Because a composite source might yield more numerous change events&#8201;&#8212;&#8201;because of the multiple underlying sources&#8201;&#8212;&#8201;your application can specify a debounce timeout for the composite source by invoking the CompositeBuilder.changesDebounce(Duration) method. The composite source aggregates multiple change events within this period into a single event and broadcasts that one instead and reloads the sources at that time, not necessarily in response to every single change in any source. The default is 100 milliseconds. <markup lang=\"java\" title=\"Customize composite source executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); Config config = Config.from( ConfigSources.from(file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies::watch), file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(4) .changesDebounce(Duration.ofSeconds(1))); Prepares a thread pool executor. ConfigSources.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) creates and returns a CompositeBuilder based on the two sources. Specifies a particular executor for monitoring and change event notification. Sets the subscriber&#8217;s buffer size to 4 events. The composite source discards any events not consumed by a subscriber if it needs to create room for more recent events. Change events will not fire more frequently than once per a second. ",
            "title": "Composite Config Source Executor"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " A loaded config tree subscribes to change events publishes by its source(s). By default, each Config uses an executor which manages a dedicated thread pool reusing previously-created threads when they are available and creating new threads as needed. All Config instances share the dedicated thread pool. Your application can specify a non-default Executor for a tree to use for accepting and propagating those events by invoking the changesExecutor method on the Config.Builder . Each source subscriber has a dedicated buffer for holding changes events. This defaults to 256 but you can tailor this value as needed. <markup lang=\"java\" title=\"Customize config executor\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.withSources( file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(16) .build(); Prepares a specific thread pool executor. Specifies the executor the Config tree will use to listen for and propagate change events. Sets the event subscriber buffer to 16 events. ",
            "title": "Config Custom Executor"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " You can control which executor a retry policy should use for its work. The RetryPolicies.repeat(int retries) method returns a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/RetryPolicies.Builder.html\">RetryPolicies.Builder . Your application can invoke the retry policy builder&#8217;s executor method to specify which ScheduledExecutorService instance it should use to schedule and execute delayed retries. By default the config system uses a separate thread pool executor for each retry policy instance. <markup lang=\"java\" title=\"Customize retry policy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2, myThreadFactory); Config config = Config.from( ConfigSources.file(\"conf/dev.properties\") .optional() .retryPolicy(RetryPolicies.repeat(2) .executor(executor))); Prepares a thread pool executor with core pool size set to 2 and a custom java.util.concurrent.ThreadFactory . When the source is flagged as optional() , the loading attempt will be repeated as the retry policy defines, but an overall failure will not lead to failing the initial load or preventing the source from being polled if so configured. Uses the built-in repeating implementation of RetryPolicy that can be used with any config source, but typically for ones that might suffer brief, intermittent outages. Specifies the executor to use for loading and retries. ",
            "title": "Retry Policy Custom Executor"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Various parts of the config system work asychronously: polling strategies to detect changes to config sources, publishers to notify your application when such changes occur, Config instances which subscribe to and respond to change notifications for their underlying sources, and retry policies (which might wait between retries). Each of these uses an executor to perform its work. The config system provides default executors, but your application can specify different ones if necessary. Executors for Polling Strategy The two methods PollingStrategies.regular(Duration) and PollingStrategies.watch(Path) return builders for their respective strategies. Both builders expose the executor method which your application can invoke, passing a java.util.concurrent.ScheduledExecutorService instance it wants used for the polling work. By default each polling strategy instance uses a separate thread pool executor. The following example shares the same executor for two different polling strategy instances. <markup lang=\"java\" title=\"Customize polling strategy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); Config config = Config.from( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy( PollingStrategies.regular(Duration.ofSeconds(2)) .executor(executor)), ConfigSources.file(\"conf/config.properties\") .pollingStrategy( path -&gt; PollingStrategies.watch(path) .executor(executor))); Prepares a thread pool executor with core pool size set 2 to be shared by all polling strategies. Selects the built-in periodic polling strategy. Tells the config system to use the specific executor to poll the dev.properties config source. Uses the Java filesystem WatchService to monitor the specified path. Tells the config system to use the same executor to monitor the path. Publishers for Source Change Events Recall that when a polling strategy detects a change in a source, it informs interested parties of the changes. By default each Config.Builder arranges for the resulting Config tree to use a shared executor that reuses available threads from a pool, creating new threads as needed. The same executor is used for actually reloading the source. Your application can invoke the polling strategy builder&#8217;s changesExecutor method to tell the builder to use a different Executor . (As an aside, your application can also control the size of the buffer used for holding source change events by invoking the builder&#8217;s changesMaxBuffer method. The default is 256.) <markup lang=\"java\" title=\"Customize config and override sources' executors\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.builder() .overrides( OverrideSources.file(\"conf/overrides.properties\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .sources( ConfigSources.file(\"conf/env.yaml\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .build(); Prepares a thread pool executor to be shared by selected sources. Tells the builder that the resulting overrides source should use the specified Executor for notifying interested parties of changes and for reloading the override source. Specifies an event buffer size of 4. Uses the same Executor and event buffer size for the config source as for the override source above. Composite Config Source Executor When your application supplies multiple sources to a config builder, as with Config.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and Config.from(List&lt;Supplier&lt;ConfigSource&gt;&gt;) , the config system automatically uses a composite config source which aggregates the separate sources but also listens for changes to any of the individual sources so it can delegate the change notification. For this change detection and notification the config system, by default, uses an executor with a dedicated thread pool that is shared across all Config instances. Your application can invoke the builder&#8217;s changesExecutor method to use a different ScheduledExecutorService instance. The builder returned by the from methods mentioned above is a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.CompositeBuilder.html\">CompositeBuilder which extends Config.Builder . Because a composite source might yield more numerous change events&#8201;&#8212;&#8201;because of the multiple underlying sources&#8201;&#8212;&#8201;your application can specify a debounce timeout for the composite source by invoking the CompositeBuilder.changesDebounce(Duration) method. The composite source aggregates multiple change events within this period into a single event and broadcasts that one instead and reloads the sources at that time, not necessarily in response to every single change in any source. The default is 100 milliseconds. <markup lang=\"java\" title=\"Customize composite source executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); Config config = Config.from( ConfigSources.from(file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies::watch), file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(4) .changesDebounce(Duration.ofSeconds(1))); Prepares a thread pool executor. ConfigSources.from(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) creates and returns a CompositeBuilder based on the two sources. Specifies a particular executor for monitoring and change event notification. Sets the subscriber&#8217;s buffer size to 4 events. The composite source discards any events not consumed by a subscriber if it needs to create room for more recent events. Change events will not fire more frequently than once per a second. Config Custom Executor A loaded config tree subscribes to change events publishes by its source(s). By default, each Config uses an executor which manages a dedicated thread pool reusing previously-created threads when they are available and creating new threads as needed. All Config instances share the dedicated thread pool. Your application can specify a non-default Executor for a tree to use for accepting and propagating those events by invoking the changesExecutor method on the Config.Builder . Each source subscriber has a dedicated buffer for holding changes events. This defaults to 256 but you can tailor this value as needed. <markup lang=\"java\" title=\"Customize config executor\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.withSources( file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(16) .build(); Prepares a specific thread pool executor. Specifies the executor the Config tree will use to listen for and propagate change events. Sets the event subscriber buffer to 16 events. Retry Policy Custom Executor You can control which executor a retry policy should use for its work. The RetryPolicies.repeat(int retries) method returns a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/RetryPolicies.Builder.html\">RetryPolicies.Builder . Your application can invoke the retry policy builder&#8217;s executor method to specify which ScheduledExecutorService instance it should use to schedule and execute delayed retries. By default the config system uses a separate thread pool executor for each retry policy instance. <markup lang=\"java\" title=\"Customize retry policy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2, myThreadFactory); Config config = Config.from( ConfigSources.file(\"conf/dev.properties\") .optional() .retryPolicy(RetryPolicies.repeat(2) .executor(executor))); Prepares a thread pool executor with core pool size set to 2 and a custom java.util.concurrent.ThreadFactory . When the source is flagged as optional() , the loading attempt will be repeated as the retry policy defines, but an overall failure will not lead to failing the initial load or preventing the source from being polled if so configured. Uses the built-in repeating implementation of RetryPolicy that can be used with any config source, but typically for ones that might suffer brief, intermittent outages. Specifies the executor to use for loading and retries. ",
            "title": "Executors for Asynchronous Config Activity"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " The config system represents configuration as a tree in memory. Many developers will choose to work directly with config values&#8201;&#8212;&#8201;values from the leaves in the tree&#8201;&#8212;&#8201;accessing them by their keys. You can also navigate explicitly among the nodes of the tree without using keys. This section describes what the tree looks like and how you can traverse it. ",
            "title": "preambule"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " The config system represents configuration in memory using three types of nodes, each a different interface defined within the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigNode.html\"> ConfigNode interface. ConfigNode Types Type Java Interface Usage object ConfigNode.ObjectNode Represents complex structure (a subtree). Its child nodes can be of any type. list ConfigNode.ListNode Represents a list of nodes. Its components can be of any type. value ConfigNode.ValueNode Represents a leaf node. A node of any type can have a String value. Each config tree in memory will have an object node as its root with child nodes as dictated by the source config data from which the config system built the tree. Missing Config Nodes If your application attempts to access a non-existent node, for example using <markup lang=\"java\" >config.get(\"key.does.not.exist\") the config system returns a Config node object with type MISSING . The in-memory config tree contains nodes only of types OBJECT , LIST , and VALUE . ",
            "title": "Configuration Node Types"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " The following example is in <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config/blob/master/HOCON.md\">HOCON (human-optimized config object notation) format. The config system supports HOCON as an extension module . <markup lang=\"hocon\" title=\"HOCON application.conf file\" >app { greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] } data { providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] } The diagram below illustrates the in-memory tree for that configuration. Config Nodes structure of application.conf file Notes Each non-root node has a name which distinguishes it from other nodes with the same parent. The interpretation of the name depends on the node type. Node Type Name value member name of the node within its parent list element index of the node within the containing list Each node&#8217;s key is the fully-qualified path using dotted names from the root to that node. The root has an empty key, empty name, and no value. The Config object exposes methods to return the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#name--\"> name , <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#key--\"> key , and <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#type--\"> type of the node. ",
            "title": "In-memory Representation of Configuration"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " For many applications, accessing configuration values by key will be the simplest approach. If you write the code with a specific configuration structure in mind, your code can retrieve the value from a specific configuration node very easily. Your application can specify the entire navigation path as the key to a single get invocation, using dotted notation to separate the names of the nodes along the path. The code can navigate one level at a time using chained get invocations, each specifying one level of the path to the expected node. Or, you can mix the two styles. All of the following lines retrieve the same Config node. <markup lang=\"java\" title=\"Equivalent Config Retrievals\" >assert config.get(\"\") == config; Config provName1 = config.get(\"data.providers.0.name\"); Config provName2 = config.get(\"data.providers.0\").get(\"name\"); Config provName3 = config.get(\"data.providers\").get(\"0.name\"); Config provName4 = config.get(\"data\").get(\"providers.0\").get(\"name\"); Config provName5 = config.get(\"data\").get(\"providers\").get(\"0\").get(\"name\"); using a single key mixed style (composite key and single key) navigating one level with each get invocation The Config.get(key) method always returns a Config object without throwing an exception. If the specified key does not exist the method returns a Config node of type MISSING . There are several ways your application can tell whether a given config value exists. Method Usage exists Returns true or false ifExistsOrElse Execute functional operations for present or missing nodes type Returns enum value for the Config.Type ; Config.Type.MISSING if the node represents a config value that does not exist asOptionalXXX On the returned Optional&lt;XXX&gt; invoke isPresent or one of the other, functional, methods such as ifPresent The config system throws a MissingValueException if the application tries to access the value of a missing node. ",
            "title": "Access by Key"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " Some applications might need to work with configuration without knowing its structure or key names ahead of time, and such applications can use various methods on the Config class to do this. General Config Node Methods Method Usage asNodeList(default) For nodes of type OBJECT returns the child nodes as a List . hasValue() For any node reports if the node has a value. This can be true for any node type except MISSING . isLeaf() Reports whether the node has no child nodes. Leaf nodes have no children and has a single value. key() Returns the fully-qualified path of the node using dotted notation. name() Returns the name of the node (the last part of the key). node() Returns an Optional&lt;Config&gt; wrapped around the node nodeList() Returns an Optional&lt;List&lt;Config&gt;&gt; consisting of child nodes if the node is a Type.OBJECT element nodes if the node is a Type.LIST Optional.empty() if the node is a Type.MISSING Throws ConfigMappingException if the node is a Type.VALUE traverse(Predicate&lt;Config&gt;) Returns a Stream&lt;Config&gt; as an iterative deepening depth-first traversal of the subtree type() Returns the Type enum value for the node: OBJECT , LIST , VALUE , or MISSING value() Returns the String value for the node, throwing ConfigMappingException if the node has no value (e.g., for some Type.Object or Type.List nodes) <markup lang=\"java\" title=\"List names of child nodes of an object node\" >List&lt;String&gt; appNodeNames = config.get(\"app\") .asNodeList() .stream().map(Config::name).sorted() .collect(Collectors.toList()); assert appNodeNames.get(0).equals(\"basic-range\"); assert appNodeNames.get(1).equals(\"greeting\"); assert appNodeNames.get(2).equals(\"page-size\"); Get child nodes of the app object node as a List of Config instances. Use the Java Stream API to collect all child names. Check that the list contains the expected child names: basic-range , greeting and page-size . <markup lang=\"java\" title=\"List child nodes of a list node\" >List&lt;Config&gt; providers = config.get(\"data.providers\") .asNodeList(); assert providers.get(0).key().toString().equals(\"data.providers.0\"); assert providers.get(1).key().toString().equals(\"data.providers.1\"); Get child nodes of the data.providers list node as a List of Config instances. Check that the list contains the expected child nodes with keys data.providers.0 and data.providers.1 . The traverse() method returns a stream of the nodes in the subtree that is rooted at the current configuration node. Depending on the structure of the loaded configuration the stream contains a mix of object, list or leaf value nodes. <markup lang=\"java\" title=\"Traverse subtree below a list node\" >config.get(\"data.providers\") .traverse() .forEach(node -&gt; System.out.println(node.type() + \" \\t\" + node.key())); Visit the subtree rooted at the data.providers list node. Prints out following list of nodes (type and key): OBJECT data.providers.0 VALUE data.providers.0.name VALUE data.providers.0.class OBJECT data.providers.1 VALUE data.providers.1.name VALUE data.providers.1.class The optional Predicate&lt;Config&gt; argument to the traverse methods allows the application to prune the traversal of a subtree at any point. <markup lang=\"java\" title=\"Traverse root ( object ) node, skipping the entire data subtree\" >config.traverse(node -&gt; !node.name().equals(\"data\")) .forEach(node -&gt; System.out.println(node.type() + \" \\t\" + node.key())); Visit all root sub-nodes, excluding whole data tree structure but including others. Prints out following list of nodes (type and key): OBJECT app VALUE app.page-size VALUE app.greeting LIST app.basic-range VALUE app.basic-range.0 VALUE app.basic-range.1 ",
            "title": "Access by General Navigation"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " Sometimes it can be convenient to write part of your application to deal with configuration without it knowing if or where the relevant configuration is plugged into a larger config tree. For example, the application.properties from the introduction section contains several settings prefixed with web such as web.page-size . Perhaps in another config source the same information might be stored as server.web.page-size : <markup lang=\"java\" title=\"Alternate Structure for Web Config\" >server.web.page-size: 40 server.web.debug = true server.web.ratio = 1.4 You might want to write the web portion of your app to work with a config subtree with keys that are independent of the subtree&#8217;s position in a larger tree. This would allow you to reuse the web portion of your application without change, regardless of which structure a config source used. One easy way to do this is to detach a subtree from a larger config tree. When your application invokes the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.html#detach--\"> Config.detach method it gets back a copy of the config node but with no parent. The copy and the original node both point to the same objects for their child nodes (if any). The original node is unchanged. <markup lang=\"java\" title=\"Detaching a Subtree\" >Config originalRoot = // from the original example `.conf` file Config alternateRoot = // from the alternate structure above Config detachedFromOriginal = originalRoot.get(\"web\").detach(); Config detachedFromAlternate = alternateRoot.get(\"server.web\").detach(); assert originalRoot.get(\"web.debug\").equals(\"true\"); assert alternateRoot.get(\"server.web.debug\").equals(\"true\"); assert detachedFromOriginal.get(\"debug\").equals(\"true\"); assert detachedFromAlternate.get(\"debug\").equals(\"true\"); Navigation depends on knowing the full structure of the config and so is different for the two cases. Detaching so the web node is the root can use the same key regardless of where the config subtree came from. ",
            "title": "Detaching a Config Subtree"
        },
        {
            "location": "/microprofile/05_security",
            "text": " To add security, such as protecting resource methods with authentication, to a MicroProfile application, add the Helidon security integration dependency to your project. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/05_security",
            "text": " For web server static content, see Configuration Secrets. For JAX-RS resources, declare security by adding annotations to a resource class or method. <markup lang=\"java\" title=\"Protected resource method\" >@GET @io.helidon.security.annot.Authenticated @io.helidon.security.annot.Authorized // you can also use io.helidon.security.abac.role.RoleValidator.Roles @RolesAllowed(\"admin\") public String adminResource(@Context io.helidon.security.SecurityContext securityContext) { return \"you are \" + securityContext.getUser(); } ",
            "title": "Securing a Web Resource"
        },
        {
            "location": "/microprofile/05_security",
            "text": "<markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.microprofile&lt;/groupId&gt; &lt;artifactId&gt;helidon-microprofile-security&lt;/artifactId&gt; &lt;/dependency&gt; Securing a Web Resource For web server static content, see Configuration Secrets. For JAX-RS resources, declare security by adding annotations to a resource class or method. <markup lang=\"java\" title=\"Protected resource method\" >@GET @io.helidon.security.annot.Authenticated @io.helidon.security.annot.Authorized // you can also use io.helidon.security.abac.role.RoleValidator.Roles @RolesAllowed(\"admin\") public String adminResource(@Context io.helidon.security.SecurityContext securityContext) { return \"you are \" + securityContext.getUser(); } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/about/01_introduction",
            "text": " Helidon是用于开发微服务的一个Java库集合。 没有唯一的工具或部署模型。你的微服务只是一个简单的Java SE 应用程序。 Helidon的基础由三部分组成： settings_ethernet WebServer 由Netty提供支持并具有响应式功能的编程HTTP API。 settings Config 灵活的配置框架，支持多种源和格式。 security Security 用于处理身份验证，授权和上下文传播的工具链。 ",
            "title": "介绍"
        },
        {
            "location": "/about/01_introduction",
            "text": " Helidon 快速入门示例 包含对Docker和Kubernetes的支持。只需按照示例操作，您就可以在几分钟内完成并运行简单的服务。 ",
            "title": "支持Docker和Kubernetes"
        },
        {
            "location": "/about/01_introduction",
            "text": " 在此基础之上，Helidon支持MicroProfile系列API，包括JAX-RS和CDI。这意味着您可以从以下两种编程模型中选择一种： Helidon SE: 一种函数式编程风格，直接使用Helidon WebServer，Config和Security API。这种方式将控制权全权交给你自己。 Helidon MP: 这是一种对Java EE程序员来说很熟悉的一种方式，此方式支持https://microprofile.io[MicroProfile] API等一系列更具说明性的模型。这对Java EE开发人员来说很熟悉。 我们的 快速入门示例 可让您开始使用这些编程模型中的任何一种。 支持Docker和Kubernetes Helidon 快速入门示例 包含对Docker和Kubernetes的支持。只需按照示例操作，您就可以在几分钟内完成并运行简单的服务。 ",
            "title": "MicroProfile"
        },
        {
            "location": "/getting-started/04_kubernetes",
            "text": " 对于开发人员来将，通常会在个人电脑上面运行Kubernetes环境，两种流行的方法是在Docker for Desktop中使用 <a id=\"\" title=\"\" target=\"_blank\" href=\"https://kubernetes.io/docs/getting-started-guides/minikube/\">Kubernetes Minikube 或 <a id=\"\" title=\"\" target=\"_blank\" href=\"https://docs.docker.com/docker-for-mac/kubernetes/\">Kubernetes Docker桌面版支持 。 在本指南中，我们将使用 <a id=\"\" title=\"\" target=\"_blank\" href=\"https://docs.docker.com/docker-for-mac/kubernetes/\">Kubernetes Docker桌面版支持 . ",
            "title": "preambule"
        },
        {
            "location": "/getting-started/04_kubernetes",
            "text": " 安装适用于 <a id=\"\" title=\"\" target=\"_blank\" href=\"https://docs.docker.com/docker-for-mac/install/\">Mac的Docker 或适用于 <a id=\"\" title=\"\" target=\"_blank\" href=\"https://docs.docker.com/docker-for-windows/install/\">Windows的Docker 。 要使用Kubernetes支持，您需要获得Edge Channel安装程序。 ",
            "title": "安装"
        },
        {
            "location": "/getting-started/04_kubernetes",
            "text": " 启用 <a id=\"\" title=\"\" target=\"_blank\" href=\"https://docs.docker.com/docker-for-mac/#kubernetes\">Kubernetes Support for Mac 或者 <a id=\"\" title=\"\" target=\"_blank\" href=\"https://docs.docker.com/docker-for-windows/#kubernetes\">Kubernetes Support for Windows . Kubernetes安装完成后，请确保正确设置上下文以使用docker-for-desktop。 <markup lang=\"bash\" title=\"确保将K8s上下文设置为docker-for-desktop\" >kubectl config get-contexts kubectl config use-context docker-for-desktop kubectl cluster-info kubectl version --short kubectl get nodes ",
            "title": "启用Kubernetes支持"
        },
        {
            "location": "/getting-started/04_kubernetes",
            "text": "",
            "title": "继续 快速入门示例 "
        },
        {
            "location": "/getting-started/03_managing-dependencies",
            "text": " Helidon提供了\"`Bill Of Materials`\" (BOM)来管理依赖。 这是一个提供了管理依赖的的特殊maven的pom文件。 使用Helidon BOM允许我们通过Helison的版本信息来使用Helidon的组件们。 ",
            "title": "preambule"
        },
        {
            "location": "/getting-started/03_managing-dependencies",
            "text": " 将以下代码段添加到pom.xml文件中, 以此来导入Helidon BOM。 <markup lang=\"xml\" title=\"导入Helidon BOM\" >&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon&lt;/groupId&gt; &lt;artifactId&gt;helidon-bom&lt;/artifactId&gt; &lt;version&gt;0.10.1-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; ",
            "title": "Helidon的BOM和POM"
        },
        {
            "location": "/getting-started/03_managing-dependencies",
            "text": " 导入BOM后，可以在不指定版本的情况下声明Helidon组件的依赖关系。 <markup lang=\"xml\" title=\"组件依赖\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "使用Helidon组件依赖项"
        },
        {
            "location": "/microprofile/03_application-configuration",
            "text": " Your application can use the MicroProfile Config or Helidon Config (or both). MicroProfile Config offers portability to other MicroProfile servers. Helidon Config supports a full tree structure, including repeating elements. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/03_application-configuration",
            "text": " You can inject values that the application can access from both MicroProfile Config and from Helidon Config. <markup lang=\"java\" title=\"JAX-RS - inject a single config property\" >@Inject public MyResource(@ConfigProperty(name=\"app.name\") String appName) { this.applicationName = appName; } You can also inject the whole configuration instance, either io.helidon.config.Config or org.eclipse.microprofile.config.Config . <markup lang=\"java\" title=\"JAX-RS - inject config\" >@Inject public MyResource(Config config) { this.config = config; } ",
            "title": "Configuring the Application"
        },
        {
            "location": "/microprofile/04_static-content",
            "text": " You can serve static content from a location in a file system or from the classpath. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/04_static-content",
            "text": "<markup lang=\"properties\" title=\"META-INF/microprofile-config.properties - File system static content\" ># Location of content on file system server.static.path.location=/var/www/html # default is index.html server.static.classpath.welcome=resource.html # static content path - default is \"/\" # server.static.classpath.context=/static-file <markup lang=\"properties\" title=\"META-INF/microprofile-config.properties - Classpath static content\" ># src/main/resources/WEB in your source tree server.static.classpath.location=/WEB # default is index.html server.static.classpath.welcome=resource.html # static content path - default is \"/\" # server.static.classpath.context=/static-cp ",
            "title": "Serving Static Content"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Configuration can be loaded from different types of locations and expressed in different formats. This section describes how your application can use config sources and config parsers together to load configuration data. ",
            "title": "preambule"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Each config source reads data from a location of a specific type, without regard to the format of the config data there. Each config parser converts data expressed in a particular format into the in-memory config data structure that the rest of the config system uses, without any concern for where that data resides or how it is physically retrieved. These two work together to prepare data in a given format at a given location for the config system. When your application prepares a Config.Builder it sets what ConfigSource s and ConfigParser s the builder should use in constructing the resulting Config object. ",
            "title": "Overview"
        },
        {
            "location": "/config/02_config-sources",
            "text": " If your application uses the default configuration, then the config system automatically sets up the config sources for you, as described in the config introduction . If instead your application uses a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html\"> Config.Builder , then it can invoke one of the sources methods on that builder to set which config sources it should use. The config system includes support for several types of config sources, for example: a resource on the runtime classpath, environment variables, a file, Java system properties, a URL, a variety of in-memory data structures ( String , Map , Properties ) See the JavaDoc for the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html\"> ConfigSources class for a complete list of the built-in config source types and how to use them. You can also extend the config system to handle other types of sources by implementing the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigSource.html\"> ConfigSource interface. See the extensions documentation for complete information. See the advanced topics page for further information on some more involved aspects of config sources. ",
            "title": "Config Sources"
        },
        {
            "location": "/config/02_config-sources",
            "text": " When it reads configuration text from sources, the config system uses config parsers to translate that text into the in-memory data structures representing that configuration. The config system includes several built-in parsers, such as for the Java properties, YAML, JSON, and HOCON formats. See this section in the introduction for how to change your pom.xml to make parsers for those formats available to your application. Then your application can invoke the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html#addParser-io.helidon.config.spi.ConfigParser-\">config builder&#8217;s addParser method so that builder will use the parsers you choose. You can extend the system with custom parsers of your own. Implement the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigParser.html\"> ConfigParser interface, then construct a Config.Builder using the addParser method, passing an instance of your customer parser. Invoke one of the sources methods to include a source that uses the custom format and then build the Config object. ",
            "title": "Config Parsers"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Each Config object which the config system returns to your application is immutable; even if the information in one of the underlying config sources changes, an in-memory data structure built from the earlier content remains unchanged. Even so, the config system allows your application to learn when such underlying changes in the data occur and respond accordingly. The mutability section explains this in detail, and the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/PollingStrategies.html\"> PollingStrategies JavaDoc describes the built-in implementations. You can, of course, write your own by implementing the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy interface. On a config source builder invoke pollingStrategy with an instance of your custom strategy and then invoke build to create the ConfigSource . ",
            "title": "Detecting and Responding to Changes in Config Data"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Config sources, especially those that depend on fallible mechanisms such as the network or a shared file system, might fail to load during momentary outages. The config system allows you to build resiliency into your application&#8217;s use of configuration that relies on such technologies. When your application builds a ConfigSource it can specify a retry policy . When the config system needs to load data from that source it delegates the load operation to that retry policy. That policy is responsible not only for loading the data but also for detecting errors during loading and implementing the algorithm for deciding when and how many times to retry a failed load before reporting a failure back to your application. The config system includes two predefined retry policies: Predefined Retry Policies Policy Summary \"just call\" (default) asks the config source to load the data with no retry \"repeat\" performs a settable number of time-based retries, reporting failure only after all available retries have failed See the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/RetryPolicies.html\"> RetryPolicies JavaDoc for complete details on these built-in retry policies. You can devise your own policy. Implement the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/RetryPolicy.html\"> RetryPolicy interface. Then pass an instance of your policy implementation to the config source builder&#8217;s retryPolicy method. ",
            "title": "Dealing with Loading Errors: Retry Policies"
        },
        {
            "location": "/security/01_introduction",
            "text": " Cloud Security provides the following features Authentication - support for authenticating incoming requests, creating a security Subject with Principal and Grants. Principal represents current user/service. Grant may represent a Role, Scope etc. Responsibility to create Principals and Grants lies with with AuthenticationProvider SPI. The following Principals are expected and supported out of the box: UserPrincipal - the party is an end-user (e.g. a person) - there can be zero to one user principals in a subject ServicePrincipal - the party is a service (e.g. a computer program) - there can be zero to one service principals in a subject Authorization - support for authorizing incoming requests. Out-of-the-box the security module supports ABAC and RBAC (Attribute based access control and Role based access control). RBAC is handled through RolesAllowed annotation (for integrations that support injection). Outbound security - support for propagating identity or (in general) securing outbound requests. Modification of a request to include outbound security is responsibility of OutboundSecurityProvider SPI Audit - security module audits most important events through its own API (e.g. Authentication events, Authorization events, outbound security events). A default AuditProvider is provided as well, logging to Java util logging (JUL) logger called \"AUDIT\" (may be overridden through configuration). AuditProvider SPI may be implemented to support other auditing options. Security module is quite HTTP centric (as most common use cases are related to HTTP REST), though it is not HTTP specific (the security module may be used to secure even other transports, such as JMS, Kafka messages etc. if an appropriate integration module is developed, as all APIs can be mapped to a non-HTTP protocol). Nevertheless there may be security providers that only make sense with HTTP (such as HTTP digest authentication). ",
            "title": "preambule"
        },
        {
            "location": "/security/01_introduction",
            "text": "<markup lang=\"java\" title=\"Security through a builder\" >Security security = Security.builder() // create a provider instance based on the provider documentation .addProvider(...) .build(); ",
            "title": "Builder pattern"
        },
        {
            "location": "/security/01_introduction",
            "text": " See Secure config for details about encrypting passwords in configuration files. <markup lang=\"java\" title=\"Security from configuration\" >// uses io.helidon.Config Security security = Security.fromConfig(config); <markup lang=\"conf\" title=\"Security from configuration - configuration\" ># Uses secure config tool to encryp passwords security.providers: [ { http-basic-auth { realm = \"helidon\" user-store { users: [ { login = \"aUser\" password = \"${CLEAR=somePassword}\" roles = [\"theRole\"] }, { login = \"noRoles\" password = \"${CLEAR=somePassword}\" roles = [] } ] } } } ] ",
            "title": "Configuration pattern"
        },
        {
            "location": "/security/01_introduction",
            "text": "<markup lang=\"java\" title=\"Security from configuration and builder\" >// uses io.helidon.Config Security security = Security.builderFromConfig(config) .addProvider(...) .build(); // or reverse order: Security security = Security.builder() .addProvider() .config(config) .build(); ",
            "title": "Hybrid pattern (Builder &amp; Configuration)"
        },
        {
            "location": "/security/01_introduction",
            "text": " To integrate with a container, or to use Security standalone, we must create an instance of security. In general, Security supports three approaches a fluent-API builder pattern - you configure everything \"by hand\" a configuration based pattern - you configure everything in a configuration file hybrid - you load a builder from configuration and update it in a program Once a security instance is built, it can be used to initialize an integration with a container , or to use security from a program directly: <markup lang=\"java\" title=\"Security direct usage\" >// create a security context SecurityContext context = security.contextBuilder(UUID.randomUUID().toString()) .env(SecurityEnvironment.builder() .method(\"get\") .path(\"/test\") .transport(\"http\") .header(\"Authorization\", \"Bearer abcdefgh\") .build()) .build(); // use the context to authenticate a request context.atnClientBuilder() .submit() .whenComplete((response, exception) -&gt; { // this is to show the features, not a real-world production code... if (null == exception) { if (response.getStatus().isSuccess()) { System.out.println(response.getUser()); System.out.println(response.getService()); } else { System.out.println(\"Authentication failed: \" + response.getDescription()); } } else { exception.printStackTrace(); } }); Builder pattern <markup lang=\"java\" title=\"Security through a builder\" >Security security = Security.builder() // create a provider instance based on the provider documentation .addProvider(...) .build(); Configuration pattern See Secure config for details about encrypting passwords in configuration files. <markup lang=\"java\" title=\"Security from configuration\" >// uses io.helidon.Config Security security = Security.fromConfig(config); <markup lang=\"conf\" title=\"Security from configuration - configuration\" ># Uses secure config tool to encryp passwords security.providers: [ { http-basic-auth { realm = \"helidon\" user-store { users: [ { login = \"aUser\" password = \"${CLEAR=somePassword}\" roles = [\"theRole\"] }, { login = \"noRoles\" password = \"${CLEAR=somePassword}\" roles = [] } ] } } } ] Hybrid pattern (Builder &amp; Configuration) <markup lang=\"java\" title=\"Security from configuration and builder\" >// uses io.helidon.Config Security security = Security.builderFromConfig(config) .addProvider(...) .build(); // or reverse order: Security security = Security.builder() .addProvider() .config(config) .build(); ",
            "title": "How to use"
        },
        {
            "location": "/security/01_introduction",
            "text": " You need to declare the following dependency in your project: <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/getting-started/01_prerequisites",
            "text": " 此处列出了使用想要开始使用Helidon所需的一切。 ",
            "title": "preambule"
        },
        {
            "location": "/getting-started/01_prerequisites",
            "text": " Helidon需要Java 8（或更高版本）和Maven。如果要构建和部署Docker容器，你则需要学习一些Docker的知识。 如果要将服务部署到Kubernetes，则需要`kubectl`和Kubernetes集群(您可以 在你电脑桌面上安装一个 )。 以下列表显示了最低版本要求： <div class=\"table__overflow elevation-1 flex sm7 \"> <a id=\"\" title=\"\" target=\"_blank\" href=\"https://www.oracle.com/technetwork/java/javase/downloads\">Java&#160;SE&#160;8 or <a id=\"\" title=\"\" target=\"_blank\" href=\"http://jdk.java.net\">Open&#160;JDK&#160;8 &#160; <a id=\"\" title=\"\" target=\"_blank\" href=\"https://maven.apache.org/download.cgi\">Maven 3.5 &#160; <a id=\"\" title=\"\" target=\"_blank\" href=\"https://docs.docker.com/install/\">Docker 18.02 使用Edge通道在桌面上运行Kubernetes <a id=\"\" title=\"\" target=\"_blank\" href=\"https://kubernetes.io/docs/tasks/tools/install-kubectl/\">Kubectl 1.7.4 &#160; <markup lang=\"bash\" title=\"检查环境配置\" >java --version mvn --version docker --version kubectl version --short ",
            "title": "先决条件"
        },
        {
            "location": "/getting-started/01_prerequisites",
            "text": "<markup lang=\"bash\" title=\"Setting JAVA_HOME\" ># On Mac export JAVA_HOME=`/usr/libexec/java_home -v 1.8` # On Linux # Use the appropriate path to your JDK export JAVA_HOME=/usr/lib/jvm/jdk-8 ",
            "title": "配置 JAVA_HOME"
        },
        {
            "location": "/getting-started/01_prerequisites",
            "text": " 现在您已准备好基础环境并可以进行尝试 快速入门示例 。 ",
            "title": "开始尝试快速开始示例"
        },
        {
            "location": "/webserver/05_error-handling",
            "text": " If no user-defined error handler is matched, or if the last error handler of the exception called req.next() , then the exception is translated to an HTTP response as follows: Subtypes of HttpException are translated to their associated HTTP error codes. <markup lang=\"java\" title=\"Reply with the 406 HTTP error code by throwing an exception\" >(req, res) -&gt; throw new HttpException(\"Amount of money must be greater than 0.\", Http.Status.NOT_ACCEPTABLE_406) Otherwise, the exceptions are translated to an Internal Server Error HTTP error code 500 . ",
            "title": "Default error handling"
        },
        {
            "location": "/webserver/05_error-handling",
            "text": " You may register an error handler for a specific Throwable in the Routing.Builder method. <markup lang=\"java\" >Routing routing = Routing.builder() .error(MyException.class, (req, res, ex) -&gt; { // handle the error, set the HTTP status code res.send(errorDescriptionObject); }) .build Registers an error handler that handles MyException that are thrown from the upstream handlers Finishes the request handling by sending a response Error handlers are called when an exception is thrown from a handler req.next(ex) is called, where ex is an instance of Throwable As with the standard handlers, the error handler must either send a response <markup lang=\"java\" >.error(MyException.class, (req, res, ex) -&gt; { res.status(Http.Status.BAD_REQUEST_400); res.send(\"Unable to parse request. Message: \" + ex.getMessage()); }) or, forward the error handling to the downstream error handlers <markup lang=\"java\" >.error(Throwable.class, (req, res, ex) -&gt; { // some logic req.next(ex); }) Error handling can&#8217;t be forwarded to the standard handlers. In fact, invoking req.next(ex) or req.next() in an error handler are equivalent. <markup lang=\"java\" >.error(Throwable.class, (req, res, ex) -&gt; { if (condition) { req.next(ex); } else { req.next(); } }) Call a downstream error handler with the Throwable instance. Here, req.next() is the same as req.next(ex) . In both cases, the downstream error handler is called. Default error handling If no user-defined error handler is matched, or if the last error handler of the exception called req.next() , then the exception is translated to an HTTP response as follows: Subtypes of HttpException are translated to their associated HTTP error codes. <markup lang=\"java\" title=\"Reply with the 406 HTTP error code by throwing an exception\" >(req, res) -&gt; throw new HttpException(\"Amount of money must be greater than 0.\", Http.Status.NOT_ACCEPTABLE_406) Otherwise, the exceptions are translated to an Internal Server Error HTTP error code 500 . ",
            "title": "Error Routing"
        },
        {
            "location": "/webserver/05_error-handling",
            "text": " You can also register an application that has its own handlers at a path prefix or context root. <markup lang=\"java\" title=\"Registering routing logic for a context root\" >.register(\"/context-root\", new MyComplexApplication()) <markup lang=\"java\" title=\"Routing logic implementation\" >public class MyComplexApplication implements Consumer&lt;Routing.Config&gt; { @Override public void accept(Routing.Config config) { config.get(\"/subpath\", (req, res) -&gt; {/* handler */}); } } In this example, the GET handler matches requests to /context-root/subpath . ",
            "title": "Registering an application - Organizing code into services"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " When security requires a configuration with repeating complex elements, use Helidon Config. This example configures a basic authentication provider and protects static content on the web server. It also includes annotations in Jersey. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " If you don&#8217;t provide an explicit instance of Helidon Config to a MicroProfile server, then the secure config filter is enabled by default . However, if you don&#8217;t configure it, the secure config filter only supports a template for aliasing that checks that no clear text passwords are present (template ${CLEAR=&#8230;&#8203;}. To add the secure config filter: <markup lang=\"java\" title=\"Add secure config filter\" >Config helidonConfig = Config.builder() .addFilter(SecureConfigFilter.fromConfig()) .build(); Put encrypted values into your configuration file so that it can be stored in a public repository with no danger of exposing the secret values. Be sure to use a strong and secret password. The supported templates are: Templates Template Description Example ${CLEAR=&#8230;&#8203;} Secret in clear text (for testing) - requiresEncryption must be disabled ${CLEAR=knownSecret} ${RSA=&#8230;&#8203;} Public/private key encryption, base64 value ${RSA=aGr3sFCMQznixrgbIk9qNfoLnO1cdi3H86qweCNjxFvH4dYg5IQM1EuoyTjJaXcSCG5MBskpeA3bjnWYrzeAFFlZHuYSPsb+wJVzGLrfUColTn+BPJjpJ3rmEd3AVkJl1ASfBBMh3q3deC+rvUdhfoTGBO8sC0teUATklCQSxfHOnIxswxqrplnoGXToGiTIfehiN2IZNulRKeoDQ0AeoKREmq5au4L8OOmS+D9BqnlKMc0F1tULZ7+h3Cxla4lXC5WRPoPfHBU4vzRZOGzeDvLkRgrD60caw/wKn5M0Wy1A1cKR8E46ceBXCjJ2eWIcLyhZSAZWDe3ceNrawHZtCg==} ${AES=&#8230;&#8203;} Shared secret ecryption, base64 value ${AES=D/UgMzsNb265HU1NDvdzm7tACHdsW6u1PjYEcRkV/OLiWcI+ET6Q4MKCz0zHyEh9} ${ALIAS=&#8230;&#8203;} Reference to another key ${ALIAS=someOtherKey} ",
            "title": "Protecting Configuration Secrets"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " The secure config filter has an option that defines whether encryption is required or not. If it&#8217;s set to true, which is the default, then: Configuration values with ${CLEAR=&#8230;&#8203;} template will cause an exception when requested. The filter fails during bootstrap if security.config.aes.insecure-passphrase is configured. ",
            "title": "Requiring encryption"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " The secure config filter provides a Main class io.helidon.security.tools.config.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using shared secret masterPassword \" >java io.helidon.security.tools.config.Main aes masterPassword secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. ",
            "title": "Encrypting values (AES)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " You can provide a shared secret in a couple of ways: in configuration - for testing/demo purposes only - key is security.config.aes.insecure-passphrase as an environment variable - SECURE_CONFIG_AES_MASTER_PWD ",
            "title": "Shared Secret (AES)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " Symmetric encryption is based on a shared secret that is known by the person encrypting the value and is also provided to the application. Encrypting values (AES) The secure config filter provides a Main class io.helidon.security.tools.config.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using shared secret masterPassword \" >java io.helidon.security.tools.config.Main aes masterPassword secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Shared Secret (AES) You can provide a shared secret in a couple of ways: in configuration - for testing/demo purposes only - key is security.config.aes.insecure-passphrase as an environment variable - SECURE_CONFIG_AES_MASTER_PWD ",
            "title": "Using symmetric encryption (AES)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " The secure config filter provides a Main class io.helidon.security.tools.config.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using public certificate in a keystore\" >java io.helidon.security.tools.config.Main rsa /path/to/keystore.p12 keystorePassword publicCertAlias secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. ",
            "title": "Encrypting values (RSA)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " You can configure the properties of a private key. These keys are prefixed with security.config.rsa RSA Configuration Options: Keystore What Configuration Key Environment Variable Description Keystore path keystore-path SECURE_CONFIG_RSA_PRIVATE_KEY Keystore is located in file system Keystore keystore-resource-path N/A Keystore is located on classpath Private key alias key-alias SECURE_CONFIG_PRIVATE_KEY_ALIAS Alias of the private key (such as \"1\", which is usually the default) Keystore passphrase keystore-passphrase SECURE_CONFIG_PRIVATE_KEYSTORE_PASSPHRASE Password for the keystore (and private key). RSA Configuration Options: PEM (PKCS#8) private key What Configuration Key Environment Variable Description Path pem-key-path SECURE_CONFIG_RSA_PEM_KEY Key is located on file system Resource path pem-key-resource-path N/A Key is located on classpath Passphrase pem-key-passphrase SECURE_CONFIG_PRIVATE_KEY_PASSPHRASE Password protecting the private key <markup lang=\"yaml\" title=\"Example yaml configuration\" >security.config: # Set to true for production - if set to true, clear text passwords will cause failure require-encryption: false # The \"master\" password for AES decryption. For production, set this via system property or environment variable. aes.insecure-passphrase: \"myMasterPasswordForEncryption\" # See documentation of pki-util rsa: # load from classpath keystore-resource-path: \".ssh/keystore.p12\" # If keystore is used, alias to use from the keystore (in this example, it is \"1\") key-alias: \"1\" # Password of keystore keystore-passphrase: \"helidon\" ",
            "title": "Configure secure config filter (RSA)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " This approach is based on a pair of keys: a public key which is known to anybody, and a private key which is known to a limited set of parties (usually a single person or process). For asymmetric encryption, the following is true: a value encrypted by a public key can only be decrypted by the private key a value encrypted by a private key can only be decrypted by the public key When using the secure config filter, you should encrypt the configuration values using the public key, and give the application process access to the private key to decrypt the values. Encrypting values (RSA) The secure config filter provides a Main class io.helidon.security.tools.config.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using public certificate in a keystore\" >java io.helidon.security.tools.config.Main rsa /path/to/keystore.p12 keystorePassword publicCertAlias secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Configure secure config filter (RSA) You can configure the properties of a private key. These keys are prefixed with security.config.rsa RSA Configuration Options: Keystore What Configuration Key Environment Variable Description Keystore path keystore-path SECURE_CONFIG_RSA_PRIVATE_KEY Keystore is located in file system Keystore keystore-resource-path N/A Keystore is located on classpath Private key alias key-alias SECURE_CONFIG_PRIVATE_KEY_ALIAS Alias of the private key (such as \"1\", which is usually the default) Keystore passphrase keystore-passphrase SECURE_CONFIG_PRIVATE_KEYSTORE_PASSPHRASE Password for the keystore (and private key). RSA Configuration Options: PEM (PKCS#8) private key What Configuration Key Environment Variable Description Path pem-key-path SECURE_CONFIG_RSA_PEM_KEY Key is located on file system Resource path pem-key-resource-path N/A Key is located on classpath Passphrase pem-key-passphrase SECURE_CONFIG_PRIVATE_KEY_PASSPHRASE Password protecting the private key <markup lang=\"yaml\" title=\"Example yaml configuration\" >security.config: # Set to true for production - if set to true, clear text passwords will cause failure require-encryption: false # The \"master\" password for AES decryption. For production, set this via system property or environment variable. aes.insecure-passphrase: \"myMasterPasswordForEncryption\" # See documentation of pki-util rsa: # load from classpath keystore-resource-path: \".ssh/keystore.p12\" # If keystore is used, alias to use from the keystore (in this example, it is \"1\") key-alias: \"1\" # Password of keystore keystore-passphrase: \"helidon\" ",
            "title": "Using asymmetric encryption (RSA)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": "<markup lang=\"yaml\" title=\"application.yaml\" >security: providers: # Attribute based access control, validates roles - abac: # HTTP Basic authentication provider - http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"password\" roles: [\"user\", \"admin\"] - login: \"jill\" password: \"password\" roles: [\"user\"] - login: \"john\" password: \"password\" # Protect static content - require authenticated user web-server: paths: - path: \"/static-cp[/{*}]\" authenticate: true Protecting Configuration Secrets If you don&#8217;t provide an explicit instance of Helidon Config to a MicroProfile server, then the secure config filter is enabled by default . However, if you don&#8217;t configure it, the secure config filter only supports a template for aliasing that checks that no clear text passwords are present (template ${CLEAR=&#8230;&#8203;}. To add the secure config filter: <markup lang=\"java\" title=\"Add secure config filter\" >Config helidonConfig = Config.builder() .addFilter(SecureConfigFilter.fromConfig()) .build(); Put encrypted values into your configuration file so that it can be stored in a public repository with no danger of exposing the secret values. Be sure to use a strong and secret password. The supported templates are: Templates Template Description Example ${CLEAR=&#8230;&#8203;} Secret in clear text (for testing) - requiresEncryption must be disabled ${CLEAR=knownSecret} ${RSA=&#8230;&#8203;} Public/private key encryption, base64 value ${RSA=aGr3sFCMQznixrgbIk9qNfoLnO1cdi3H86qweCNjxFvH4dYg5IQM1EuoyTjJaXcSCG5MBskpeA3bjnWYrzeAFFlZHuYSPsb+wJVzGLrfUColTn+BPJjpJ3rmEd3AVkJl1ASfBBMh3q3deC+rvUdhfoTGBO8sC0teUATklCQSxfHOnIxswxqrplnoGXToGiTIfehiN2IZNulRKeoDQ0AeoKREmq5au4L8OOmS+D9BqnlKMc0F1tULZ7+h3Cxla4lXC5WRPoPfHBU4vzRZOGzeDvLkRgrD60caw/wKn5M0Wy1A1cKR8E46ceBXCjJ2eWIcLyhZSAZWDe3ceNrawHZtCg==} ${AES=&#8230;&#8203;} Shared secret ecryption, base64 value ${AES=D/UgMzsNb265HU1NDvdzm7tACHdsW6u1PjYEcRkV/OLiWcI+ET6Q4MKCz0zHyEh9} ${ALIAS=&#8230;&#8203;} Reference to another key ${ALIAS=someOtherKey} Requiring encryption The secure config filter has an option that defines whether encryption is required or not. If it&#8217;s set to true, which is the default, then: Configuration values with ${CLEAR=&#8230;&#8203;} template will cause an exception when requested. The filter fails during bootstrap if security.config.aes.insecure-passphrase is configured. Using symmetric encryption (AES) Symmetric encryption is based on a shared secret that is known by the person encrypting the value and is also provided to the application. Encrypting values (AES) The secure config filter provides a Main class io.helidon.security.tools.config.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using shared secret masterPassword \" >java io.helidon.security.tools.config.Main aes masterPassword secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Shared Secret (AES) You can provide a shared secret in a couple of ways: in configuration - for testing/demo purposes only - key is security.config.aes.insecure-passphrase as an environment variable - SECURE_CONFIG_AES_MASTER_PWD Using asymmetric encryption (RSA) This approach is based on a pair of keys: a public key which is known to anybody, and a private key which is known to a limited set of parties (usually a single person or process). For asymmetric encryption, the following is true: a value encrypted by a public key can only be decrypted by the private key a value encrypted by a private key can only be decrypted by the public key When using the secure config filter, you should encrypt the configuration values using the public key, and give the application process access to the private key to decrypt the values. Encrypting values (RSA) The secure config filter provides a Main class io.helidon.security.tools.config.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using public certificate in a keystore\" >java io.helidon.security.tools.config.Main rsa /path/to/keystore.p12 keystorePassword publicCertAlias secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Configure secure config filter (RSA) You can configure the properties of a private key. These keys are prefixed with security.config.rsa RSA Configuration Options: Keystore What Configuration Key Environment Variable Description Keystore path keystore-path SECURE_CONFIG_RSA_PRIVATE_KEY Keystore is located in file system Keystore keystore-resource-path N/A Keystore is located on classpath Private key alias key-alias SECURE_CONFIG_PRIVATE_KEY_ALIAS Alias of the private key (such as \"1\", which is usually the default) Keystore passphrase keystore-passphrase SECURE_CONFIG_PRIVATE_KEYSTORE_PASSPHRASE Password for the keystore (and private key). RSA Configuration Options: PEM (PKCS#8) private key What Configuration Key Environment Variable Description Path pem-key-path SECURE_CONFIG_RSA_PEM_KEY Key is located on file system Resource path pem-key-resource-path N/A Key is located on classpath Passphrase pem-key-passphrase SECURE_CONFIG_PRIVATE_KEY_PASSPHRASE Password protecting the private key <markup lang=\"yaml\" title=\"Example yaml configuration\" >security.config: # Set to true for production - if set to true, clear text passwords will cause failure require-encryption: false # The \"master\" password for AES decryption. For production, set this via system property or environment variable. aes.insecure-passphrase: \"myMasterPasswordForEncryption\" # See documentation of pki-util rsa: # load from classpath keystore-resource-path: \".ssh/keystore.p12\" # If keystore is used, alias to use from the keystore (in this example, it is \"1\") key-alias: \"1\" # Password of keystore keystore-passphrase: \"helidon\" ",
            "title": "Protecting Static Content"
        },
        {
            "location": "/security/04_tools",
            "text": " Support for encrypting secrets in configuration files. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-tools-config&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Secure configuration"
        },
        {
            "location": "/security/04_tools",
            "text": " Configuration support for accessing private keys, public keys, certificates and certificate chains including runtime access to instances of such. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.common&lt;/groupId&gt; &lt;artifactId&gt;helidon-common-key-util&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Key and certificate configuration"
        },
        {
            "location": "/security/04_tools",
            "text": " Secure configuration Support for encrypting secrets in configuration files. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-tools-config&lt;/artifactId&gt; &lt;/dependency&gt; Key and certificate configuration Configuration support for accessing private keys, public keys, certificates and certificate chains including runtime access to instances of such. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.common&lt;/groupId&gt; &lt;artifactId&gt;helidon-common-key-util&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Tools"
        },
        {
            "location": "/security/04_tools",
            "text": " This guide guides you through extension possibilities for Security component. The component has the following extension points: Security providers Provider selection policy Integration with a framework ",
            "title": "Developer&#8217;s Guide"
        },
        {
            "location": "/security/04_tools",
            "text": " To create a custom authentication provider, create a class that implements \"io.helidon.security.spi.AuthenticationProvider\". Implementation is responsible for taking a request and assuming a subject based on that request. In case the protocol is multi-request (e.g. challenge for basic authentication), you have the possibility to return specific headers and a response code. The default semantics of these is HTTP, though providers may exist that are not HTTP specific. ",
            "title": "Authentication provider"
        },
        {
            "location": "/security/04_tools",
            "text": " To create a custom authorization provider, create a class that implements \"io.helidon.security.spi.AuthorizationProvider\". Implementation is responsible for taking a request and checking whether the request can continue processing (e.g. if the current user and/or service subject has a right to execute it). If authentication is configured, the Security component guarantees it resolved before authorization. ",
            "title": "Authorization provider"
        },
        {
            "location": "/security/04_tools",
            "text": " To create a custom outbound security provider, create a class that implements \"io.helidon.security.spi.OutboundSecurityProvider\". Implementation can update outgoing message headers to handle security for an outgoing request (e.g. identity propagation, mapping etc.). ",
            "title": "Outbound security provider"
        },
        {
            "location": "/security/04_tools",
            "text": " To create a custom audit provider, create a class that implements \"io.helidon.security.spi.AuditProvider\". Security component feeds each audit provider all messages from all components that invoke audit method on \"Security\" class, including internal audit events pre-configured in the component itself (e.g. authentication, authorization events). Implementation may do whatever desired with these messages, e.g.: filter them log them store them to a database forward them to an audit component discard them ",
            "title": "Audit provider"
        },
        {
            "location": "/security/04_tools",
            "text": " You can build a custom provider for each type of security concept supported. By default, each provider is asynchronous. To simplify simple cases, a class exists in \"spi\" package to help in implementing a synchronous approach: \"SynchronousProvider\". You have two options: 1. Implement a provider interface and reference it in configuration (or from builder) by class 2. Implement a provider interface and provide a java service implementing \"io.helidon.security.spi.SecurityProviderService\" The second option allows for easier configuration, as the configuration key can be used without a class definition and creates a default name of a provider. Authentication provider To create a custom authentication provider, create a class that implements \"io.helidon.security.spi.AuthenticationProvider\". Implementation is responsible for taking a request and assuming a subject based on that request. In case the protocol is multi-request (e.g. challenge for basic authentication), you have the possibility to return specific headers and a response code. The default semantics of these is HTTP, though providers may exist that are not HTTP specific. Authorization provider To create a custom authorization provider, create a class that implements \"io.helidon.security.spi.AuthorizationProvider\". Implementation is responsible for taking a request and checking whether the request can continue processing (e.g. if the current user and/or service subject has a right to execute it). If authentication is configured, the Security component guarantees it resolved before authorization. Outbound security provider To create a custom outbound security provider, create a class that implements \"io.helidon.security.spi.OutboundSecurityProvider\". Implementation can update outgoing message headers to handle security for an outgoing request (e.g. identity propagation, mapping etc.). Audit provider To create a custom audit provider, create a class that implements \"io.helidon.security.spi.AuditProvider\". Security component feeds each audit provider all messages from all components that invoke audit method on \"Security\" class, including internal audit events pre-configured in the component itself (e.g. authentication, authorization events). Implementation may do whatever desired with these messages, e.g.: filter them log them store them to a database forward them to an audit component discard them ",
            "title": "Security providers"
        },
        {
            "location": "/security/04_tools",
            "text": " Each request is processed by a single authentication and/or authorization provider. The selection policy provides the security component information about which provider to use. Out of the box, there are three policies: \"First\" policy - first configured provider (or explicitly defined default provider) is used by default, if a named provider is requested, it would be used \"Composite\" policy - this policy allows for a sequence of providers to be executed (e.g. one request may have more than one provider) - used for example to resolve service and user authentication \"Class\" policy - this allows usage of a custom policy defined by fully qualified class name To create a custom provider selection policy, create a class that implements \"io.helidon.security.spi.ProviderSelectionPolicy\". ",
            "title": "Provider selection policy"
        },
        {
            "location": "/security/04_tools",
            "text": " To integrate a new framework, you should create a single Security instance shared for a scope (e.g. one application). Security instance has a method to create a SecurityContext (request scope). Use tools of the framework integrated to add annotations support (if feasible). There are two annotations that should be supported: @Secured - to configure security, e.g. authentication, authorization @Audited - to configure auditing In addition you should implement integration of entity processing through Request builder - see integration for Jersey, class \"SecurityFilter\" ",
            "title": "Framework integration"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Helidon Config provides several extension modules that support other configuration formats (parsers) and sources. This section describes how to add these modules to your build and how to use them from your application. ",
            "title": "preambule"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " This document describes the additional config formats and sources the Helidon config system supports and how to include them and use them in your project. In each case you need to add module dependencies to your project and, in some cases, write your application accordingly. ",
            "title": "Introduction"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " With each of the parsers described here, your application can either explicitly add a parser of the correct implementation to the Config.Builder , or rely on Java service loading and the config system&#8217;s matching of file types and media types to parsers. If your application creates a Config.Builder with parser services disabled (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html#disableParserServices--\"> disableParserServices then that builder will not find the Java services for the various parsers and so will be unable to match the file type or media type of sources with the corresponding parser automatically. So if you want to use automatic type matching with a given builder, do not invoke Config.Builder.disableParserServices() . ",
            "title": "Automatic Media Type and File Type Handling"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency in your project: <markup lang=\"xml\" title=\"Config YAML Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-yaml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config YAML Dependency in module-info.java \" >module myModule { requires io.helidon.config.yaml; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The YAML parser handles the following media type: application/x-yaml - YAML format (file type .yaml ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.from(classpath(\"application.yaml\")); The config system automatically maps the file type .yaml to the media type application/x-yaml which the Helidon YAML parser matches. <markup lang=\"java\" title=\"YAML parser specified - no file type on source\" >Config config = Config.from(classpath(\"my-config\") .parser(YamlConfigParserBuilder.buildDefault())); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config on the runtime classpath using the YAML parser instance created by the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/yaml/YamlConfigParserBuilder.html\"> YamlConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.from(classpath(\"my-config\") .mediaType(\"application/x-yaml\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"YAML parser specified because parser services disabled\" >Config config = Config.withSources(classpath(\"application.yaml\")) .disableParserServices() .addParser(YamlConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the YAML parser is therefore required. ",
            "title": "Using the YAML Parser"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config YAML Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-yaml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config YAML Dependency in module-info.java \" >module myModule { requires io.helidon.config.yaml; } Using the YAML Parser The YAML parser handles the following media type: application/x-yaml - YAML format (file type .yaml ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.from(classpath(\"application.yaml\")); The config system automatically maps the file type .yaml to the media type application/x-yaml which the Helidon YAML parser matches. <markup lang=\"java\" title=\"YAML parser specified - no file type on source\" >Config config = Config.from(classpath(\"my-config\") .parser(YamlConfigParserBuilder.buildDefault())); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config on the runtime classpath using the YAML parser instance created by the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/yaml/YamlConfigParserBuilder.html\"> YamlConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.from(classpath(\"my-config\") .mediaType(\"application/x-yaml\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"YAML parser specified because parser services disabled\" >Config config = Config.withSources(classpath(\"application.yaml\")) .disableParserServices() .addParser(YamlConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the YAML parser is therefore required. ",
            "title": "YAML"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency in your project: <markup lang=\"xml\" title=\"Config HOCON Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-hocon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config HOCON Dependency in module-info.java \" >module myModule { requires io.helidon.config.hocon; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The parser handles the following media types: application/hocon - HOCON format (file type .conf ) application/json - JSON format (file type .json ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.from(classpath(\"application.conf\")); The config system automatically maps the file type .conf to the media type `application/hocon which the Helidon HOCON parser matches. The same module and parser supports file type .json and the media type application/json . <markup lang=\"java\" title=\"HOCON parser specified - no file type on source\" >Config config = Config.from(classpath(\"my-config\") .parser(HoconConfigParserBuilder.buildDefault())); the media type of the source `my-config`is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config using the HOCON parser created by the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/hocon/HoconConfigParserBuilder.html\">HoconConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.from(classpath(\"my-config\") .mediaType(\"application/hocon\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"HOCON parser specified because parser services disabled\" >Config config = Config.withSources(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the HOCON parser is therefore required. <markup lang=\"java\" title=\"Customized HOCON parser\" >Config config = Config.withSources(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.create() .disableResolving() .build()) .build(); Creates new instance of the parser builder. Disables resolution of substitutions. (See the <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config/blob/master/HOCON.md#substitutions\">HOCON documentation .) Builds a new instance of the HOCON config parser. You can also specify <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config/blob/master/config/src/main/java/com/typesafe/config/ConfigResolveOptions.java\"> ConfigResolveOptions using the HoconConfigParserBuilder.resolveOptions method. ",
            "title": "Using the HOCON/JSON Parser"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Helidon HOCON config module handles sources in the HOCON and JSON formats. Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config HOCON Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-hocon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config HOCON Dependency in module-info.java \" >module myModule { requires io.helidon.config.hocon; } Using the HOCON/JSON Parser The parser handles the following media types: application/hocon - HOCON format (file type .conf ) application/json - JSON format (file type .json ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.from(classpath(\"application.conf\")); The config system automatically maps the file type .conf to the media type `application/hocon which the Helidon HOCON parser matches. The same module and parser supports file type .json and the media type application/json . <markup lang=\"java\" title=\"HOCON parser specified - no file type on source\" >Config config = Config.from(classpath(\"my-config\") .parser(HoconConfigParserBuilder.buildDefault())); the media type of the source `my-config`is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config using the HOCON parser created by the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/hocon/HoconConfigParserBuilder.html\">HoconConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.from(classpath(\"my-config\") .mediaType(\"application/hocon\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"HOCON parser specified because parser services disabled\" >Config config = Config.withSources(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the HOCON parser is therefore required. <markup lang=\"java\" title=\"Customized HOCON parser\" >Config config = Config.withSources(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.create() .disableResolving() .build()) .build(); Creates new instance of the parser builder. Disables resolution of substitutions. (See the <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config/blob/master/HOCON.md#substitutions\">HOCON documentation .) Builds a new instance of the HOCON config parser. You can also specify <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config/blob/master/config/src/main/java/com/typesafe/config/ConfigResolveOptions.java\"> ConfigResolveOptions using the HoconConfigParserBuilder.resolveOptions method. ",
            "title": "HOCON/JSON"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Automatic Media Type and File Type Handling With each of the parsers described here, your application can either explicitly add a parser of the correct implementation to the Config.Builder , or rely on Java service loading and the config system&#8217;s matching of file types and media types to parsers. If your application creates a Config.Builder with parser services disabled (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html#disableParserServices--\"> disableParserServices then that builder will not find the Java services for the various parsers and so will be unable to match the file type or media type of sources with the corresponding parser automatically. So if you want to use automatic type matching with a given builder, do not invoke Config.Builder.disableParserServices() . YAML Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config YAML Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-yaml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config YAML Dependency in module-info.java \" >module myModule { requires io.helidon.config.yaml; } Using the YAML Parser The YAML parser handles the following media type: application/x-yaml - YAML format (file type .yaml ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.from(classpath(\"application.yaml\")); The config system automatically maps the file type .yaml to the media type application/x-yaml which the Helidon YAML parser matches. <markup lang=\"java\" title=\"YAML parser specified - no file type on source\" >Config config = Config.from(classpath(\"my-config\") .parser(YamlConfigParserBuilder.buildDefault())); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config on the runtime classpath using the YAML parser instance created by the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/yaml/YamlConfigParserBuilder.html\"> YamlConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.from(classpath(\"my-config\") .mediaType(\"application/x-yaml\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"YAML parser specified because parser services disabled\" >Config config = Config.withSources(classpath(\"application.yaml\")) .disableParserServices() .addParser(YamlConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the YAML parser is therefore required. HOCON/JSON The Helidon HOCON config module handles sources in the HOCON and JSON formats. Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config HOCON Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-hocon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config HOCON Dependency in module-info.java \" >module myModule { requires io.helidon.config.hocon; } Using the HOCON/JSON Parser The parser handles the following media types: application/hocon - HOCON format (file type .conf ) application/json - JSON format (file type .json ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.from(classpath(\"application.conf\")); The config system automatically maps the file type .conf to the media type `application/hocon which the Helidon HOCON parser matches. The same module and parser supports file type .json and the media type application/json . <markup lang=\"java\" title=\"HOCON parser specified - no file type on source\" >Config config = Config.from(classpath(\"my-config\") .parser(HoconConfigParserBuilder.buildDefault())); the media type of the source `my-config`is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config using the HOCON parser created by the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/hocon/HoconConfigParserBuilder.html\">HoconConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.from(classpath(\"my-config\") .mediaType(\"application/hocon\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"HOCON parser specified because parser services disabled\" >Config config = Config.withSources(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the HOCON parser is therefore required. <markup lang=\"java\" title=\"Customized HOCON parser\" >Config config = Config.withSources(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.create() .disableResolving() .build()) .build(); Creates new instance of the parser builder. Disables resolution of substitutions. (See the <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config/blob/master/HOCON.md#substitutions\">HOCON documentation .) Builds a new instance of the HOCON config parser. You can also specify <a id=\"\" title=\"\" target=\"_blank\" href=\"https://github.com/lightbend/config/blob/master/config/src/main/java/com/typesafe/config/ConfigResolveOptions.java\"> ConfigResolveOptions using the HoconConfigParserBuilder.resolveOptions method. ",
            "title": "Additional Config Formats and Parsers"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency to your project: <markup lang=\"xml\" title=\"Config Etcd Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-etcd&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config Etcd Dependency in module-info.java \" >module myModule { requires io.helidon.config.etcd; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " To read configuration from an Etcd source, your application uses the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/etcd/EtcdConfigSourceBuilder.html\"> EtcdConfigSourceBuilder . <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.from( EtcdConfigSourceBuilder .from(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdConfigSourceBuilder.EtcdApi.v3)); Use the factory method EtcdConfigSourceBuilder.from to initialize the builder. Specify the Etcd endpoint address. Specify the Etcd key of the configuration document. Version of the Etcd API to use; v2 and v3 are supported. The config system will use the YAML parser automatically in this example because the file type of the key is .yaml . The EtcdConfigSourceBuilder class extends <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html\"> AbstractParsableConfigSource.Builder and so supports the usual settings on config sources. ",
            "title": "Using the Etcd Config Source"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Etcd support includes a polling strategy designed for an etcd config source. <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.from( EtcdConfigSourceBuilder .from(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdApi.v3) .pollingStrategy(EtcdWatchPollingStrategy::new)); Use the etcd-specific polling strategy. ",
            "title": "Monitoring for Source Changes"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from an Etcd source set the following required properties for the source: type to etcd , or class to io.helidon.config.etcd.EtcdConfigSourceBuilder uri (type URI ) - Etcd endpoint URI. key (type String ) - Etcd key that is associated with the configuration. api (type EtcdConfigSourceBuilder.EtcdApi , i.e. v2 or v3 ) - Etcd API version. Other optional properties are inherited from AbstractParsableConfigSource.Builder . (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html#init-io.helidon.config.Config-\">javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-etcd.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-etcd.yaml for the etcd source\" >sources: - type: \"etcd\" properties: uri: \"http://my-etcd:2379\" key: \"/config.yaml\" api: \"v3\" polling-strategy: class: \"io.helidon.config.etcd.EtcdWatchPollingStrategy\" etcd config source type Etcd source-specific (mandatory) properties : uri , key and api . Polling strategy EtcdWatchPollingStrategy is automatically initialized by specified mandatory properties . ",
            "title": "Loading Meta-configuration via Etcd"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Helidon Etcd config module supports reading configuration from a specified Etcd key. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config Etcd Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-etcd&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config Etcd Dependency in module-info.java \" >module myModule { requires io.helidon.config.etcd; } Using the Etcd Config Source To read configuration from an Etcd source, your application uses the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/etcd/EtcdConfigSourceBuilder.html\"> EtcdConfigSourceBuilder . <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.from( EtcdConfigSourceBuilder .from(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdConfigSourceBuilder.EtcdApi.v3)); Use the factory method EtcdConfigSourceBuilder.from to initialize the builder. Specify the Etcd endpoint address. Specify the Etcd key of the configuration document. Version of the Etcd API to use; v2 and v3 are supported. The config system will use the YAML parser automatically in this example because the file type of the key is .yaml . The EtcdConfigSourceBuilder class extends <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html\"> AbstractParsableConfigSource.Builder and so supports the usual settings on config sources. Monitoring for Source Changes The Etcd support includes a polling strategy designed for an etcd config source. <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.from( EtcdConfigSourceBuilder .from(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdApi.v3) .pollingStrategy(EtcdWatchPollingStrategy::new)); Use the etcd-specific polling strategy. Loading Meta-configuration via Etcd The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from an Etcd source set the following required properties for the source: type to etcd , or class to io.helidon.config.etcd.EtcdConfigSourceBuilder uri (type URI ) - Etcd endpoint URI. key (type String ) - Etcd key that is associated with the configuration. api (type EtcdConfigSourceBuilder.EtcdApi , i.e. v2 or v3 ) - Etcd API version. Other optional properties are inherited from AbstractParsableConfigSource.Builder . (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html#init-io.helidon.config.Config-\">javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-etcd.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-etcd.yaml for the etcd source\" >sources: - type: \"etcd\" properties: uri: \"http://my-etcd:2379\" key: \"/config.yaml\" api: \"v3\" polling-strategy: class: \"io.helidon.config.etcd.EtcdWatchPollingStrategy\" etcd config source type Etcd source-specific (mandatory) properties : uri , key and api . Polling strategy EtcdWatchPollingStrategy is automatically initialized by specified mandatory properties . ",
            "title": "Etcd"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency to your project: <markup lang=\"xml\" title=\"Config git Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-git&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config git Dependency in module-info.java \" >module myModule { requires io.helidon.config.git; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " To read configuration from a git source, your application uses the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/git/GitConfigSourceBuilder.html\"> GitConfigSourceBuilder . <markup lang=\"java\" title=\"Use git config source\" >Config config = Config.from( GitConfigSourceBuilder .from(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .directory(Paths.get(\"/config\")) .branch(\"dev\")); Use the factory method GitConfigSourceBuilder.from to initialize the builder with a mandatory path to the configuration file. Specify the git repository URI. Specify a directory where the git repository is already cloned or it will be cloned. Specify the git branch. Note that the config system will use the HOCON parser in this example because the file type is .conf . Recall that for this to work the HOCON config module must be on module-path or classpath. The GitConfigSourceBuilder supports the usual source builder properties because it extends <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html\"> AbstractParsableConfigSource.Builder . ",
            "title": "Using the git Config Source"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Your application can monitor changes to a configuration loaded from a git source associating the regular built-in polling strategy with the source. <markup lang=\"java\" title=\"Use of git config source with polling strategy\" >Config config = Config.from( GitConfigSourceBuilder .from(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .pollingStrategy(PollingStrategies.regular(Duration.ofMinutes(5)))); Use PollingStrategies.regular(Duration duration) to monitor for config changes. You can also implemention your own polling strategy by implementing <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy . See the mutability support and polling strategy discussions. ",
            "title": "Monitoring for Source Changes"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from a git config source set the following properties for the source: type to git or class to io.helidon.config.git.GitConfigSourceBuilder path (type String ) - Relative path to the configuration file in repository. uri (type URI ) - URI to the git repository. directory (type Path ) - Directory with a cloned repository, by default a temporary directory. branch (type String ) - git branch (default is master ). The meta-configuration must set the path and one of uri or directory . Other optional properties are inherited from AbstractParsableConfigSource.Builder (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html#init-io.helidon.config.Config-\">javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-git.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-git.yaml for the git source\" >sources: - type: \"git\" properties: path: \"application.conf\" uri: \"https://github.com/okosatka/test-config.git\" directory: \"/config\" branch: \"dev\" polling-strategy: type: \"regular\" properties: interval: \"PT5M\" git config source type git source-specific properties: path , uri , directory and branch . Polling strategy regular with an interval, in Duration format, of 5 minutes in this example. ",
            "title": "Loading Meta-configuration via git"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Helidon git config module supports reading configuration from a git repository. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config git Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-git&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config git Dependency in module-info.java \" >module myModule { requires io.helidon.config.git; } Using the git Config Source To read configuration from a git source, your application uses the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/git/GitConfigSourceBuilder.html\"> GitConfigSourceBuilder . <markup lang=\"java\" title=\"Use git config source\" >Config config = Config.from( GitConfigSourceBuilder .from(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .directory(Paths.get(\"/config\")) .branch(\"dev\")); Use the factory method GitConfigSourceBuilder.from to initialize the builder with a mandatory path to the configuration file. Specify the git repository URI. Specify a directory where the git repository is already cloned or it will be cloned. Specify the git branch. Note that the config system will use the HOCON parser in this example because the file type is .conf . Recall that for this to work the HOCON config module must be on module-path or classpath. The GitConfigSourceBuilder supports the usual source builder properties because it extends <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html\"> AbstractParsableConfigSource.Builder . Monitoring for Source Changes Your application can monitor changes to a configuration loaded from a git source associating the regular built-in polling strategy with the source. <markup lang=\"java\" title=\"Use of git config source with polling strategy\" >Config config = Config.from( GitConfigSourceBuilder .from(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .pollingStrategy(PollingStrategies.regular(Duration.ofMinutes(5)))); Use PollingStrategies.regular(Duration duration) to monitor for config changes. You can also implemention your own polling strategy by implementing <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy . See the mutability support and polling strategy discussions. Loading Meta-configuration via git The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from a git config source set the following properties for the source: type to git or class to io.helidon.config.git.GitConfigSourceBuilder path (type String ) - Relative path to the configuration file in repository. uri (type URI ) - URI to the git repository. directory (type Path ) - Directory with a cloned repository, by default a temporary directory. branch (type String ) - git branch (default is master ). The meta-configuration must set the path and one of uri or directory . Other optional properties are inherited from AbstractParsableConfigSource.Builder (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html#init-io.helidon.config.Config-\">javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-git.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-git.yaml for the git source\" >sources: - type: \"git\" properties: path: \"application.conf\" uri: \"https://github.com/okosatka/test-config.git\" directory: \"/config\" branch: \"dev\" polling-strategy: type: \"regular\" properties: interval: \"PT5M\" git config source type git source-specific properties: path , uri , directory and branch . Polling strategy regular with an interval, in Duration format, of 5 minutes in this example. ",
            "title": "git"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Etcd The Helidon Etcd config module supports reading configuration from a specified Etcd key. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config Etcd Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-etcd&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config Etcd Dependency in module-info.java \" >module myModule { requires io.helidon.config.etcd; } Using the Etcd Config Source To read configuration from an Etcd source, your application uses the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/etcd/EtcdConfigSourceBuilder.html\"> EtcdConfigSourceBuilder . <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.from( EtcdConfigSourceBuilder .from(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdConfigSourceBuilder.EtcdApi.v3)); Use the factory method EtcdConfigSourceBuilder.from to initialize the builder. Specify the Etcd endpoint address. Specify the Etcd key of the configuration document. Version of the Etcd API to use; v2 and v3 are supported. The config system will use the YAML parser automatically in this example because the file type of the key is .yaml . The EtcdConfigSourceBuilder class extends <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html\"> AbstractParsableConfigSource.Builder and so supports the usual settings on config sources. Monitoring for Source Changes The Etcd support includes a polling strategy designed for an etcd config source. <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.from( EtcdConfigSourceBuilder .from(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdApi.v3) .pollingStrategy(EtcdWatchPollingStrategy::new)); Use the etcd-specific polling strategy. Loading Meta-configuration via Etcd The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from an Etcd source set the following required properties for the source: type to etcd , or class to io.helidon.config.etcd.EtcdConfigSourceBuilder uri (type URI ) - Etcd endpoint URI. key (type String ) - Etcd key that is associated with the configuration. api (type EtcdConfigSourceBuilder.EtcdApi , i.e. v2 or v3 ) - Etcd API version. Other optional properties are inherited from AbstractParsableConfigSource.Builder . (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html#init-io.helidon.config.Config-\">javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-etcd.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-etcd.yaml for the etcd source\" >sources: - type: \"etcd\" properties: uri: \"http://my-etcd:2379\" key: \"/config.yaml\" api: \"v3\" polling-strategy: class: \"io.helidon.config.etcd.EtcdWatchPollingStrategy\" etcd config source type Etcd source-specific (mandatory) properties : uri , key and api . Polling strategy EtcdWatchPollingStrategy is automatically initialized by specified mandatory properties . git The Helidon git config module supports reading configuration from a git repository. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config git Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-git&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config git Dependency in module-info.java \" >module myModule { requires io.helidon.config.git; } Using the git Config Source To read configuration from a git source, your application uses the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/git/GitConfigSourceBuilder.html\"> GitConfigSourceBuilder . <markup lang=\"java\" title=\"Use git config source\" >Config config = Config.from( GitConfigSourceBuilder .from(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .directory(Paths.get(\"/config\")) .branch(\"dev\")); Use the factory method GitConfigSourceBuilder.from to initialize the builder with a mandatory path to the configuration file. Specify the git repository URI. Specify a directory where the git repository is already cloned or it will be cloned. Specify the git branch. Note that the config system will use the HOCON parser in this example because the file type is .conf . Recall that for this to work the HOCON config module must be on module-path or classpath. The GitConfigSourceBuilder supports the usual source builder properties because it extends <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html\"> AbstractParsableConfigSource.Builder . Monitoring for Source Changes Your application can monitor changes to a configuration loaded from a git source associating the regular built-in polling strategy with the source. <markup lang=\"java\" title=\"Use of git config source with polling strategy\" >Config config = Config.from( GitConfigSourceBuilder .from(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .pollingStrategy(PollingStrategies.regular(Duration.ofMinutes(5)))); Use PollingStrategies.regular(Duration duration) to monitor for config changes. You can also implemention your own polling strategy by implementing <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy . See the mutability support and polling strategy discussions. Loading Meta-configuration via git The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from a git config source set the following properties for the source: type to git or class to io.helidon.config.git.GitConfigSourceBuilder path (type String ) - Relative path to the configuration file in repository. uri (type URI ) - URI to the git repository. directory (type Path ) - Directory with a cloned repository, by default a temporary directory. branch (type String ) - git branch (default is master ). The meta-configuration must set the path and one of uri or directory . Other optional properties are inherited from AbstractParsableConfigSource.Builder (see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/AbstractParsableConfigSource.Builder.html#init-io.helidon.config.Config-\">javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-git.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-git.yaml for the git source\" >sources: - type: \"git\" properties: path: \"application.conf\" uri: \"https://github.com/okosatka/test-config.git\" directory: \"/config\" branch: \"dev\" polling-strategy: type: \"regular\" properties: interval: \"PT5M\" git config source type git source-specific properties: path , uri , directory and branch . Polling strategy regular with an interval, in Duration format, of 5 minutes in this example. ",
            "title": "Additional Config Source Types"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " MicroProfile is a platform definition that is familiar to Java EE developers. If you have experience with JAX-RS, JSON-P, and CDI, you may prefer to use this model. To extend the functionality of your MicroProfile application, you might also decide to use the Helidon core APIs, especially for configuration and security. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.microprofile.bundles&lt;/groupId&gt; &lt;artifactId&gt;helidon-microprofile-1.1&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Create a JAX-RS Resource class with at least one resource method. <markup lang=\"java\" title=\"Sample JAX-RS Resource Class\" >@Path(\"/\") @RequestScoped public class HelloWorldResource { @GET @Produces(MediaType.TEXT_PLAIN) public String message() { return \"Hello World\"; } } And create a JAX-RS application. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >@ApplicationScoped @ApplicationPath(\"/\") public class HelloWorldApplication extends Application { @Override public Set&lt;Class&lt;?&gt;&gt; getClasses() { return Set.of( HelloWorldResource.class ); } } Add beans.xml in src/main/resources/META-INF so the CDI implementation can pick up your classes. <markup lang=\"xml\" title=\"beans.xml\" >&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans/&gt; As a last step, add a main method to your application (or a dedicated Main class) to start everything up. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >public static void main(String[] args) { io.helidon.microprofile.server.Main.main(args); } Run the main class. The server will start on port 7001 and serve your resources. ",
            "title": "Project files"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Jandex is an indexing tool for Weld (CDI implementation) that helps speed up the boot time of an application. To use Jandex, configure a Maven plugin that adds the index to your JAR file and a dependency on Jandex. <markup lang=\"xml\" title=\"jandex dependency\" >&lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.0.4.Final&lt;/version&gt; &lt;/dependency&gt; <markup lang=\"xml\" title=\"jandex plugin configuration\" >&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt; &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-index&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jandex&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ",
            "title": "Adding Jandex"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Complete these tasks to get started with your MicroProfile application. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.microprofile.bundles&lt;/groupId&gt; &lt;artifactId&gt;helidon-microprofile-1.1&lt;/artifactId&gt; &lt;/dependency&gt; Project files Create a JAX-RS Resource class with at least one resource method. <markup lang=\"java\" title=\"Sample JAX-RS Resource Class\" >@Path(\"/\") @RequestScoped public class HelloWorldResource { @GET @Produces(MediaType.TEXT_PLAIN) public String message() { return \"Hello World\"; } } And create a JAX-RS application. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >@ApplicationScoped @ApplicationPath(\"/\") public class HelloWorldApplication extends Application { @Override public Set&lt;Class&lt;?&gt;&gt; getClasses() { return Set.of( HelloWorldResource.class ); } } Add beans.xml in src/main/resources/META-INF so the CDI implementation can pick up your classes. <markup lang=\"xml\" title=\"beans.xml\" >&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans/&gt; As a last step, add a main method to your application (or a dedicated Main class) to start everything up. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >public static void main(String[] args) { io.helidon.microprofile.server.Main.main(args); } Run the main class. The server will start on port 7001 and serve your resources. Adding Jandex Jandex is an indexing tool for Weld (CDI implementation) that helps speed up the boot time of an application. To use Jandex, configure a Maven plugin that adds the index to your JAR file and a dependency on Jandex. <markup lang=\"xml\" title=\"jandex dependency\" >&lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.0.4.Final&lt;/version&gt; &lt;/dependency&gt; <markup lang=\"xml\" title=\"jandex plugin configuration\" >&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt; &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-index&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jandex&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ",
            "title": "Getting Started with Helidon MicroProfile"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"WebServer Jersey Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-jersey&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " You can also register the JAX-RS Application object. <markup lang=\"java\" title=\"Register the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder(new MyApplication()) .build()) .build(); Register the Jersey application at /jersey context root MyApplication handles requests made to /jersey context root. ",
            "title": "Registering JAX-RS Application"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " To access WebServer internals, inject the following beans into the Jersey managed beans: request scoped ServerRequest and/or request scoped ServerResponse <markup lang=\"java\" title=\"Injection of WebServer internal objects\" >@Path(\"/\") public class HelloWorld { @Inject private ServerRequest request; @Inject private ServerResponse response; } ",
            "title": "Accessing WebServer internals from a Jersey application"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " To register a Jersey application at a context root, use the JerseySupport class and its JerseySupport.Builder builder. JerseySupport can register the JAX-RS resources directly. <markup lang=\"java\" title=\"Jersey (JAX-RS) HelloWorld resource\" >@Path(\"/\") public class HelloWorld { @GET @Path(\"hello\") public Response hello() { return Response.ok(\"Hello World!\").build(); } } <markup lang=\"java\" title=\"Registering the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder() .register(HelloWorld.class) .build()) .build(); Register the Jersey application at /jersey context root The Jersey Application stays hidden and consists of a single HelloWorld resource class As a result, an HTTP GET request to /jersey/hello would yield a Hello World! response string. Registering JAX-RS Application You can also register the JAX-RS Application object. <markup lang=\"java\" title=\"Register the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder(new MyApplication()) .build()) .build(); Register the Jersey application at /jersey context root MyApplication handles requests made to /jersey context root. Accessing WebServer internals from a Jersey application To access WebServer internals, inject the following beans into the Jersey managed beans: request scoped ServerRequest and/or request scoped ServerResponse <markup lang=\"java\" title=\"Injection of WebServer internal objects\" >@Path(\"/\") public class HelloWorld { @Inject private ServerRequest request; @Inject private ServerResponse response; } ",
            "title": "Registering a Jersey Application"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " You can register a Jersey (JAX-RS) application at a context root using the JerseySupport class. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" title=\"WebServer Jersey Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-jersey&lt;/artifactId&gt; &lt;/dependency&gt; Registering a Jersey Application To register a Jersey application at a context root, use the JerseySupport class and its JerseySupport.Builder builder. JerseySupport can register the JAX-RS resources directly. <markup lang=\"java\" title=\"Jersey (JAX-RS) HelloWorld resource\" >@Path(\"/\") public class HelloWorld { @GET @Path(\"hello\") public Response hello() { return Response.ok(\"Hello World!\").build(); } } <markup lang=\"java\" title=\"Registering the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder() .register(HelloWorld.class) .build()) .build(); Register the Jersey application at /jersey context root The Jersey Application stays hidden and consists of a single HelloWorld resource class As a result, an HTTP GET request to /jersey/hello would yield a Hello World! response string. Registering JAX-RS Application You can also register the JAX-RS Application object. <markup lang=\"java\" title=\"Register the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder(new MyApplication()) .build()) .build(); Register the Jersey application at /jersey context root MyApplication handles requests made to /jersey context root. Accessing WebServer internals from a Jersey application To access WebServer internals, inject the following beans into the Jersey managed beans: request scoped ServerRequest and/or request scoped ServerResponse <markup lang=\"java\" title=\"Injection of WebServer internal objects\" >@Path(\"/\") public class HelloWorld { @Inject private ServerRequest request; @Inject private ServerResponse response; } ",
            "title": "JAX-RS Support"
        },
        {
            "location": "/config/07_extensions",
            "text": " Developer-provided extensions influence how the config system behaves. The config system introduction explains the design of the config system and how its parts work together to read and parse config data, convert it to Java types, fine-tune the look-up of config data, and reload and reprocess data when it changes. Config extensions provided by the application modify and expand the way the config system performs these steps. ",
            "title": "preambule"
        },
        {
            "location": "/config/07_extensions",
            "text": " The config system invokes extensions of a given type in priority order. Developers can express the relative importance of an extension by annotating the implementation class with @javax.annotation.Priority . The default value is 100. A lower priority value represents greater importance. The sections below for each interface tell which SPIs support @Priority . ",
            "title": "About Priority"
        },
        {
            "location": "/config/07_extensions",
            "text": " Each config extension implements one of the interfaces defined in the Configuration SPI: ConfigSource - Loads raw configuration data from a given type of source and delegates to a ConfigParser , producing the in-memory data structure which represents the loaded and parsed configuration. ConfigParser - Translates configuration content in a given format into the corresponding internal config data structures. OverrideSource - Provides key/value pairs which override config values loaded from any ConfigSource , given the key and ignoring the original value. ConfigFilter - Transforms config String values returned from any value-type Config node, given the key and the original value. ConfigMapperProvider - Provides one or more ConfigMapper s each of which converts a Config object tree to a Java type specific to the application. PollingStrategy - Implements a custom technique for notifying the Config system when the data underlying a ConfigSource or OverrideSource has changed. The config system itself implements several of these SPIs, as noted in the sections below. About Priority The config system invokes extensions of a given type in priority order. Developers can express the relative importance of an extension by annotating the implementation class with @javax.annotation.Priority . The default value is 100. A lower priority value represents greater importance. The sections below for each interface tell which SPIs support @Priority . ",
            "title": "Introduction"
        },
        {
            "location": "/config/07_extensions",
            "text": " The config system includes built-in support for several types of sources (for example, Java String , Readable , Properties , and Map objects - see <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigSources.html\"> ConfigSources ). Implement a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigSource.html\"> ConfigSource to load raw configuration data from a type of source that the config system does not already support. ConfigSource SPI The interfaces ConfigNode , ObjectNode , ValueNode and ListNode represent the in-memory data structure for loaded and parsed configuration data. ",
            "title": "ConfigSource SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The parsing step converts config data in some format into the corresponding in-memory representation of config ObjectNode s. The config system can already parse several data formats (for example Java Properties , YAML, and HOCON). Implement the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigParser.html\"> ConfigParser SPI to allow the config system to handle additional formats. ConfigParser SPI The ConfigParser.Content interface defines operations on the content that is to to be parsed by a ConfigParser implementation: getStamp() - Returns a stamp (for example, a time stamp) that is different for different values of the content. getMediaType() - Reports the media type of the content. asReadable() - Provides a Readable and Autocloseable object from which the content can be read. The application can register parsers for a builder by invoking Config.Builder#addParser(ConfigParser) . The config system also uses the Java service loader mechanism to load automatically, for all builders, any parsers listed in the META-INF/services/io.helidon.config.spi.ConfigParser resource on the runtime classpath. Prevent autoloading of parsers for a given builder by invoking Config.Builder#disableParserServices() . ConfigParser accepts @Priority . See About Priority . <markup lang=\"java\" title=\"Example custom parser implementation listed in META-INF/services/io.helidon.config.spi.ConfigParser \" >myModule.MyConfigParser <markup lang=\"java\" title=\"Example custom parser definition in module-info.java \" >module myModule { requires transitive io.helidon.config; provides io.helidon.config.spi.ConfigParser with myModule.MyConfigParser; } ",
            "title": "ConfigParser SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " When the application retrieves a configuration value the config system first uses the relevant config sources and filters. It then applies any overrides the application has provided. Each override has: a Predicate&lt;Config.Key&gt; (a boolean-valued function that operates on the config key), and a replacement, overriding , String value the config system should use if the predicate evaluates to true. To furnish overrides to the config system, implement the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/OverrideSource.html\"> OverrideSource SPI one or more times and pass instances of those implementations to the config builder&#8217;s <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html#overrides-java.util.function.Supplier-\"> overrides method. The config system will apply the overrides returned from each OverrideSource to each config key requested from a Config that is based on that Config.Builder . OverrideSource SPI ",
            "title": "OverrideSource SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The ConfigFilter JavaDoc describes multiple methods for adding filters to a Config.Builder . Some accept a ConfigFilter directly and some accept a provider function which, when passed a Config instance, returns a ConfigFilter . Neither a ConfigFilter nor a provider function which furnishes one should access the Config instance passed to the provider function. Instead, implement the ConfigFilter.init(Config) method on the filter. The config system invokes the filters' init methods according to the filters' @Priority order. Recall that whenever any code invokes Config.get , the Config instance invokes the apply method of all registered filters. By the time the application retrieves config this way the config system will have run the init method on all the filters. But note that when a filter&#8217;s init method invokes Config.get , the init methods of lower-priority filters will not yet have run. ConfigFilter SPI ",
            "title": "Initializing Filters"
        },
        {
            "location": "/config/07_extensions",
            "text": " Before returning a String from Config.value() the config system applies any filters set up on the Config.Builder used to create the config tree that contains the config node of interest. The application provides filters as implementations of the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigFilter.html\"> ConfigFilter interface. Each filter is a function which accepts a Config.Key and an input String value and returns a String value the config system should use for that key going forward. The filter can return the original value or return some other value. The application registers filters and filter providers by passing ConfigFilter implementations to one of the config builder <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html\"> addFilter methods . The config system also uses the Java service loader mechanism to load additional filters automatically, for all builders, using the service interface described in the following table. Prevent a given builder from using the auto-loaded filters by invoking the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/Config.Builder.html#disableFilterServices--\"> disableFilterServices method. Config SPI Interfaces for Filtering Interface Method Usage <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigFilter.html\"> ConfigFilter Accepts @Priority . See About Priority . String apply(Config.Key key, String stringValue); Accepts a key and the corresponding String value and returns the String which the config system should use for that key. Initializing Filters The ConfigFilter JavaDoc describes multiple methods for adding filters to a Config.Builder . Some accept a ConfigFilter directly and some accept a provider function which, when passed a Config instance, returns a ConfigFilter . Neither a ConfigFilter nor a provider function which furnishes one should access the Config instance passed to the provider function. Instead, implement the ConfigFilter.init(Config) method on the filter. The config system invokes the filters' init methods according to the filters' @Priority order. Recall that whenever any code invokes Config.get , the Config instance invokes the apply method of all registered filters. By the time the application retrieves config this way the config system will have run the init method on all the filters. But note that when a filter&#8217;s init method invokes Config.get , the init methods of lower-priority filters will not yet have run. ConfigFilter SPI ",
            "title": "ConfigFilter SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The config system provides built-in mappings from String values to various Java types. (See <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/ConfigMappers.html\"> ConfigMappers .) To handle mappings to other types the application can register custom mappers with the config system by implementing the <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/ConfigMapperProvider.html\"> ConfigMapperProvider SPI. Such providers return a map, with entries in which: the key is the Java type (a Class object) the mapper produces, and the value is a ConfigMapper that converts the config in-memory data structure into the type in the key. The config system also uses the Java service loader mechanism to load automatically, for all builders, any mappers returned by the providers listed in the META-INF/services/io.helidon.config.spi.ConfigMapper resource on the runtime classpath. The application can prevent autoloading of mappers for a given builder by invoking Config.Builder#disableMapperServices() . Note that the build-in mappers described in ConfigMappers still operate. Mapper providers accept @Priority . See About Priority . ConfigMapperProvider SPI A mapper provider can specify a @javax.annotation.Priority . If no priority is explicitly assigned, the value of 100 is assumed. <markup lang=\"java\" title=\"Reference custom mapper provider implementation in META-INF/services/io.helidon.config.spi.ConfigMapperProvider \" >myModule.MyConfigMapperProvider <markup lang=\"java\" title=\"Reference custom mapper provider implementation in module-info.java \" >module myModule { requires transitive io.helidon.config; provides io.helidon.config.spi.ConfigMapperProvider with myModule.MyConfigMapperProvider; } ",
            "title": "ConfigMapperProvider SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " Once it loads a Config tree from ConfigSource s the config system does not itself change the in-memory Config tree. Even so, the underlying data available via the tree&#8217;s ConfigSource s can change. Implementations of <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/PollingStrategy.html\"> PollingStrategy informs other interested code when changes to that underlying data might have occurred. In implementations of PollingStrategy the #ticks() method returns a Flow.Publisher of PollingEvent s to which the application or the ConfigSource s themselves can subscribe. Generally, each event is a hint to the subscriber that it should check to see if any of the underlying config data it relies on has changed. Note that a PollingStrategy 's publication of an event does not necessarily guarantee that the underlying data has in fact changed, although this might be true for some PollingStrategy implementations. The config system offers polling strategies for periodic time-based checks and for a file watcher. Often an application can create a config source simply by using one of the methods on ConfigSources (for example, ConfigSources#file(path) to get a builder and then invoke pollingStrategy passing one of the predefined strategies. But the application can implement its own PollingStrategy and set it on the config source builder instead. PollingStrategy SPI The PollingStrategy ticks() method returns a Publisher of PollingEvent s. Each event becomes available as the particular PollingStrategy publishes it. Depending on the implementation of the polling strategy, such events might indicate that the underlying source data has changed or that it might have changed. In either case the subscribers to the publisher are notified. If the ConfigSource itself subscribes to the publisher, for example, then it might choose to reload the underlying data when its subscriber receives an event. ",
            "title": "PollingStrategy SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The builder for each ConfigSource and OverrideSource accepts a <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/spi/RetryPolicy.html\"> RetryPolicy governing if and how the source should deal with failures loading the underlying data. A retry policy accepts a function, the invocation of which the policy will govern according to its own implementation. Applications can use the predefined policies in <a id=\"\" title=\"\" target=\"_blank\" href=\"./apidocs/index.html?io/helidon/config/RetryPolicies.html\"> RetryPolicies , such as RetryPolicies.justCall which simply invokes the function without any retry. That class also exposes a builder for constructing a time-based retry policy, with several parameters: Parameters Controlling Built-in RetryPolicy Parameter Usage Default delay Initial delay between calls to the function 200 ms delayFactor Multiplier applied to delay on each successive call 2 callTimeout Time limit for each individual call of the function 500 ms overallTimeout Limit for the total elapsed time attempting to call the function successfully, including delays between calls 2 s The actual delay between function call starts as delay and changes by the factor delayFactor on each successive attempt. Note that the job of each retry policy is to call the provided function successfully. As such, the policy must perform the first attempt as well as any retries. RetryPolicy SPI The application can try to cancel the overall execution of a RetryPolicy by invoking the RetryPolicy#cancel(boolean mayInterruptIfRunning) method. Ideally the retry policy implementation should be able to abort the execution of the retry policy, even while a function call is in progress, but the policy must respond to cancels between function calls. In either case cancel returns true if the retry was aborted without a successful call to the function, and false otherwise, including if the function call had already completed successfully or had previously been successfully canceled. ",
            "title": "RetryPolicy SPI"
        },
        {
            "location": "/webserver/09_tracing-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"WebServer Zipkin Support Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/09_tracing-support",
            "text": " To enable Zipkin integration, configure Tracer on the ServerConfiguration.Builder . <markup lang=\"java\" title=\"Configuring OpenTracing Tracer \" >ServerConfiguration.builder() .tracer(new ZipkinTracerBuilder.forService(\"my-application\") .zipkin(\"http://10.0.0.18:9411\") .build()) .build() The name of the application to associate with the tracing events Zipkin endpoint for the tracing events ",
            "title": "Configuring Tracing Support"
        },
        {
            "location": "/webserver/09_tracing-support",
            "text": " The WebServer includes Zipkin support for OpenTracing. When enabled, the WebServer sends its tracing events to Zipkin. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" title=\"WebServer Zipkin Support Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; Configuring Tracing Support To enable Zipkin integration, configure Tracer on the ServerConfiguration.Builder . <markup lang=\"java\" title=\"Configuring OpenTracing Tracer \" >ServerConfiguration.builder() .tracer(new ZipkinTracerBuilder.forService(\"my-application\") .zipkin(\"http://10.0.0.18:9411\") .build()) .build() The name of the application to associate with the tracing events Zipkin endpoint for the tracing events ",
            "title": "Tracing Support"
        }
 ]
}