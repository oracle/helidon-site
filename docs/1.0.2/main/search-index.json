{
    "docs": [
        {
            "location": "/webserver/04_request-handling",
            "text": " Each Handler has two parameters. ServerRequest and ServerResponse . Request provides access to the request method, URI, path, query parameters, headers and entity. Response provides an ability to set response code, headers, and entity. ",
            "title": "Process Request and Produce Response"
        },
        {
            "location": "/webserver/04_request-handling",
            "text": " The handler forwards the request to the downstream handlers by nexting . There are two options: call req.next() <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic req.next(); }) handler for any HTTP method using the /hello path business logic implementation forward the current request to the downstream handler call req.next(throwable) to forward the handling to the error handlers <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic (e.g., validating parameters) if (userParametersOk()) { req.next(); } else { req.next(new IllegalArgumentException(\"Invalid parameters.\"); } }) handler for any HTTP method using the /hello path custom logic forward the current request to the downstream handler forward the request to the error handler The handling logic can explicitly forward the execution to a different thread. This is the reason why returning from the handler can&#8217;t automatically trigger calling the next handler. ",
            "title": "Handler as a Filter"
        },
        {
            "location": "/webserver/04_request-handling",
            "text": " To complete the request handling, you must send a response by calling the res.send() method. <markup lang=\"java\" >.get(\"/hello\", (req, res) -&gt; { // terminating logic res.status(Http.Status.ACCEPTED_201); res.send(\"Saved!\"); }) handler that terminates the request handling for any HTTP method using the /hello path send the response ",
            "title": "Sending a response"
        },
        {
            "location": "/webserver/04_request-handling",
            "text": " Implement the logic to handle requests to WebServer in a Handler , which is a FunctionalInterface . Handlers: Process the request and send a response. Act as a filter and forward requests to downstream handlers using the request.next() method. Throw an exception or call request.next(exception) to begin error handling . Process Request and Produce Response Each Handler has two parameters. ServerRequest and ServerResponse . Request provides access to the request method, URI, path, query parameters, headers and entity. Response provides an ability to set response code, headers, and entity. Handler as a Filter The handler forwards the request to the downstream handlers by nexting . There are two options: call req.next() <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic req.next(); }) handler for any HTTP method using the /hello path business logic implementation forward the current request to the downstream handler call req.next(throwable) to forward the handling to the error handlers <markup lang=\"java\" >.any(\"/hello\", (req, res) -&gt; { // filtering logic (e.g., validating parameters) if (userParametersOk()) { req.next(); } else { req.next(new IllegalArgumentException(\"Invalid parameters.\"); } }) handler for any HTTP method using the /hello path custom logic forward the current request to the downstream handler forward the request to the error handler The handling logic can explicitly forward the execution to a different thread. This is the reason why returning from the handler can&#8217;t automatically trigger calling the next handler. Sending a response To complete the request handling, you must send a response by calling the res.send() method. <markup lang=\"java\" >.get(\"/hello\", (req, res) -&gt; { // terminating logic res.status(Http.Status.ACCEPTED_201); res.send(\"Saved!\"); }) handler that terminates the request handling for any HTTP method using the /hello path send the response ",
            "title": "Request Handling"
        },
        {
            "location": "/health/01_health",
            "text": " This document describes the health check API available with Helidon SE. ",
            "title": "preambule"
        },
        {
            "location": "/health/01_health",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.health&lt;/groupId&gt; &lt;artifactId&gt;helidon-health&lt;/artifactId&gt; &lt;/dependency&gt; <markup lang=\"xml\" title=\"Optional dependency to use built-in health checks:\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.health&lt;/groupId&gt; &lt;artifactId&gt;helidon-health-checks&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/health/01_health",
            "text": " It’s a good practice to monitor your microservice’s health, to ensure that it is available and performs correctly. Applications implement health checks to expose health status that is collected at regular intervals by external tooling, such as orchestrators like Kubernetes. The orchestrator may then take action, such as restarting your application if the health check fails. A typical health check combines the statuses of all the dependencies that affect availability and the ability to perform correctly: network latency storage database other services used by your application Prerequisites Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.health&lt;/groupId&gt; &lt;artifactId&gt;helidon-health&lt;/artifactId&gt; &lt;/dependency&gt; <markup lang=\"xml\" title=\"Optional dependency to use built-in health checks:\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.health&lt;/groupId&gt; &lt;artifactId&gt;helidon-health-checks&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "About health checks"
        },
        {
            "location": "/health/01_health",
            "text": "<markup lang=\"java\" title=\"Register a custom health check:\" >HealthSupport health = HealthSupport.builder() .add(() -&gt; HealthCheckResponse.named(\"exampleHealthCheck\") .up() .withData(\"time\", System.currentTimeMillis()) .build()) .build(); Routing.builder() .register(JsonSupport.create()) .register(health) .build(); Add a custom health check. This example returns UP and current time. Enable support for JSON . Register health support with web server routing (adds the /health endpoint). Balance collecting a lot of information with the need to avoid overloading the application and overwhelming users. <markup lang=\"json\" title=\"JSON response:\" >{ \"outcome\": \"UP\", \"checks\": [ { \"name\": \"exampleHealthCheck\", \"state\": \"UP\", \"data\": { \"time\": 1546958376613 } } ] } ",
            "title": "Example"
        },
        {
            "location": "/health/01_health",
            "text": " A set of built-in health checks can be optionally enabled to report various health check statuses that are commonly used: deadlock detection available disk space available heap memory <markup lang=\"java\" >HealthSupport health = HealthSupport.builder() .add(HealthChecks.healthChecks()) .build(); Routing.builder() .register(JsonSupport.create()) .register(health) .build(); Add built-in health checks (requires the helidon-health-checks dependency). Register the JSON-P support in the WebServer routing. Register the created health support with web server routing (adds the /health endpoint). <markup lang=\"json\" title=\"JSON response.\" >{ \"outcome\": \"UP\", \"checks\": [ { \"name\": \"deadlock\", \"state\": \"UP\" }, { \"name\": \"diskSpace\", \"state\": \"UP\", \"data\": { \"free\": \"211.00 GB\", \"freeBytes\": 226563444736, \"percentFree\": \"45.31%\", \"total\": \"465.72 GB\", \"totalBytes\": 500068036608 } }, { \"name\": \"heapMemory\", \"state\": \"UP\", \"data\": { \"free\": \"215.15 MB\", \"freeBytes\": 225600496, \"max\": \"3.56 GB\", \"maxBytes\": 3817865216, \"percentFree\": \"99.17%\", \"total\": \"245.50 MB\", \"totalBytes\": 257425408 } } ] } ",
            "title": "Built-in health-checks"
        },
        {
            "location": "/health/01_health",
            "text": " Health check API classes org.eclipse.microprofile.health.HealthCheck Java functional interface representing the logic of a single health check org.eclipse.microprofile.health.HealthCheckResponse Result of a health check invocation that contains a state and a description. org.eclipse.microprofile.health.HealthCheckResponseBuilder Builder class to create HealthCheckResponse instances io.helidon.health.HealthSupport WebServer service that exposes /health and invokes the registered health checks io.helidon.health.HealthSupport.Builder Builder class to create HealthSupport instances A health check is a Java functional interface that returns a HealthCheckResponse object. You can choose to implement a health check inline with a lambda expression or you can reference a method with the double colon operator :: . <markup lang=\"java\" title=\"Health check with a lambda expression:\" >HealthCheck hc = () -&gt; HealthCheckResponse .named(\"exampleHealthCheck\") .up() .build(); <markup lang=\"java\" title=\"Health check with method reference:\" >HealthCheckResponse exampleHealthCheck(){ return HealthCheckResponse .named(\"exampleHealthCheck\") .up() .build(); } HealthCheck hc = this::exampleHealthCheck; HealthSupport is a WebServer service that contains a collection of registered HealthCheck instances. When queried, it invokes the registered health check and returns a response with a status code representing the overall state of the application. Health status codes <div class=\"table__overflow elevation-1 flex sm7 \"> 200 The application is healthy. 503 The application is not healthy. 500 An error occurred while reporting the health. The HTTP response also contains a JSON payload that describes the statuses for all health checks. <markup lang=\"java\" title=\"Create the health support service:\" >HealthSupport health = HealthSupport.builder() .add(hc) .build(); Health check requires the JSON-P support to be enabled. See the example below. Example <markup lang=\"java\" title=\"Register a custom health check:\" >HealthSupport health = HealthSupport.builder() .add(() -&gt; HealthCheckResponse.named(\"exampleHealthCheck\") .up() .withData(\"time\", System.currentTimeMillis()) .build()) .build(); Routing.builder() .register(JsonSupport.create()) .register(health) .build(); Add a custom health check. This example returns UP and current time. Enable support for JSON . Register health support with web server routing (adds the /health endpoint). Balance collecting a lot of information with the need to avoid overloading the application and overwhelming users. <markup lang=\"json\" title=\"JSON response:\" >{ \"outcome\": \"UP\", \"checks\": [ { \"name\": \"exampleHealthCheck\", \"state\": \"UP\", \"data\": { \"time\": 1546958376613 } } ] } Built-in health-checks A set of built-in health checks can be optionally enabled to report various health check statuses that are commonly used: deadlock detection available disk space available heap memory <markup lang=\"java\" >HealthSupport health = HealthSupport.builder() .add(HealthChecks.healthChecks()) .build(); Routing.builder() .register(JsonSupport.create()) .register(health) .build(); Add built-in health checks (requires the helidon-health-checks dependency). Register the JSON-P support in the WebServer routing. Register the created health support with web server routing (adds the /health endpoint). <markup lang=\"json\" title=\"JSON response.\" >{ \"outcome\": \"UP\", \"checks\": [ { \"name\": \"deadlock\", \"state\": \"UP\" }, { \"name\": \"diskSpace\", \"state\": \"UP\", \"data\": { \"free\": \"211.00 GB\", \"freeBytes\": 226563444736, \"percentFree\": \"45.31%\", \"total\": \"465.72 GB\", \"totalBytes\": 500068036608 } }, { \"name\": \"heapMemory\", \"state\": \"UP\", \"data\": { \"free\": \"215.15 MB\", \"freeBytes\": 225600496, \"max\": \"3.56 GB\", \"maxBytes\": 3817865216, \"percentFree\": \"99.17%\", \"total\": \"245.50 MB\", \"totalBytes\": 257425408 } } ] } ",
            "title": "API overview"
        },
        {
            "location": "/microprofile/02_server-configuration",
            "text": " By default, the server uses the MicroProfile Config, but you may also want to use Helidon configuration. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/02_server-configuration",
            "text": " There are 3 default MicroProfile Config sources: System.getProperties() System.getenv() all META-INF/microprofile-config.properties files on the class path In this example, the configuration is in a file, and it includes Helidon configuration options. <markup lang=\"properties\" title=\"META-INF/microprofile-config.properties - Server configuration\" ># default is localhost server.host=some.host # default is 7001 server.port=7011 # Helidon configuration (optional) # Length of queue for incoming connections. Default is 1024 server.backlog: 512 # TCP receive window. Default is 0 to use implementation default server.receive-buffer: 256 # Socket timeout milliseconds - defaults to 0 (infinite) server.timeout: 30000 # Default is CPU_COUNT * 2 server.workers=4 # Default is not to use SSL ssl: private-key: keystore-resource-path: \"certificate.p12\" keystore-passphrase: \"abcd\" For Helidon config, the default file is application.yaml on the classpath (e.g. src/main/resources/application.yaml). <markup lang=\"yaml\" title=\"application.yaml - Server configuration\" >server: sockets: - secure: port: 443 # supports all socket related properties of server backlog: 1024 receive-buffer: 0 timeout: 60000 ssl: .... - another: port: 12041 ",
            "title": "Configuring the Server"
        },
        {
            "location": "/about/04_managing-dependencies",
            "text": " Helidon provides a &#8220;Bill Of Materials&#8221; (BOM) to manage dependencies. This is a special Maven pom file that provides dependency management. Using the Helidon BOM allows you to use Helidon component dependencies with a single version: the Helidon version. ",
            "title": "preambule"
        },
        {
            "location": "/about/04_managing-dependencies",
            "text": " Add the following snippet to your pom.xml file in order to import the Helidon BOM. <markup lang=\"xml\" title=\"Import the Helidon BOM\" >&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon&lt;/groupId&gt; &lt;artifactId&gt;helidon-bom&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; ",
            "title": "The Helidon BOM POM"
        },
        {
            "location": "/about/04_managing-dependencies",
            "text": " Once you have imported the BOM, you can declare dependencies on Helidon components without specifying a version. <markup lang=\"xml\" title=\"Component dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Using Helidon Component Dependencies"
        },
        {
            "location": "/config/01_introduction",
            "text": " The config component provides a Java API to load and process configuration properties in key/value form into a Config object which the application can use to retrieve config data. ",
            "title": "preambule"
        },
        {
            "location": "/config/01_introduction",
            "text": " A brief overview of the config system helps clarify its different parts and how they work together. Most applications will typically deal with more than one of these parts. The system reads configuration from a config source , a physical location (such as a file, a URL, or a String ) which holds config data. Each config source works with a config parser which translates a particular text format (for example, Java properties or YAML) into an in-memory tree which represents the configuration&#8217;s structure and values. An optional polling strategy detects and publishes changes to the underlying config source so the config source itself or your application can respond. Your application uses the Config object which results from building that in-memory tree to retrieve config data. The app can navigate explicitly among the nodes in the tree and fetch a node&#8217;s value <markup lang=\"java\" >int pageSize = config .get(\"web\") .get(\"page-size\") .asInt() .orElse(20); or it can address a node in the tree using the config key&#8217;s dotted name <markup lang=\"java\" >int pageSize = config .get(\"web.page-size\") .asInt() .orElse(20); As part of retrieving a value from a node, the config system applies config filters which can change what values are returned for selected keys. The Config object lets your application retrieve config data as a typed ConfigValue. ConfigValue&lt;T&gt; can be used to obtain: * an Optional&lt;T&gt; value from a single node , * the T value from a single node interpreted as a basic Java type (primitive or simple object) already known to the config system (such as a boolean or a Double ), or * a complex Java type from a subtree of the config tree. + The config system automatically knows how to return List and Map complex types, and you can provide config mappers to convert a config subtree to whatever Java types your application needs. ",
            "title": "Introducing the Config System"
        },
        {
            "location": "/config/01_introduction",
            "text": "<markup lang=\"xml\" title=\"Config Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config&lt;/artifactId&gt; &lt;version&gt;version-of-config-you-are-using&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ",
            "title": "Add Maven Dependency on Config"
        },
        {
            "location": "/config/01_introduction",
            "text": " If you are using Java 9 then create or update the module-info.java file for your application: <markup lang=\"java\" title=\"Config Dependency in module-info.java \" >module myModule { requires io.helidon.config; } ",
            "title": "Update module-info.java "
        },
        {
            "location": "/config/01_introduction",
            "text": "<markup title=\"Example src/main/resources/application.properties config file\" >greeting = Hello web.debug = true web.page-size = 20 web.ratio = 1.3 bl.initial-id = 10000000000 origin = props java.home=homeFromProps # will be ignored ",
            "title": "Create simple Config Properties File"
        },
        {
            "location": "/config/01_introduction",
            "text": " The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. ",
            "title": "Config Sources for the Default Config"
        },
        {
            "location": "/config/01_introduction",
            "text": " If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format http://yaml.org application.conf helidon-config-hocon HOCON format https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hocon JSON format https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Built-in Support for Config Formats"
        },
        {
            "location": "/config/01_introduction",
            "text": "<markup lang=\"java\" title=\"Create and Use Default Config from Java\" >import io.helidon.config.Config; ... Config config = Config.create(); System.out.println(String.format( \"greeting is %s\" + \"web.debug is %b\" + \"web.page-size is %d\" + \"web.ratio is %f\" + \"bl.initial-id is %d\" + \"origin is %s\" + \"java.home is %s\", config.get(\"greeting\").asString().orElse(\"Default greeting\"), config.get(\"web.debug\").asBoolean().orElse(false), config.get(\"web.page-size\").asInt().orElse(50), config.get(\"web.ratio\").asDouble().orElse(2.0), config.get(\"bl.initial-id\").asLong().orElse(1L), config.get(\"origin\").asString().orElse(\"defaults\"), config.get(\"java.home\").asString().get())); Import Config . Create the root of the Config tree from the default sources. Retrieve various values by their dotted names and decode them as the appropriate Java types, providing default values if the property is missing. Retrieve the value (and fail with a runtime exception if missing) When you build and run your project, the output will look like this: <markup >greeting is Hello web.debug is true web.page-size is 20 web.ratio is 1.300000 bl.initial-id is 10000000000 origin is props java.home is /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home Config Sources for the Default Config The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. Built-in Support for Config Formats If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format http://yaml.org application.conf helidon-config-hocon HOCON format https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hocon JSON format https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Write Code using the Default Config"
        },
        {
            "location": "/config/01_introduction",
            "text": " An easy way to start with the Config API is to follow these four steps: add config-related dependencies to your pom.xml revise your module-info.java to refer to config (if you are using Java 9) create a simple config properties file retrieve and use the default Config from your app Add Maven Dependency on Config <markup lang=\"xml\" title=\"Config Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config&lt;/artifactId&gt; &lt;version&gt;version-of-config-you-are-using&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Update module-info.java If you are using Java 9 then create or update the module-info.java file for your application: <markup lang=\"java\" title=\"Config Dependency in module-info.java \" >module myModule { requires io.helidon.config; } Create simple Config Properties File <markup title=\"Example src/main/resources/application.properties config file\" >greeting = Hello web.debug = true web.page-size = 20 web.ratio = 1.3 bl.initial-id = 10000000000 origin = props java.home=homeFromProps # will be ignored Write Code using the Default Config <markup lang=\"java\" title=\"Create and Use Default Config from Java\" >import io.helidon.config.Config; ... Config config = Config.create(); System.out.println(String.format( \"greeting is %s\" + \"web.debug is %b\" + \"web.page-size is %d\" + \"web.ratio is %f\" + \"bl.initial-id is %d\" + \"origin is %s\" + \"java.home is %s\", config.get(\"greeting\").asString().orElse(\"Default greeting\"), config.get(\"web.debug\").asBoolean().orElse(false), config.get(\"web.page-size\").asInt().orElse(50), config.get(\"web.ratio\").asDouble().orElse(2.0), config.get(\"bl.initial-id\").asLong().orElse(1L), config.get(\"origin\").asString().orElse(\"defaults\"), config.get(\"java.home\").asString().get())); Import Config . Create the root of the Config tree from the default sources. Retrieve various values by their dotted names and decode them as the appropriate Java types, providing default values if the property is missing. Retrieve the value (and fail with a runtime exception if missing) When you build and run your project, the output will look like this: <markup >greeting is Hello web.debug is true web.page-size is 20 web.ratio is 1.300000 bl.initial-id is 10000000000 origin is props java.home is /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home Config Sources for the Default Config The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. Built-in Support for Config Formats If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format http://yaml.org application.conf helidon-config-hocon HOCON format https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hocon JSON format https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Your First Config Application"
        },
        {
            "location": "/config/01_introduction",
            "text": " Introducing the Config System A brief overview of the config system helps clarify its different parts and how they work together. Most applications will typically deal with more than one of these parts. The system reads configuration from a config source , a physical location (such as a file, a URL, or a String ) which holds config data. Each config source works with a config parser which translates a particular text format (for example, Java properties or YAML) into an in-memory tree which represents the configuration&#8217;s structure and values. An optional polling strategy detects and publishes changes to the underlying config source so the config source itself or your application can respond. Your application uses the Config object which results from building that in-memory tree to retrieve config data. The app can navigate explicitly among the nodes in the tree and fetch a node&#8217;s value <markup lang=\"java\" >int pageSize = config .get(\"web\") .get(\"page-size\") .asInt() .orElse(20); or it can address a node in the tree using the config key&#8217;s dotted name <markup lang=\"java\" >int pageSize = config .get(\"web.page-size\") .asInt() .orElse(20); As part of retrieving a value from a node, the config system applies config filters which can change what values are returned for selected keys. The Config object lets your application retrieve config data as a typed ConfigValue. ConfigValue&lt;T&gt; can be used to obtain: * an Optional&lt;T&gt; value from a single node , * the T value from a single node interpreted as a basic Java type (primitive or simple object) already known to the config system (such as a boolean or a Double ), or * a complex Java type from a subtree of the config tree. + The config system automatically knows how to return List and Map complex types, and you can provide config mappers to convert a config subtree to whatever Java types your application needs. Your First Config Application An easy way to start with the Config API is to follow these four steps: add config-related dependencies to your pom.xml revise your module-info.java to refer to config (if you are using Java 9) create a simple config properties file retrieve and use the default Config from your app Add Maven Dependency on Config <markup lang=\"xml\" title=\"Config Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config&lt;/artifactId&gt; &lt;version&gt;version-of-config-you-are-using&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Update module-info.java If you are using Java 9 then create or update the module-info.java file for your application: <markup lang=\"java\" title=\"Config Dependency in module-info.java \" >module myModule { requires io.helidon.config; } Create simple Config Properties File <markup title=\"Example src/main/resources/application.properties config file\" >greeting = Hello web.debug = true web.page-size = 20 web.ratio = 1.3 bl.initial-id = 10000000000 origin = props java.home=homeFromProps # will be ignored Write Code using the Default Config <markup lang=\"java\" title=\"Create and Use Default Config from Java\" >import io.helidon.config.Config; ... Config config = Config.create(); System.out.println(String.format( \"greeting is %s\" + \"web.debug is %b\" + \"web.page-size is %d\" + \"web.ratio is %f\" + \"bl.initial-id is %d\" + \"origin is %s\" + \"java.home is %s\", config.get(\"greeting\").asString().orElse(\"Default greeting\"), config.get(\"web.debug\").asBoolean().orElse(false), config.get(\"web.page-size\").asInt().orElse(50), config.get(\"web.ratio\").asDouble().orElse(2.0), config.get(\"bl.initial-id\").asLong().orElse(1L), config.get(\"origin\").asString().orElse(\"defaults\"), config.get(\"java.home\").asString().get())); Import Config . Create the root of the Config tree from the default sources. Retrieve various values by their dotted names and decode them as the appropriate Java types, providing default values if the property is missing. Retrieve the value (and fail with a runtime exception if missing) When you build and run your project, the output will look like this: <markup >greeting is Hello web.debug is true web.page-size is 20 web.ratio is 1.300000 bl.initial-id is 10000000000 origin is props java.home is /Library/Java/JavaVirtualMachines/jdk-10.0.1.jdk/Contents/Home Config Sources for the Default Config The default config uses the following config sources, listed here from most to least important: Java system properties Environment variables application.properties , if on the classpath. The priority (most to least important) means that if a given config key appears in more than one source, the value assigned in a more important source overrules the value from a less important source. Verify this by noting that the program has displayed your actual java.home which Java set as a system property, not the value set in the example application.properties file. Built-in Support for Config Formats If you add additional Helidon config maven artifacts to your dependencies, then the config system can read formats other than Java properties format and the default configuration will search for other application file types in the following order. Note that the default configuration stops once it finds one of the files below; it does not merge all such files it can find. Default Config Files (most to least important) Source Helidon maven artifact ID (group ID: io.helidon.config ) Notes application.yaml helidon-config-yaml YAML format http://yaml.org application.conf helidon-config-hocon HOCON format https://github.com/lightbend/config#using-hocon-the-json-superset application.json helidon-config-hocon JSON format https://json.org/ application.properties helidon-config Java properties format ",
            "title": "Getting Started"
        },
        {
            "location": "/config/01_introduction",
            "text": " Although the default configuration is very simple to use, your application can take as much control as it needs over loading configuration data, accessing the data once loaded, and extending and modifying the behavior of the config system. You do this by: creating and invoking methods on a Config.Builder object to construct a Config instance Using a builder, the application can control everything about how the config system creates the resulting Config instance: config sources, parsers, polling strategy, filters, overrides, mappers, whether or not environment variables and Java system properties serve as config sources. The JavaDoc explains how to use the Config.Builder . or creating a meta-configuration file on the runtime classpath to control how the config system prepares the default configuration. Once created, the Config object provides many methods the application can use to retrieve config data as various Java types. See the Config JavaDoc for complete details. The links in the following tables lead you to more information about various other config topics. Controlling How Config is Loaded Topic Documentation Where config comes from Config sources , meta-configuration What format config data is expressed in Config parsers , supported formats How to filter, override, and dereference values Filters and overrides What happens when config data changes Config polling How to deal with loading errors Config retry policies Accessing Configuration Data Topic Documentation How config data is translated into Java types Config mappers How to navigate config trees Navigation Extending and Fine-tuning the Config System Topic Documentation Writing extensions Extensions ",
            "title": "Next Steps"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Although config values are originally text, you can use the config system&#8217;s built-in conversions or add your own to translate text into Java primitive types and simple objects (such as Double ) and to express parts of the config tree as complex types ( List , Map , and custom types specific to your application). This section introduces how to use the built-in mappings and your own custom ones to convert to simple and complext types. ",
            "title": "preambule"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The Config class itself provides many conversions to Java types. See the JavaDoc for the complete list. The methods which support Java primitive types and their related classes follow a common pattern. The examples in the table below deal with conversion to a boolean but the same pattern applies to many data types listed in the JavaDoc. Assume a local variable has been assigned something like <markup lang=\"java\" >Config config = Config.get(\"someKey\"); // shortcut method ConfigValue&lt;Boolean&gt; value = config.asBoolean(); // generic method (for any type) ConfigValue&lt;Boolean&gt; value2 = config.as(Boolean.class); Built-in Conversions to Simple Types (e.g., boolean) Java type Example usage 1 boolean boolean b = value.get(); 2 boolean defaultedB = value.orElse(true); 3 Optional&lt;Boolean&gt; ConfigValue already has all methods of an Optional. If actual optional is needed: Optional&lt;Boolean&gt; b = value.asOptional(); 4 Supplier&lt;Boolean&gt; Boolean b = value.supplier().get(); boolean defaultedB = value.supplier(true).get(); Supplier&lt;Optional&lt;Boolean&gt;&gt; Boolean b = value.optionalSupplier().get().orElse(Boolean.TRUE); Notes on Built-in Conversions to Simple Types 1 All conversions can throw MissingValueException (if no value exists at the requested key and no default is provided) and ConfigMappingException (if some error occurred while performing the data mapping). 2 The Config.asXXX methods internally use the Java-provided XXX.parseXXX methods, so here a missing or unparseable string gives false because that is how Boolean.parseBoolean behaves. 3 User code defaults the value to true . 4 User code defaults the value to Boolean.TRUE if absent; otherwise parses the value using Boolean.parseBoolean . The numerous conversions defined on the Config class for other types (integers, doubles, etc.) will satisfy many of your application&#8217;s needs. The ConfigMappers class includes other related mappings from String (rather than from Config ) to Java types (described in the JavaDoc). For additional type mapping, you can use these methods defined on Config : <markup lang=\"java\" >T as(Class&lt;? extends T&gt; type); T as(Function&lt;Config, T&gt; mapper); T as(GenericType&lt;T&gt; genericType); which maps the current node to a type. The next example, and later ones below showing complex type mapping, use the example application.properties configuration from the config introduction. Part of that example includes this line: <markup >bl.initial-id = 10000000000 Your application can use Config.as to interpret the value as a BigDecimal : <markup lang=\"java\" >BigDecimal initialId = config.get(\"bl.initial-id\").as(BigDecimal.class); ",
            "title": "Converting Configuration to Simple Types"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The Config class exposes several methods for mapping a structured config node to a Java List or Map . The JavaDoc contains complete details, but briefly your application can convert a structured Config node into: a List&lt;T&gt; of a given type, a Map&lt;String, String&gt; in which each key is the fully-qualified key String for a config entry and the value is its String value, or ",
            "title": "Built-in Conversions to List and Map "
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Any time your application has a Config instance to map to the target class it invokes Config.as passing an instance of the corresponding conversion function: <markup lang=\"java\" >Config config = Config.get(\"web\"); ConfigValue&lt;WebConfig&gt; web = config.as(WebConfigMapper::map); You do not necessarily need a new instance of the mapper every time you want to use it. In this approach, everywhere your application needs to perform this conversion it specifies the mapper to use. If you decided to change which mapper to use you would need to update each of those places in your application. ",
            "title": "Use Custom Mapper Explicitly: Config.as method"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " In this approach, your application: Tells each Config.Builder that needs to know about the custom mapper by either: registering an instance of your mapper by invoking Config.Builder.addMapper , or implementing ConfigMapperProvider so it returns an instance of your mapper (see the JavaDoc for complete information) and creating or editing the file io.helidon.config.spi.ConfigMapperProvider so it contains a line with the fully-qualified class name of your ConfigMapperProvider . The config system will use the Java service loader to find and invoke all ConfigMapperProvider classes listed and add the mappers they provide to each Config.Builder automatically. Converts using the mapper by invoking the Config.as method which accepts the target type to convert to, not the mapper itself that does the conversion. If your application converts to the same target type in several places in the code, this approach allows you to change which mapper it uses by changing only the registration of the mapper, not each use of it. ",
            "title": "Register Custom Mapper Once, Use Implicitly: Config.as method"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The following examples build on the example configuration from the application.properties example file in the introduction. <markup lang=\"java\" title=\"Java POJO to Hold web Properties Config\" >public class WebConfig { private boolean debug; private int pageSize; private double ratio; public WebConfig(boolean debug, int pageSize, double ratio) { this.debug = debug; this.pageSize = pageSize; this.ratio = ratio; } public boolean isDebug() { return debug; } public int getPageSize() { return pageSize; } public double getRatio() { return ratio; } } <markup lang=\"java\" title=\"Custom Mapper Class\" >public class WebConfigMapper implements Function&lt;Config, WebConfig&gt; { @Override public WebConfig apply(Config config) throws ConfigMappingException, MissingValueException { return new WebConfig( config.get(\"debug\").asBoolean().orElse(false), config.get(\"page-size\").asInt().orElse(10), config.get(\"ratio\").asDouble().orElse(1.0) ); } } <markup lang=\"java\" title=\"Explicitly Using the Mapper\" >... Config config = Config.create(classpath(\"application.properties\")); WebConfig web = config.get(\"web\") .as(new WebConfigMapper()) .get(); <markup lang=\"java\" title=\"Registering and Implicitly Using the Mapper\" >... Config config = Config.builder(classpath(\"application.properties\")) .addMapper(WebConfig.class, new WebConfigMapper()) .build(); WebConfig web = config.get(\"web\") .as(WebConfig.class) .get(); Either of the two approaches just described will always work without requiring you to change the POJO class. ",
            "title": "Continuing the Web Example"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Often your code will be simpler if you can treat parts of the configuration as custom, application-specific Java objects, rather than as a group of String keys and values. You will need customized conversions to do so. The config system provides many ways to accomplish this, described in the io.helidon.config package JavaDoc . Some of those approaches require that the target class&#8201;&#8212;&#8201;the class to which you want to convert the configuration data&#8201;&#8212;&#8201;have certain characteristics or that you add a method to the class to help do the mapping. You might want to avoid changing the target class or you might not even be able to if you do not control its source. Here are two approaches that will always work without requiring changes to the target class. For both approaches, you write your own conversion function. The difference is in how your application triggers the use of that mapper. Use Custom Mapper Explicitly: Config.as method Any time your application has a Config instance to map to the target class it invokes Config.as passing an instance of the corresponding conversion function: <markup lang=\"java\" >Config config = Config.get(\"web\"); ConfigValue&lt;WebConfig&gt; web = config.as(WebConfigMapper::map); You do not necessarily need a new instance of the mapper every time you want to use it. In this approach, everywhere your application needs to perform this conversion it specifies the mapper to use. If you decided to change which mapper to use you would need to update each of those places in your application. Register Custom Mapper Once, Use Implicitly: Config.as method In this approach, your application: Tells each Config.Builder that needs to know about the custom mapper by either: registering an instance of your mapper by invoking Config.Builder.addMapper , or implementing ConfigMapperProvider so it returns an instance of your mapper (see the JavaDoc for complete information) and creating or editing the file io.helidon.config.spi.ConfigMapperProvider so it contains a line with the fully-qualified class name of your ConfigMapperProvider . The config system will use the Java service loader to find and invoke all ConfigMapperProvider classes listed and add the mappers they provide to each Config.Builder automatically. Converts using the mapper by invoking the Config.as method which accepts the target type to convert to, not the mapper itself that does the conversion. If your application converts to the same target type in several places in the code, this approach allows you to change which mapper it uses by changing only the registration of the mapper, not each use of it. Continuing the Web Example The following examples build on the example configuration from the application.properties example file in the introduction. <markup lang=\"java\" title=\"Java POJO to Hold web Properties Config\" >public class WebConfig { private boolean debug; private int pageSize; private double ratio; public WebConfig(boolean debug, int pageSize, double ratio) { this.debug = debug; this.pageSize = pageSize; this.ratio = ratio; } public boolean isDebug() { return debug; } public int getPageSize() { return pageSize; } public double getRatio() { return ratio; } } <markup lang=\"java\" title=\"Custom Mapper Class\" >public class WebConfigMapper implements Function&lt;Config, WebConfig&gt; { @Override public WebConfig apply(Config config) throws ConfigMappingException, MissingValueException { return new WebConfig( config.get(\"debug\").asBoolean().orElse(false), config.get(\"page-size\").asInt().orElse(10), config.get(\"ratio\").asDouble().orElse(1.0) ); } } <markup lang=\"java\" title=\"Explicitly Using the Mapper\" >... Config config = Config.create(classpath(\"application.properties\")); WebConfig web = config.get(\"web\") .as(new WebConfigMapper()) .get(); <markup lang=\"java\" title=\"Registering and Implicitly Using the Mapper\" >... Config config = Config.builder(classpath(\"application.properties\")) .addMapper(WebConfig.class, new WebConfigMapper()) .build(); WebConfig web = config.get(\"web\") .as(WebConfig.class) .get(); Either of the two approaches just described will always work without requiring you to change the POJO class. ",
            "title": "Custom Conversions"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The hierarchical features section describes the tree structure used to represent config data. The config system can map subtrees of a config tree to complex Java types. Built-in Conversions to List and Map The Config class exposes several methods for mapping a structured config node to a Java List or Map . The JavaDoc contains complete details, but briefly your application can convert a structured Config node into: a List&lt;T&gt; of a given type, a Map&lt;String, String&gt; in which each key is the fully-qualified key String for a config entry and the value is its String value, or Custom Conversions Often your code will be simpler if you can treat parts of the configuration as custom, application-specific Java objects, rather than as a group of String keys and values. You will need customized conversions to do so. The config system provides many ways to accomplish this, described in the io.helidon.config package JavaDoc . Some of those approaches require that the target class&#8201;&#8212;&#8201;the class to which you want to convert the configuration data&#8201;&#8212;&#8201;have certain characteristics or that you add a method to the class to help do the mapping. You might want to avoid changing the target class or you might not even be able to if you do not control its source. Here are two approaches that will always work without requiring changes to the target class. For both approaches, you write your own conversion function. The difference is in how your application triggers the use of that mapper. Use Custom Mapper Explicitly: Config.as method Any time your application has a Config instance to map to the target class it invokes Config.as passing an instance of the corresponding conversion function: <markup lang=\"java\" >Config config = Config.get(\"web\"); ConfigValue&lt;WebConfig&gt; web = config.as(WebConfigMapper::map); You do not necessarily need a new instance of the mapper every time you want to use it. In this approach, everywhere your application needs to perform this conversion it specifies the mapper to use. If you decided to change which mapper to use you would need to update each of those places in your application. Register Custom Mapper Once, Use Implicitly: Config.as method In this approach, your application: Tells each Config.Builder that needs to know about the custom mapper by either: registering an instance of your mapper by invoking Config.Builder.addMapper , or implementing ConfigMapperProvider so it returns an instance of your mapper (see the JavaDoc for complete information) and creating or editing the file io.helidon.config.spi.ConfigMapperProvider so it contains a line with the fully-qualified class name of your ConfigMapperProvider . The config system will use the Java service loader to find and invoke all ConfigMapperProvider classes listed and add the mappers they provide to each Config.Builder automatically. Converts using the mapper by invoking the Config.as method which accepts the target type to convert to, not the mapper itself that does the conversion. If your application converts to the same target type in several places in the code, this approach allows you to change which mapper it uses by changing only the registration of the mapper, not each use of it. Continuing the Web Example The following examples build on the example configuration from the application.properties example file in the introduction. <markup lang=\"java\" title=\"Java POJO to Hold web Properties Config\" >public class WebConfig { private boolean debug; private int pageSize; private double ratio; public WebConfig(boolean debug, int pageSize, double ratio) { this.debug = debug; this.pageSize = pageSize; this.ratio = ratio; } public boolean isDebug() { return debug; } public int getPageSize() { return pageSize; } public double getRatio() { return ratio; } } <markup lang=\"java\" title=\"Custom Mapper Class\" >public class WebConfigMapper implements Function&lt;Config, WebConfig&gt; { @Override public WebConfig apply(Config config) throws ConfigMappingException, MissingValueException { return new WebConfig( config.get(\"debug\").asBoolean().orElse(false), config.get(\"page-size\").asInt().orElse(10), config.get(\"ratio\").asDouble().orElse(1.0) ); } } <markup lang=\"java\" title=\"Explicitly Using the Mapper\" >... Config config = Config.create(classpath(\"application.properties\")); WebConfig web = config.get(\"web\") .as(new WebConfigMapper()) .get(); <markup lang=\"java\" title=\"Registering and Implicitly Using the Mapper\" >... Config config = Config.builder(classpath(\"application.properties\")) .addMapper(WebConfig.class, new WebConfigMapper()) .build(); WebConfig web = config.get(\"web\") .as(WebConfig.class) .get(); Either of the two approaches just described will always work without requiring you to change the POJO class. ",
            "title": "Converting Configuration to Complex Types"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If you can change the target class you can add any one of the following methods or constructors to the POJO class which the config system will find and use for mapping. Methods Supporting Auto-mapping static WebConfig create(Config); static WebConfig from(Config); static WebConfig from(String); static WebConfig valueOf(Config); static WebConfig valueOf(String); static WebConfig fromConfig(Config); static WebConfig fromString(String); Constructors Supporting Auto-mapping WebConfig(Config); WebConfig(String); If the config system finds any of these methods or constructors when the application invokes <markup lang=\"java\" >WebConfig wc = config.as(WebConfig.class).get(); it will invoke the one it found to map the config data to a new instance of the target class. You do not need to write a separate class to do the mapping or register it with the Config.Builder for the config instance. ",
            "title": "Adding the Mapping to the POJO"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " You can limit the changes to the POJO class by adding a single builder method to the POJO which returns a builder class for the POJO: <markup lang=\"java\" >public class WebConfig { ... static WebConfigBuilder builder() { return new WebConfigBuilder(); } ... } The builder class WebConfigBuilder is expected to be a Java Bean with bean properties named for the config properties of interest, and a method WebConfig build() which creates the mapped instance from the builder&#8217;s own bean properties. When your application invokes config.as(WebConfig.class) the config system finds and invokes the WebConfig.builder() method, assigns the bean properties on the returned builder from the config subtree rooted at config , and invokes the builder&#8217;s build() method yielding the resulting WebConfig instance. ",
            "title": "Writing a Builder Method and Class for the POJO"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If the target Java class you want to use meets certain conditions&#8201;&#8212;&#8201;or if you can change it to meet one of those conditions&#8201;&#8212;&#8201;you might not need to write a separate mapper class. Instead, you add the mapping logic to the POJO itself in one of several ways and the config system uses Java reflection to search for those ways to perform the mapping. Your application facilitates this implicit mapping either by adding to the POJO class or by providing a builder class for it. This feature is available in Object mapping module, and is added through Java ServiceLoader mechanism. This is no longer part of core Config module, as it depends on reflection and introduces a lot of magic (see the list of supported mapping methods below, also uses reflection to invoke the methods and to map configuration values to fields/methods etc.). <markup lang=\"xml\" title=\"Config object mapping Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-object-mapping&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Adding the Mapping to the POJO If you can change the target class you can add any one of the following methods or constructors to the POJO class which the config system will find and use for mapping. Methods Supporting Auto-mapping static WebConfig create(Config); static WebConfig from(Config); static WebConfig from(String); static WebConfig valueOf(Config); static WebConfig valueOf(String); static WebConfig fromConfig(Config); static WebConfig fromString(String); Constructors Supporting Auto-mapping WebConfig(Config); WebConfig(String); If the config system finds any of these methods or constructors when the application invokes <markup lang=\"java\" >WebConfig wc = config.as(WebConfig.class).get(); it will invoke the one it found to map the config data to a new instance of the target class. You do not need to write a separate class to do the mapping or register it with the Config.Builder for the config instance. Writing a Builder Method and Class for the POJO You can limit the changes to the POJO class by adding a single builder method to the POJO which returns a builder class for the POJO: <markup lang=\"java\" >public class WebConfig { ... static WebConfigBuilder builder() { return new WebConfigBuilder(); } ... } The builder class WebConfigBuilder is expected to be a Java Bean with bean properties named for the config properties of interest, and a method WebConfig build() which creates the mapped instance from the builder&#8217;s own bean properties. When your application invokes config.as(WebConfig.class) the config system finds and invokes the WebConfig.builder() method, assigns the bean properties on the returned builder from the config subtree rooted at config , and invokes the builder&#8217;s build() method yielding the resulting WebConfig instance. ",
            "title": "Advanced Conversions using Explicit Mapping Logic"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If your POJO target class is already a JavaBean&#8201;&#8212;&#8201;or you can modify it to become one&#8201;&#8212;&#8201;you might be able to avoid writing any explicit mapping code yourself. The config system invokes the no-args constructor on the target class to create a new instance. It treats each public setter method and each public non-final field as a JavaBean property. The config system processes any non-primitive property recursively as a JavaBean. In this way the config system builds up the target object from the config data. By default, the system matches potential JavaBean property names with config keys in the configuration. Use the Value annnotation to control some of the JavaBean processing for a given property. Value Annotation Attribute Usage key Indicates which config key should match this JavaBean property withDefault String used for the bean property default value if none is set in the config withDefaultSupplier Supplier of the default bean property value if nont is set in the config To exclude a bean property from the config system bean processing annotate it with Config.Transient . Here is an example using the app portion of the example configuration from the introduction. <markup lang=\"java\" title=\"Java bean to load app propeties into via setters\" >public class AppConfig { private Instant timestamp; private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; public AppConfig() { } public void setGreeting(String greeting) { this.greeting = greeting; } public String getGreeting() { return greeting; } @Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } public int getPageSize() { return pageSize; } @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } @Config.Transient public void setTimestamp(Instant timestamp) { this.timestamp = timestamp; } public Instant getTimestamp() { return timestamp; } public static class BasicRangeSupplier implements Supplier&lt;List&lt;Integer&gt;&gt; { @Override public List&lt;Integer&gt; get() { return List.of(-10, 10); } } } Public no-parameter constructor. Property greeting is not customized and will be set from the config node with the key greeting , if present in the config. Property pageSize is matched to the config key page-size . If the page-size config node does not exist, the pageSize bean property defaults to 10 . Property basicRange is matched to the config key basic-range . If the basic-range config node does not exist, a BasicRangeSupplier instance will provide the default value. The timestamp bean property is never set, even if the config contains a node with the key timestamp . BasicRangeSupplier is used to supply the List&lt;Integer&gt; default value. Here is an example of code loading config and mapping part of it to the AppConfig bean above. <markup lang=\"java\" title=\"Map app config node into AppConfig class\" >Config config = Config.create(classpath(\"application.conf\")); AppConfig app = config.get(\"app\") .as(AppConfig.class) .get(); //assert that all values are loaded from file assert app.getGreeting().equals(\"Hello\"); assert app.getPageSize() == 20; assert app.getBasicRange().size() == 2 &amp;&amp; app.getBasicRange().get(0) == -20 &amp;&amp; app.getBasicRange().get(1) == 20; //assert that Transient property is not set assert app.getTimestamp() == null; The config system finds no registered ConfigMapper for AppConfig and so applies the JavaBean pattern to convert the config to an AppConfig instance. Because the bean property timestamp was marked as transient, the config system did not set it. ",
            "title": "POJO as JavaBean"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " If the target class includes the public static method builder() that returns any object, then the config system will make sure that the return type has a method build() which returns an instance of the target class. If so, the config system treats the builder as a JavaBean and invokes the builder() method to instantiate the builder class, treats the builder as a JavaBean and maps the Config subtree to it, invokes the builder&#8217;s build() method to create the new instance of the target class. You can augment the target class with the public static builder() method: <markup lang=\"java\" title=\"JavaBean for app properties, via a Builder \" >public class AppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static Builder builder() { return new Builder(); } public static class Builder { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private Builder() { } public void setGreeting(String greeting) { this.greeting = greeting; } @Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public AppConfig build() { return new AppConfig(greeting, pageSize, basicRange); } } } The target class&#8217;s constructor can be private in this case because new instances are created from the inner class Builder which has access to `AppConfig&#8217;s private members. The target class contains public static method builder() which returns an object that itself exposes the method AppConfig build() , so the config system recognizes it. The config system treats the AppConfig.Builder (not the enclosing target class) as a JavaBean. The builder&#8217;s property greeting is not customized and is set from config node with greeting key, if one exists. The builder&#8217;s property pageSize maps to the config key page-size and defaults to 10 if absent. The builder&#8217;s property basicRange maps to the config key basic-range and uses a BasicRangeSupplier instance to get a default value if needed. Finally, the config system invokes the builder&#8217;s public method build() , creating the new instance of AppConfig for use by the application. ",
            "title": "Builder as JavaBean"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " Another option is to annotate the parameters to a factory method or to a constructor on the target class. You can add a factory method to the target class, a public static method from with parameters annotated to link them to the corresponding config keys. Or you can add or modify a constructor with parameters, similarly annotated to form the link from each parameter to the corresponding config key. Warning Be sure to annotate each parameter of the from method or constructor with @Value and specify the key to use for the mapping. The parameter names in the Java code are not always available at runtime to map to config keys. (They might be arg0 , arg1 , etc.) <markup lang=\"java\" title=\"Target Class with Factory Method from \" >public class AppConfig { private final String greeting; private final int pageSize; private final List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static AppConfig from( @Value(key = \"greeting\") String greeting, @Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { return new AppConfig(greeting, pageSize, basicRange); } } The target class constructor can be private because the factory method on the same class has access to it. The config system invokes the factory method from(&#8230;&#8203;) , passing arguments it has fetched from the correspondingly-named config subtrees. The factory method returns the new initialized AppConfig instance. Note the consistent use of @Value(key = \"&#8230;&#8203;\") on each parameter. Because the property greeting does not specify a default value the property is mandatory and must appear in the configuration source. Otherwise the config system throws a ConfigMappingException . Alternatively, you can use an annotated constructor instead of a static factory method. Revising the example above, make the constructor public, annotate its parameters, and remove the now-unneeded from factory method. <markup lang=\"java\" title=\"Target Class with Annotated Public Constructor\" >public class AppConfig { ... public AppConfig( @Value(key = \"greeting\") String greeting, @Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } Constructor is public . Each parameter has the ConfigValue annotation to at least specify the config key name. When the application invokes config.as(AppConfig.class) , the config system locates the public annotated constructor and invokes it, passing as arguments the data it fetches from the configuration matching the annotation key names with the configuration keys. ",
            "title": "Target Class with Annotated Factory Method or Constructor"
        },
        {
            "location": "/config/04_property-mapping",
            "text": " The config system can also interpret your classes as JavaBeans and use the normal bean naming conventions to map configuration data to your POJO classes, using one of these patterns: POJO as JavaBean - The config system treats the target class itself as a JavaBean, assigning values from the config to the bean properties of the POJO class. builder as JavaBean - The config system invokes the POJO&#8217;s builder() method to obtain a builder for that POJO type and treats the builder class as a JavaBean, assigning values from the config to the builder&#8217;s bean properties and then invoking the builder&#8217;s build method to create an instance of the target POJO class. POJO with factory method or decorated constructor - The config system finds a from method or a constructor on the POJO class itself which accepts annotated arguments, then invokes that method or constructor passing the specified arguments based on the config. The from method returns an instance of the POJO class initialized with the values passed as arguments. The following sections describe these patterns in more detail. This feature is available in Object mapping module, and is added through Java ServiceLoader mechanism. This is no longer part of core Config module, as it depends on reflection. <markup lang=\"xml\" title=\"Config object mapping Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-object-mapping&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; POJO as JavaBean If your POJO target class is already a JavaBean&#8201;&#8212;&#8201;or you can modify it to become one&#8201;&#8212;&#8201;you might be able to avoid writing any explicit mapping code yourself. The config system invokes the no-args constructor on the target class to create a new instance. It treats each public setter method and each public non-final field as a JavaBean property. The config system processes any non-primitive property recursively as a JavaBean. In this way the config system builds up the target object from the config data. By default, the system matches potential JavaBean property names with config keys in the configuration. Use the Value annnotation to control some of the JavaBean processing for a given property. Value Annotation Attribute Usage key Indicates which config key should match this JavaBean property withDefault String used for the bean property default value if none is set in the config withDefaultSupplier Supplier of the default bean property value if nont is set in the config To exclude a bean property from the config system bean processing annotate it with Config.Transient . Here is an example using the app portion of the example configuration from the introduction. <markup lang=\"java\" title=\"Java bean to load app propeties into via setters\" >public class AppConfig { private Instant timestamp; private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; public AppConfig() { } public void setGreeting(String greeting) { this.greeting = greeting; } public String getGreeting() { return greeting; } @Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } public int getPageSize() { return pageSize; } @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } @Config.Transient public void setTimestamp(Instant timestamp) { this.timestamp = timestamp; } public Instant getTimestamp() { return timestamp; } public static class BasicRangeSupplier implements Supplier&lt;List&lt;Integer&gt;&gt; { @Override public List&lt;Integer&gt; get() { return List.of(-10, 10); } } } Public no-parameter constructor. Property greeting is not customized and will be set from the config node with the key greeting , if present in the config. Property pageSize is matched to the config key page-size . If the page-size config node does not exist, the pageSize bean property defaults to 10 . Property basicRange is matched to the config key basic-range . If the basic-range config node does not exist, a BasicRangeSupplier instance will provide the default value. The timestamp bean property is never set, even if the config contains a node with the key timestamp . BasicRangeSupplier is used to supply the List&lt;Integer&gt; default value. Here is an example of code loading config and mapping part of it to the AppConfig bean above. <markup lang=\"java\" title=\"Map app config node into AppConfig class\" >Config config = Config.create(classpath(\"application.conf\")); AppConfig app = config.get(\"app\") .as(AppConfig.class) .get(); //assert that all values are loaded from file assert app.getGreeting().equals(\"Hello\"); assert app.getPageSize() == 20; assert app.getBasicRange().size() == 2 &amp;&amp; app.getBasicRange().get(0) == -20 &amp;&amp; app.getBasicRange().get(1) == 20; //assert that Transient property is not set assert app.getTimestamp() == null; The config system finds no registered ConfigMapper for AppConfig and so applies the JavaBean pattern to convert the config to an AppConfig instance. Because the bean property timestamp was marked as transient, the config system did not set it. Builder as JavaBean If the target class includes the public static method builder() that returns any object, then the config system will make sure that the return type has a method build() which returns an instance of the target class. If so, the config system treats the builder as a JavaBean and invokes the builder() method to instantiate the builder class, treats the builder as a JavaBean and maps the Config subtree to it, invokes the builder&#8217;s build() method to create the new instance of the target class. You can augment the target class with the public static builder() method: <markup lang=\"java\" title=\"JavaBean for app properties, via a Builder \" >public class AppConfig { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static Builder builder() { return new Builder(); } public static class Builder { private String greeting; private int pageSize; private List&lt;Integer&gt; basicRange; private Builder() { } public void setGreeting(String greeting) { this.greeting = greeting; } @Value(key = \"page-size\", withDefault = \"10\") public void setPageSize(int pageSize) { this.pageSize = pageSize; } @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) public void setBasicRange(List&lt;Integer&gt; basicRange) { this.basicRange = basicRange; } public AppConfig build() { return new AppConfig(greeting, pageSize, basicRange); } } } The target class&#8217;s constructor can be private in this case because new instances are created from the inner class Builder which has access to `AppConfig&#8217;s private members. The target class contains public static method builder() which returns an object that itself exposes the method AppConfig build() , so the config system recognizes it. The config system treats the AppConfig.Builder (not the enclosing target class) as a JavaBean. The builder&#8217;s property greeting is not customized and is set from config node with greeting key, if one exists. The builder&#8217;s property pageSize maps to the config key page-size and defaults to 10 if absent. The builder&#8217;s property basicRange maps to the config key basic-range and uses a BasicRangeSupplier instance to get a default value if needed. Finally, the config system invokes the builder&#8217;s public method build() , creating the new instance of AppConfig for use by the application. Target Class with Annotated Factory Method or Constructor Another option is to annotate the parameters to a factory method or to a constructor on the target class. You can add a factory method to the target class, a public static method from with parameters annotated to link them to the corresponding config keys. Or you can add or modify a constructor with parameters, similarly annotated to form the link from each parameter to the corresponding config key. Warning Be sure to annotate each parameter of the from method or constructor with @Value and specify the key to use for the mapping. The parameter names in the Java code are not always available at runtime to map to config keys. (They might be arg0 , arg1 , etc.) <markup lang=\"java\" title=\"Target Class with Factory Method from \" >public class AppConfig { private final String greeting; private final int pageSize; private final List&lt;Integer&gt; basicRange; private AppConfig(String greeting, int pageSize, List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } public String getGreeting() { return greeting; } public int getPageSize() { return pageSize; } public List&lt;Integer&gt; getBasicRange() { return basicRange; } public static AppConfig from( @Value(key = \"greeting\") String greeting, @Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { return new AppConfig(greeting, pageSize, basicRange); } } The target class constructor can be private because the factory method on the same class has access to it. The config system invokes the factory method from(&#8230;&#8203;) , passing arguments it has fetched from the correspondingly-named config subtrees. The factory method returns the new initialized AppConfig instance. Note the consistent use of @Value(key = \"&#8230;&#8203;\") on each parameter. Because the property greeting does not specify a default value the property is mandatory and must appear in the configuration source. Otherwise the config system throws a ConfigMappingException . Alternatively, you can use an annotated constructor instead of a static factory method. Revising the example above, make the constructor public, annotate its parameters, and remove the now-unneeded from factory method. <markup lang=\"java\" title=\"Target Class with Annotated Public Constructor\" >public class AppConfig { ... public AppConfig( @Value(key = \"greeting\") String greeting, @Value(key = \"page-size\", withDefault = \"10\") int pageSize, @Value(key = \"basic-range\", withDefaultSupplier = BasicRangeSupplier.class) List&lt;Integer&gt; basicRange) { this.greeting = greeting; this.pageSize = pageSize; this.basicRange = basicRange; } Constructor is public . Each parameter has the ConfigValue annotation to at least specify the config key name. When the application invokes config.as(AppConfig.class) , the config system locates the public annotated constructor and invokes it, passing as arguments the data it fetches from the configuration matching the annotation key names with the configuration keys. ",
            "title": "Conversions using JavaBean Deserialization"
        },
        {
            "location": "/about/01_overview",
            "text": " explore Guides Follow step-by-step guides to build your applications. library_books Javadocs Browse the Helidon Javadocs. ",
            "title": "Get going"
        },
        {
            "location": "/about/01_overview",
            "text": " settings_ethernet WebServer A programmatic HTTP API with reactive features, powered by Netty. settings Config A flexible configuration framework with support for multiple sources and formats. security Security A tool-chain to handle authentication, authorization and context propagation. widgets MicroProfile A platform definition that is familiar to enterprise Java developers. extension Extensions A set of add-ons for your Helidon-based applications. av_timer Metrics Instrumentation to expose metrics of your applications. timeline Tracing Profile and monitor your applications across multiple services. favorite_outline Health Checks Expose health statuses of your applications. ",
            "title": "Components"
        },
        {
            "location": "/extensions/03_cdi_jedis",
            "text": " This CDI portable extension provides support for injecting Jedis clients in your Helidon MicroProfile applications. ",
            "title": "preambule"
        },
        {
            "location": "/extensions/03_cdi_jedis",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.integrations.cdi&lt;/groupId&gt; &lt;artifactId&gt;helidon-integrations-cdi-jedis&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/extensions/03_cdi_jedis",
            "text": " The following examples show how to create and inject a Jedis pool named orders in your application code. <markup lang=\"java\" title=\"Field-injection example\" > @Inject @Named(\"orders\") private JedisPool ordersPool; <markup lang=\"java\" title=\"Constructor-injection example\" > private final JedisPool ordersPool; @Inject public YourConstructor(@Named(\"orders\") JedisPool pool) { super(); this.ordersPool = pool; } The extension implements this injection point by creating a JedisPool object in the application scope . You can configure the object using MicroProfile config . For example, the Jedis pool created above can be configured as follows: <markup lang=\"properties\" title=\"META-INF/microprofile-config.properties\" >redis.clients.jedis.JedisPool.orders.port=6379 Property names that start with redis.clients.jedis.JedisPoolConfig.instanceName. are parsed, and the remaining portion of each name is treated as a Java Bean property of JedisPoolConfig . Because the JedisPoolConfig class inherits from Apache commons-pool&#8217;s GenericObjectPoolConfig class and from Apache commons-pool&#8217;s BaseObjectPoolConfig class, those writable Java Bean properties are available as well. Accordingly, the JedisPoolConfig Java Bean properties that can be set are as follows, where instanceName should be replaced with the actual name used in application code: <div class=\"table__overflow elevation-1 flex md7 \"> redis.clients.jedis.JedisPoolConfig.instanceName.blockWhenExhausted redis.clients.jedis.JedisPoolConfig.instanceName.evictionPolicyClassName redis.clients.jedis.JedisPoolConfig.instanceName.fairness redis.clients.jedis.JedisPoolConfig.instanceName.jmxEnabled redis.clients.jedis.JedisPoolConfig.instanceName.jmxNameBase redis.clients.jedis.JedisPoolConfig.instanceName.jmxNamePrefix redis.clients.jedis.JedisPoolConfig.instanceName.lifo redis.clients.jedis.JedisPoolConfig.instanceName.maxIdle redis.clients.jedis.JedisPoolConfig.instanceName.maxTotal redis.clients.jedis.JedisPoolConfig.instanceName.maxWaitMillis redis.clients.jedis.JedisPoolConfig.instanceName.minEvictableTimeMillis redis.clients.jedis.JedisPoolConfig.instanceName.minIdle redis.clients.jedis.JedisPoolConfig.instanceName.numTestsPerEvictionRun redis.clients.jedis.JedisPoolConfig.instanceName.softMinEvictableIdleTimeMillis redis.clients.jedis.JedisPoolConfig.instanceName.testOnBorrow redis.clients.jedis.JedisPoolConfig.instanceName.testOnCreate redis.clients.jedis.JedisPoolConfig.instanceName.testOnReturn redis.clients.jedis.JedisPoolConfig.instanceName.testWhileIdle redis.clients.jedis.JedisPoolConfig.instanceName.timeBetweenEvictionRunsMillis Any documentation for these properties that exists may be found in the javadocs for the JedisPoolConfig , GenericObjectPoolConfig and BaseObjectPoolConfig classes. Property names that start with redis.clients.jedis.JedisPool.instanceName. are parsed, and the remaining portion of each name is treated as a Java Bean property of JedisPool , or as a primitive value accepted by its constructor . Because the JedisPool class inherits from the Pool class, its writable Java Bean properties are available as well. Accordingly, the JedisPool properties that can be set are as follows, where instanceName should be replaced with the actual named used in application code: <div class=\"table__overflow elevation-1 flex md7 \"> redis.clients.jedis.JedisPool.instanceName.clientName redis.clients.jedis.JedisPool.instanceName.connectionTimeout redis.clients.jedis.JedisPool.instanceName.database redis.clients.jedis.JedisPool.instanceName.host redis.clients.jedis.JedisPool.instanceName.password redis.clients.jedis.JedisPool.instanceName.port redis.clients.jedis.JedisPool.instanceName.socketTimeout redis.clients.jedis.JedisPool.instanceName.ssl Any documentation for these properties that exists may be found in the javadocs for the JedisPool and Pool classes. ",
            "title": "Injecting a Jedis client"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " An in-memory config tree, once loaded, is immutable, even though the data in the underlying config sources can change over time. Your application can find out metadata about a loaded in-memory config and can track changes in config sources. ",
            "title": "preambule"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Even though in-memory config trees are immutable, the config system internally records which config sources it used to load each config tree and some metadata about the configuration. Your application can be aware of updates to the underlying config sources by: using the metadata the config system maintains, responding to changes when the config sources are updated, or using Supplier s of particular config values to obtain the always-current value for a key. ",
            "title": "Overview"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " The config system records when it loads each configuration into memory. Your application can retrieve it by invoking the timestamp method : <markup lang=\"java\" >java.time.Instance loadTime = myConfig.timestamp(); on any config node. ",
            "title": "Loading Time"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " The config system maintains a Config.Context for each Config node. Your application can retrieve the context by invoking the Config.context() method and then use it for these operations: Uses of Config.Context Method Usage Instant timestamp() Returns the load time of the last loaded configuration that used the context. Config last() Returns the most recently loaded configuration that used the context. Config reload() Reloads the entire config tree from the current contents of the same config sources used to load the tree in which the current node resides. Note that the config context describes or replaces a currently-loaded config tree. It by itself does not help your application decide when reloading the config might be useful. ",
            "title": "Config Context"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Loading Time The config system records when it loads each configuration into memory. Your application can retrieve it by invoking the timestamp method : <markup lang=\"java\" >java.time.Instance loadTime = myConfig.timestamp(); on any config node. Config Context The config system maintains a Config.Context for each Config node. Your application can retrieve the context by invoking the Config.context() method and then use it for these operations: Uses of Config.Context Method Usage Instant timestamp() Returns the load time of the last loaded configuration that used the context. Config last() Returns the most recently loaded configuration that used the context. Config reload() Reloads the entire config tree from the current contents of the same config sources used to load the tree in which the current node resides. Note that the config context describes or replaces a currently-loaded config tree. It by itself does not help your application decide when reloading the config might be useful. ",
            "title": "Using Config Metadata"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " When the application creates a config source, it can set up change detection for that source. This is called polling in the Helidon API but specific change detection algorithms might not use actual polling. You choose a specific PollingStrategy for each config source you want to monitor. See the section on polling strategies in the config extensions doc page for more information. The config system provides some built-in polling strategies, exposed as these methods on the PollingStrategies class: regular(Duration interval) - a general-purpose scheduled polling strategy with a specified, constant polling interval. watch(Path watchedPath) - a filesystem-specific strategy to watch specified path. You can use this strategy with the file and classpath built-in config sources. nop() - a no-op strategy This example builds a Config object from three sources, each set up with a different polling strategy: <markup lang=\"java\" title=\"Build a Config with a different PollingStrategy for each config source\" >Config config = Config.create( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies.regular(Duration.ofSeconds(2))) .optional(), ConfigSources.file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch) .optional(), ConfigSources.classpath(\"application.properties\") .pollingStrategy(PollingStrategies::nop)); Optional file source conf/dev.properties will be checked for changes every 2 seconds. Optional file source conf/config.properties will be watched by the Java WatchService for changes on filesystem. The classpath resource application.properties will not be checked for changes. PollingStrategies.nop() polling strategy is default. The polling strategies internally inform the config system when they detect changes in the monitored config sources (except that the nop strategy does nothing). ",
            "title": "Setting up Config Source Change Detection"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " A simple approach is for your application to register a function that should run when any change occurs. <markup lang=\"java\" title=\"Subscribe on greeting property changes via onChange method\" >config.get(\"greeting\") .onChange((changedNode) -&gt; { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); return true; }); Navigate to the Config node on which you want to register. Invoke the onChange method, passing a function ( Function&lt;Config, Boolean&gt; ). The config system invokes that function each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting . The function should return true to continue being run on subsequent changes, false to stop. ",
            "title": "Registering Actions"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " The config system also supports the flow publisher/subscriber model for applications that need more control over the pace at which the config system delivers config change events. Each Config instance exposes the Config.changes() method which returns a Flow.Publisher&lt;Config&gt; . Your application can invoke this method, then invoke subscribe on the returned Flow.Publisher , passing your own Flow.Subscriber implementation. The config system will invoke your subscriber&#8217;s methods as appropriate, most notably calling onNext whenever it detects a change in one of the underlying config sources for the config node of interest. Mote that your subscriber will be notified when a change occurs anywhere in the subtree represented by the Config node. <markup lang=\"java\" title=\"Subscribe on greeting property changes\" >config.get(\"greeting\") .changes() .subscribe(new Flow.Subscriber&lt;&gt;() { Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { this.subscription = subscription; subscription.request(1); } @Override public void onNext(Config changedNode) { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); subscription.request(1); } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } }); Navigate to the Config node on which you want to register. Invoke changes to get the Flow.Publisher of changes to the subtree rooted at the Config node. Subscribe to the publisher passing a custom Flow.Subscriber&lt;Config&gt; implementation. Request the first event delivery in onSubscribe method. The config system invokes onNext each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting , regardless of where in the subtree the change actually occurred. Remember to request the next event delivery in onNext . The config system does not currently invoke onError . The config system invokes onComplete if all config sources indicate there will be no other change event . Note Your application does not need to subscribe to the new Config instance passed to your onNext method. The original subscription remains in force for changes to the \"new\" instance. ",
            "title": "Subscribing to Events"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " To know when config sources have changed, your application must register its interest on the Config node of interest. The config system will then notify your application of any change within the subtree rooted at that node. In particular, if you register on the root node, then the config system notifies your code of changes anywhere in the config tree. You can register in either of two ways: register an action to be run upon each change, or subscribe to a Flow.Publisher that notifies of changes. Registering Actions A simple approach is for your application to register a function that should run when any change occurs. <markup lang=\"java\" title=\"Subscribe on greeting property changes via onChange method\" >config.get(\"greeting\") .onChange((changedNode) -&gt; { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); return true; }); Navigate to the Config node on which you want to register. Invoke the onChange method, passing a function ( Function&lt;Config, Boolean&gt; ). The config system invokes that function each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting . The function should return true to continue being run on subsequent changes, false to stop. Subscribing to Events The config system also supports the flow publisher/subscriber model for applications that need more control over the pace at which the config system delivers config change events. Each Config instance exposes the Config.changes() method which returns a Flow.Publisher&lt;Config&gt; . Your application can invoke this method, then invoke subscribe on the returned Flow.Publisher , passing your own Flow.Subscriber implementation. The config system will invoke your subscriber&#8217;s methods as appropriate, most notably calling onNext whenever it detects a change in one of the underlying config sources for the config node of interest. Mote that your subscriber will be notified when a change occurs anywhere in the subtree represented by the Config node. <markup lang=\"java\" title=\"Subscribe on greeting property changes\" >config.get(\"greeting\") .changes() .subscribe(new Flow.Subscriber&lt;&gt;() { Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { this.subscription = subscription; subscription.request(1); } @Override public void onNext(Config changedNode) { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); subscription.request(1); } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } }); Navigate to the Config node on which you want to register. Invoke changes to get the Flow.Publisher of changes to the subtree rooted at the Config node. Subscribe to the publisher passing a custom Flow.Subscriber&lt;Config&gt; implementation. Request the first event delivery in onSubscribe method. The config system invokes onNext each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting , regardless of where in the subtree the change actually occurred. Remember to request the next event delivery in onNext . The config system does not currently invoke onError . The config system invokes onComplete if all config sources indicate there will be no other change event . Note Your application does not need to subscribe to the new Config instance passed to your onNext method. The original subscription remains in force for changes to the \"new\" instance. ",
            "title": "Registering a Config Change Response"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Evolving API This section describes the Config.changes() method. It is marked as deprecated because it returns an io.helidon.reactive.Flow.Publisher object. In a future Helidon release that requires Java 9 or later this method will be undeprecated and changed&#8201;&#8212;&#8201;or a similar method will be added&#8201;&#8212;&#8201;so that the return type is java.util.concurrent.Flow.Publisher instead. Any code you write using the existing Config.changes() method might need to change at that time. Although in-memory config trees do not change once loaded, applications can respond to changes in the underlying config sources by: setting up change detection for the config sources used to build a configuration, and registering a response to be run when a source changes. Your code&#8217;s response can react to the changes in whatever way makes sense for your application. The following sections describe these steps in detail. Setting up Config Source Change Detection When the application creates a config source, it can set up change detection for that source. This is called polling in the Helidon API but specific change detection algorithms might not use actual polling. You choose a specific PollingStrategy for each config source you want to monitor. See the section on polling strategies in the config extensions doc page for more information. The config system provides some built-in polling strategies, exposed as these methods on the PollingStrategies class: regular(Duration interval) - a general-purpose scheduled polling strategy with a specified, constant polling interval. watch(Path watchedPath) - a filesystem-specific strategy to watch specified path. You can use this strategy with the file and classpath built-in config sources. nop() - a no-op strategy This example builds a Config object from three sources, each set up with a different polling strategy: <markup lang=\"java\" title=\"Build a Config with a different PollingStrategy for each config source\" >Config config = Config.create( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies.regular(Duration.ofSeconds(2))) .optional(), ConfigSources.file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch) .optional(), ConfigSources.classpath(\"application.properties\") .pollingStrategy(PollingStrategies::nop)); Optional file source conf/dev.properties will be checked for changes every 2 seconds. Optional file source conf/config.properties will be watched by the Java WatchService for changes on filesystem. The classpath resource application.properties will not be checked for changes. PollingStrategies.nop() polling strategy is default. The polling strategies internally inform the config system when they detect changes in the monitored config sources (except that the nop strategy does nothing). Registering a Config Change Response To know when config sources have changed, your application must register its interest on the Config node of interest. The config system will then notify your application of any change within the subtree rooted at that node. In particular, if you register on the root node, then the config system notifies your code of changes anywhere in the config tree. You can register in either of two ways: register an action to be run upon each change, or subscribe to a Flow.Publisher that notifies of changes. Registering Actions A simple approach is for your application to register a function that should run when any change occurs. <markup lang=\"java\" title=\"Subscribe on greeting property changes via onChange method\" >config.get(\"greeting\") .onChange((changedNode) -&gt; { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); return true; }); Navigate to the Config node on which you want to register. Invoke the onChange method, passing a function ( Function&lt;Config, Boolean&gt; ). The config system invokes that function each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting . The function should return true to continue being run on subsequent changes, false to stop. Subscribing to Events The config system also supports the flow publisher/subscriber model for applications that need more control over the pace at which the config system delivers config change events. Each Config instance exposes the Config.changes() method which returns a Flow.Publisher&lt;Config&gt; . Your application can invoke this method, then invoke subscribe on the returned Flow.Publisher , passing your own Flow.Subscriber implementation. The config system will invoke your subscriber&#8217;s methods as appropriate, most notably calling onNext whenever it detects a change in one of the underlying config sources for the config node of interest. Mote that your subscriber will be notified when a change occurs anywhere in the subtree represented by the Config node. <markup lang=\"java\" title=\"Subscribe on greeting property changes\" >config.get(\"greeting\") .changes() .subscribe(new Flow.Subscriber&lt;&gt;() { Flow.Subscription subscription; @Override public void onSubscribe(Flow.Subscription subscription) { this.subscription = subscription; subscription.request(1); } @Override public void onNext(Config changedNode) { System.out.println(\"Node \" + changedNode.key() + \" has changed!\"); subscription.request(1); } @Override public void onError(Throwable throwable) { } @Override public void onComplete() { } }); Navigate to the Config node on which you want to register. Invoke changes to get the Flow.Publisher of changes to the subtree rooted at the Config node. Subscribe to the publisher passing a custom Flow.Subscriber&lt;Config&gt; implementation. Request the first event delivery in onSubscribe method. The config system invokes onNext each time the subtree rooted at the greeting node changes. The changedNode is a new instance of Config representing the updated subtree rooted at greeting , regardless of where in the subtree the change actually occurred. Remember to request the next event delivery in onNext . The config system does not currently invoke onError . The config system invokes onComplete if all config sources indicate there will be no other change event . Note Your application does not need to subscribe to the new Config instance passed to your onNext method. The original subscription remains in force for changes to the \"new\" instance. ",
            "title": "Responding to Changes in Config Sources"
        },
        {
            "location": "/config/05_mutability-support",
            "text": " Some applications do not need to respond to changes as they happen. Instead it&#8217;s sufficient that they simply have access to the current value for a particular key in the configuration. Each asXXX method on the Config class has a companion asXXXSupplier method. These supplier methods return Supplier&lt;XXX&gt; , and when your application invokes the supplier&#8217;s get method the config system returns the then-current value as stored in the config source. <markup lang=\"java\" title=\"Access greeting property as Supplier&lt;String&gt; \" >// Construct a Config with the appropriate PollingStrategy on each config source. Supplier&lt;String&gt; greetingSupplier = config.get(\"greeting\") .asString().supplier(); System.out.println(\"Always actual greeting value: \" + greetingSupplier.get()); Navigate to the Config node for which you want access to the always-current value. Retrieve and store the returned supplier for later use. Invoke the supplier&#8217;s get() method to retrieve the current value of the node. Important Supplier support requires that you create the Config object from config sources that have proper polling strategies set up. ",
            "title": "Accessing Always-current Values"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " This section discusses several advanced topics related to Helidon configuration. ",
            "title": "preambule"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The config system supports using environment variables as a config source, and is enabled by default. Since environment variable names are normally restricted to alphanumeric characters and underscore, this config source adds variants that enable setting or overriding config entries with dotted and/or hyphenated keys. The mapping makes it possible to set or override a config entry with a key of \"foo.bar\" using an environment variable named \"FOO_BAR\" and \"foo.bar-baz\" using \"FOO_BAR_dash_BAZ\" . One use case for this mapping is config overrides in containers, where passing environment variables directly or via Kubernetes Secrets/ConfigMaps is common. Scripts that solve the mapping problem by explicitly converting variables to system properties can also be simplified. Variants are produced for any environment variable name that matches all of the following: does not begin or end with a '_' character does not contain \"__\" contains one or more '_' characters For each such name, two variants are added with the names mapped as follows: Replace any \"_dash_\" substrings with \"-\" , e.g. \"APP_PAGE_dash_SIZE\" becomes \"APP_PAGE-SIZE\" . Replace '_' with '.' and add as a variant, e.g. \"APP_GREETING\" is added as \"APP.GREETING\" and \"APP_PAGE-SIZE\" is added as \"APP.PAGE-SIZE\" . This mapping is added primarily to support mixed case config keys such as \"app.someCamelCaseKey\" . Convert the result of step 2 to lowercase and add as a variant, e.g. \"APP.GREETING\" is added as \"app.greeting\" and \"APP.PAGE-SIZE\" is added as \"app.page-size\" . ",
            "title": "Environment Variables Config Source"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The config system supports using a file system directory as a config source. Each non-directory file in the directory becomes a config entry: the file name is the key and the contents of that file are used as the corresponding config String value. The following example shows, for example, one way to load Kubernetes secrets mounted on the pod&#8217;s filesystem. If the directory conf/secrets contains these two files <markup title=\"File secrets/username \" >jose <markup title=\"File secrets/password \" >^ery$ecretP&amp;ssword your application can load this as configuration as follows: <markup lang=\"java\" title=\"Using directory config source\" >Config secrets = Config.withSources( ConfigSources.directory(\"conf/secrets\")) .disableEnvironmentVariablesSource() .disableSystemPropertiesSource() .build(); assert secrets.get(\"username\") .asString() .get() .equals(\"jose\"); assert secrets.get(\"password\") .asString() .get() .equals(\"^ery$ecretP&amp;ssword\"); Loads all files from the conf/secrets directory. No need to use environment variables or system properties as sources in building the Config . The loaded config maps the key username to the value jose &#8230;&#8203; &#8230;&#8203;and the key password to ^ery$ecretP&amp;ssword . Remember that your application can process the contents of a given file as configuration. See the config sources section and the ConfigSources.file JavaDoc. ",
            "title": "Directory Config Source"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config anotherConfig = Config.create(classpath(\"application.conf\")); Config config = Config.create( ConfigSources.create(anotherConfig.get(\"data\"))); ",
            "title": "Subtree of Another Config "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.create( ConfigSources.create(System.getProperties()).build()); ",
            "title": " Properties Object"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.create( ConfigSources.create(\"app.greeting = Hi\", \"text/x-java-properties\")); ",
            "title": " String of a Given Media Type"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.crate( ConfigSources.create(Map.of(\"app.page-size\", \"20\")) .lax() .build()); ",
            "title": " Map "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" >Config config = Config.create( ConfigSources.create(ObjectNode.builder() .addList(\"app.basic-range\", ListNode.builder() .addValue(\"-20\") .addValue(\"20\") .build()) .build())); ConfigSources.create variants for Properties or Map arguments return a ConfigSources.MapBuilder instance. A similar create variant accepts a Readable instead of a String . MapBuilder by default throws an exception if a key appears more than once in the map. The lax() method relaxes this; the config system logs a warning instead. ",
            "title": " ad hoc Config Nodes"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The config system provides several ways to create a Config tree from data already in memory. See the ConfigSources javadoc for further details. The numerous variants of the from method construct ConfigSource or Builder&lt;ConfigSource&gt; instances. Subtree of Another Config <markup lang=\"java\" >Config anotherConfig = Config.create(classpath(\"application.conf\")); Config config = Config.create( ConfigSources.create(anotherConfig.get(\"data\"))); Properties Object <markup lang=\"java\" >Config config = Config.create( ConfigSources.create(System.getProperties()).build()); String of a Given Media Type <markup lang=\"java\" >Config config = Config.create( ConfigSources.create(\"app.greeting = Hi\", \"text/x-java-properties\")); Map <markup lang=\"java\" >Config config = Config.crate( ConfigSources.create(Map.of(\"app.page-size\", \"20\")) .lax() .build()); ad hoc Config Nodes <markup lang=\"java\" >Config config = Config.create( ConfigSources.create(ObjectNode.builder() .addList(\"app.basic-range\", ListNode.builder() .addValue(\"-20\") .addValue(\"20\") .build()) .build())); ConfigSources.create variants for Properties or Map arguments return a ConfigSources.MapBuilder instance. A similar create variant accepts a Readable instead of a String . MapBuilder by default throws an exception if a key appears more than once in the map. The lax() method relaxes this; the config system logs a warning instead. ",
            "title": "In-memory Config Sources"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.create( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\") .asString() .get() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\") .asString() .get() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. ",
            "title": "Prefixed Config Sources"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The ConfigSources.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.create(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeBuilder . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.create( ConfigSources.create(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.create(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. ",
            "title": "Merging Strategies"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Prefixed Config Sources Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.create( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\") .asString() .get() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\") .asString() .get() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. Merging Strategies The ConfigSources.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.create(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeBuilder . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.create( ConfigSources.create(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.create(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. ",
            "title": "Handling Key Collisions"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Although the examples above use a single source, you can build a single Config from multiple sources. Handling Key Collisions Prefixed Config Sources Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.create( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\") .asString() .get() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\") .asString() .get() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. Merging Strategies The ConfigSources.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.create(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeBuilder . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.create( ConfigSources.create(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.create(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. ",
            "title": "Multi-Source Config s and Composite Config Sources"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java Service java.nio.file.spi.FileTypeDetector API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) ",
            "title": "By Inference"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.create(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. ",
            "title": "By Application Directive"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " By Inference Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java Service java.nio.file.spi.FileTypeDetector API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) By Application Directive Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.create(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. ",
            "title": "Identifying the Media Type"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. ",
            "title": "By Inference from media-type "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.create(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. ",
            "title": "By Application Directive"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " By Inference from media-type Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. By Application Directive Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.create(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. ",
            "title": "Locating a Parser"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " As the config sources and parsers section describes, these two work together to read and translate configuration data from some external form into the corresponding in-memory config tree. Although most applications are explicit about the config sources they use in building a Config , the config system often has to figure out what parser to use. It does so by: determining, the best that it can, the media type of the source, and locating a parser that can translate that media type. Identifying the Media Type By Inference Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java Service java.nio.file.spi.FileTypeDetector API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) By Application Directive Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.create(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. Locating a Parser By Inference from media-type Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. By Application Directive Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.create(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. ",
            "title": "How Config Chooses Parsers"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": "<markup lang=\"java\" title=\"Specify JSON as media type for node\" >Config config = Config.create( classpath(\"application.yaml\") .mediaTypeMapping( key -&gt; \"app\".equals(key.toString()) ? \"application/json\" : null)); assert config.get(\"secrets.username\").asString() .get().equals(\"jose\"); assert config.get(\"secrets.password\").asString() .get().equals(\"^ery$ecretP&amp;ssword\"); assert config.get(\"app\").type() == Type.OBJECT; assert config.get(\"app.greeting\") .asString().get().equals(\"Hello\"); assert config.get(\"app.page-size\") .asInt().get() == 20; assert config.get(\"app.basic-range.0\") .asInt().get() == -20; assert config.get(\"app.basic-range.1\") .asInt().get() == 20; The source builder&#8217;s mediaTypeMapping method accepts a function which returns the appropriate media types (if any) for config keys. The function says to treat the app property value as a JSON document and leave other nodes unchanged. Other properties are loaded as expected. Property app is now an structured object node. Because the function passed to mediaTypeMapping identifies the app node as a JSON document, the config system selects the config parser that is registered with the builder which also handles the JSON media type. Also, note that the config system replaces the original String value node with an object node resulting from parsing that String value as JSON. ",
            "title": "Specify Key-to-media-type Mapping"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Alternatively, your application could map config keys to the specific parsers you want to use for parsing those keys' values. <markup lang=\"java\" title=\"Specify JSON formatted property' parser instance\" >Config config = Config.create( ConfigSources.classpath(\"application.yaml\") .parserMapping( key -&gt; \"app\".equals(key.toString()) ? HoconConfigParserBuilder.buildDefault() : null)); Uses the parserMapping method to map keys to parser instances. Tells the config system to use the HOCON parser for translating the String value of the app key. (HCON is a superset of JSON.) As before, the config system replaces the value node in the containing config tree with the config tree resulting from the additional parse. ",
            "title": "Specify Key-to-parser Mapping"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " A config value node might contain an entire config document in String form, but in a format different from the containing document. Your application can tell the config system to parse such a node as config in a different format and replace the String value node in the original tree with the config tree that results from parsing that String . In this example, a YAML document contains a JSON document as a leaf. <markup lang=\"yaml\" title=\"YAML file with included JSON formated property\" >secrets: username: \"jose\" password: \"^ery$ecretP&amp;ssword\" app: &gt; { \"greeting\": \"Hello\", \"page-size\": 20, \"basic-range\": [ -20, 20 ] } The property app is itself formatted as a JSON document. Specify Key-to-media-type Mapping <markup lang=\"java\" title=\"Specify JSON as media type for node\" >Config config = Config.create( classpath(\"application.yaml\") .mediaTypeMapping( key -&gt; \"app\".equals(key.toString()) ? \"application/json\" : null)); assert config.get(\"secrets.username\").asString() .get().equals(\"jose\"); assert config.get(\"secrets.password\").asString() .get().equals(\"^ery$ecretP&amp;ssword\"); assert config.get(\"app\").type() == Type.OBJECT; assert config.get(\"app.greeting\") .asString().get().equals(\"Hello\"); assert config.get(\"app.page-size\") .asInt().get() == 20; assert config.get(\"app.basic-range.0\") .asInt().get() == -20; assert config.get(\"app.basic-range.1\") .asInt().get() == 20; The source builder&#8217;s mediaTypeMapping method accepts a function which returns the appropriate media types (if any) for config keys. The function says to treat the app property value as a JSON document and leave other nodes unchanged. Other properties are loaded as expected. Property app is now an structured object node. Because the function passed to mediaTypeMapping identifies the app node as a JSON document, the config system selects the config parser that is registered with the builder which also handles the JSON media type. Also, note that the config system replaces the original String value node with an object node resulting from parsing that String value as JSON. Specify Key-to-parser Mapping Alternatively, your application could map config keys to the specific parsers you want to use for parsing those keys' values. <markup lang=\"java\" title=\"Specify JSON formatted property' parser instance\" >Config config = Config.create( ConfigSources.classpath(\"application.yaml\") .parserMapping( key -&gt; \"app\".equals(key.toString()) ? HoconConfigParserBuilder.buildDefault() : null)); Uses the parserMapping method to map keys to parser instances. Tells the config system to use the HOCON parser for translating the String value of the app key. (HCON is a superset of JSON.) As before, the config system replaces the value node in the containing config tree with the config tree resulting from the additional parse. ",
            "title": "Parsing a Config Value as Config"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your application loads the configuration specified by a meta-config file by: invoking the ConfigSources.load(Config) method, passing a config object read from the meta-config source as the argument; invoking the Config.loadSourcesFrom method, or invoking the Config.builderLoadSourceFrom method. These methods return either a Config tree or a Config.Builder which your application can further fine-tune before using to construct a Config tree. The config system interprets the meta-config as directions for how to build a config tree, rather than as the config data itself. ",
            "title": "Loading Config by Specifying a Meta-configuration File"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The introduction section shows how to use Config.create() to load config from one of several possible default config files. That same method also searches for one of several possible default meta-config files from which to load config sources to be used for the default config. The Config.create() method determines the default configuration from the following search: Attempt to load meta-config from at most one of the following, checked in this order: meta-config.yaml - meta configuration file in YAML format meta-config.conf - meta configuration file in HOCON format meta-config.json - meta configuration file in JSON format meta-config.properties - meta configuration file in Java Properties format Otherwise, load config from: environment variables, and Java system properties, and at most one of the following, checking in this order: application.yaml - configuration file in YAML format application.conf - configuration file in HOCON format application.json - configuration file in JSON format application.properties - configuration file in Java Properties format Remember that the config system will check for these default meta-config and config files only if the classpath includes the corresponding parsers. The introduction section on built-in formats section describes this further. ",
            "title": "Loading Config from an Implicit Meta-configuration File"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. ",
            "title": "Built-in Types"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Each meta-configuration file must contain the top-level sources property that is an array (ordered list) of config sources. The meta-config file can contain other top-level keys as well but the config system ignores them when it interprets the contents as meta-configuration. Each sources property must contain exactly one of following top level properties: Meta-configuration Required Top-level Property Property Name Usage type Either: a predefined type (see below ), or a custom config source ID class Fully-qualified class name of either: a custom config source implementation, or a builder class with a build() method that returns ConfigSource If you specify both type and class , the config system ignores the class setting. In addition, each sources property can optionally have a properties property which assigns type-specific attributes for the config source being defined. Built-in Types The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. ",
            "title": "Meta-configuration File Format"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } ",
            "title": "Custom Source Types using class "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. ",
            "title": "Custom Source Type using type "
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " You can use meta-config to set up custom config source types as well as the built-in ones described above. Meta-config supports this in two ways: by class name by custom type name Custom Source Types using class Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } Custom Source Type using type You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. ",
            "title": "Meta-config for Custom Source Types"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Here is how your application can use meta-configuration in a particular resource on the classpath to load a Config tree: <markup lang=\"java\" title=\"Loading Config using Meta-configuration\" >ConfigSource sourceFromMetaConfig = ConfigSources.load( classpath(\"config-meta-all.conf\")).build(); Config config = Config.create(sourceFromMetaConfig); The ConfigSources.load method creates a config source for the eventual config from the config source argument which specifies the meta-config. This example uses meta-config from a resource on the classpath but you can use meta-config from any valid config source. The load method populates the sourceFromMetaConfig ConfigSource from all the actual sources declared in the meta-configuration. The returned ConfigSource is ready for use in creating a Config instance. ",
            "title": "Loading Config using Meta-configuration"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Your meta-config can include the set-up for polling strategies and retry policies if the config source supports them. Declare them in a way similar to how you declare the config sources themselves: by type or class and with accompanying properties . Meta-config Support for Built-in Polling Strategies Strategy Type Usage Properties regular Periodic polling - See PollingStrategies.regular method interval ( Duration ) - indicating how often to poll; e.g., PT15S represents 15 seconds watch Filesystem monitoring - See PollingStrategies.watch method path - file system path to the classpath , file , or directory to monitor Meta-config Support for Built-in Retry Policies Policy Type Usage Properties repeat Regularly-scheduled - see RetryPolicies.repeat . retries ( int ) - number of retries to perform Optional: delay ( Duration ) - initial delay between retries delay-factor ( double ) - delay is repeatedly multiplied by this each retry to compute the delay for each successive retry call-timeout ( Duration ) - timeout for a single invocation to load the source overall-timeout ( Duration ) - total timeout for all retry calls and delays To specify a custom polling strategy or custom retry policy, specify class (instead of type ) and give the fully-qualified class name for the implementation class. If your custom class needs parameters to control its behavior the config system uses io.helidon.config.ConfigMapper to initialize the class instance. See RetryPolicy and PollingStrategy JavaDoc sections. ",
            "title": "Meta-config for Polling Strategies and Retry Policies"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Instead of including code in your application to construct config trees from builders, sources, etc., you can instead prepare meta-configuration in a file that declares the sources to load and their attributes. You can either specify the meta-config file in your application or allow the config system to search for and load meta-config from a preset list of possible sources. Loading Config by Specifying a Meta-configuration File Your application loads the configuration specified by a meta-config file by: invoking the ConfigSources.load(Config) method, passing a config object read from the meta-config source as the argument; invoking the Config.loadSourcesFrom method, or invoking the Config.builderLoadSourceFrom method. These methods return either a Config tree or a Config.Builder which your application can further fine-tune before using to construct a Config tree. The config system interprets the meta-config as directions for how to build a config tree, rather than as the config data itself. Loading Config from an Implicit Meta-configuration File The introduction section shows how to use Config.create() to load config from one of several possible default config files. That same method also searches for one of several possible default meta-config files from which to load config sources to be used for the default config. The Config.create() method determines the default configuration from the following search: Attempt to load meta-config from at most one of the following, checked in this order: meta-config.yaml - meta configuration file in YAML format meta-config.conf - meta configuration file in HOCON format meta-config.json - meta configuration file in JSON format meta-config.properties - meta configuration file in Java Properties format Otherwise, load config from: environment variables, and Java system properties, and at most one of the following, checking in this order: application.yaml - configuration file in YAML format application.conf - configuration file in HOCON format application.json - configuration file in JSON format application.properties - configuration file in Java Properties format Remember that the config system will check for these default meta-config and config files only if the classpath includes the corresponding parsers. The introduction section on built-in formats section describes this further. Meta-configuration File Format Each meta-configuration file must contain the top-level sources property that is an array (ordered list) of config sources. The meta-config file can contain other top-level keys as well but the config system ignores them when it interprets the contents as meta-configuration. Each sources property must contain exactly one of following top level properties: Meta-configuration Required Top-level Property Property Name Usage type Either: a predefined type (see below ), or a custom config source ID class Fully-qualified class name of either: a custom config source implementation, or a builder class with a build() method that returns ConfigSource If you specify both type and class , the config system ignores the class setting. In addition, each sources property can optionally have a properties property which assigns type-specific attributes for the config source being defined. Built-in Types The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. Meta-config for Custom Source Types You can use meta-config to set up custom config source types as well as the built-in ones described above. Meta-config supports this in two ways: by class name by custom type name Custom Source Types using class Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } Custom Source Type using type You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. Loading Config using Meta-configuration Here is how your application can use meta-configuration in a particular resource on the classpath to load a Config tree: <markup lang=\"java\" title=\"Loading Config using Meta-configuration\" >ConfigSource sourceFromMetaConfig = ConfigSources.load( classpath(\"config-meta-all.conf\")).build(); Config config = Config.create(sourceFromMetaConfig); The ConfigSources.load method creates a config source for the eventual config from the config source argument which specifies the meta-config. This example uses meta-config from a resource on the classpath but you can use meta-config from any valid config source. The load method populates the sourceFromMetaConfig ConfigSource from all the actual sources declared in the meta-configuration. The returned ConfigSource is ready for use in creating a Config instance. Meta-config for Polling Strategies and Retry Policies Your meta-config can include the set-up for polling strategies and retry policies if the config source supports them. Declare them in a way similar to how you declare the config sources themselves: by type or class and with accompanying properties . Meta-config Support for Built-in Polling Strategies Strategy Type Usage Properties regular Periodic polling - See PollingStrategies.regular method interval ( Duration ) - indicating how often to poll; e.g., PT15S represents 15 seconds watch Filesystem monitoring - See PollingStrategies.watch method path - file system path to the classpath , file , or directory to monitor Meta-config Support for Built-in Retry Policies Policy Type Usage Properties repeat Regularly-scheduled - see RetryPolicies.repeat . retries ( int ) - number of retries to perform Optional: delay ( Duration ) - initial delay between retries delay-factor ( double ) - delay is repeatedly multiplied by this each retry to compute the delay for each successive retry call-timeout ( Duration ) - timeout for a single invocation to load the source overall-timeout ( Duration ) - total timeout for all retry calls and delays To specify a custom polling strategy or custom retry policy, specify class (instead of type ) and give the fully-qualified class name for the implementation class. If your custom class needs parameters to control its behavior the config system uses io.helidon.config.ConfigMapper to initialize the class instance. See RetryPolicy and PollingStrategy JavaDoc sections. ",
            "title": "Loading Config using Meta-configuration"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Environment Variables Config Source The config system supports using environment variables as a config source, and is enabled by default. Since environment variable names are normally restricted to alphanumeric characters and underscore, this config source adds variants that enable setting or overriding config entries with dotted and/or hyphenated keys. The mapping makes it possible to set or override a config entry with a key of \"foo.bar\" using an environment variable named \"FOO_BAR\" and \"foo.bar-baz\" using \"FOO_BAR_dash_BAZ\" . One use case for this mapping is config overrides in containers, where passing environment variables directly or via Kubernetes Secrets/ConfigMaps is common. Scripts that solve the mapping problem by explicitly converting variables to system properties can also be simplified. Variants are produced for any environment variable name that matches all of the following: does not begin or end with a '_' character does not contain \"__\" contains one or more '_' characters For each such name, two variants are added with the names mapped as follows: Replace any \"_dash_\" substrings with \"-\" , e.g. \"APP_PAGE_dash_SIZE\" becomes \"APP_PAGE-SIZE\" . Replace '_' with '.' and add as a variant, e.g. \"APP_GREETING\" is added as \"APP.GREETING\" and \"APP_PAGE-SIZE\" is added as \"APP.PAGE-SIZE\" . This mapping is added primarily to support mixed case config keys such as \"app.someCamelCaseKey\" . Convert the result of step 2 to lowercase and add as a variant, e.g. \"APP.GREETING\" is added as \"app.greeting\" and \"APP.PAGE-SIZE\" is added as \"app.page-size\" . Directory Config Source The config system supports using a file system directory as a config source. Each non-directory file in the directory becomes a config entry: the file name is the key and the contents of that file are used as the corresponding config String value. The following example shows, for example, one way to load Kubernetes secrets mounted on the pod&#8217;s filesystem. If the directory conf/secrets contains these two files <markup title=\"File secrets/username \" >jose <markup title=\"File secrets/password \" >^ery$ecretP&amp;ssword your application can load this as configuration as follows: <markup lang=\"java\" title=\"Using directory config source\" >Config secrets = Config.withSources( ConfigSources.directory(\"conf/secrets\")) .disableEnvironmentVariablesSource() .disableSystemPropertiesSource() .build(); assert secrets.get(\"username\") .asString() .get() .equals(\"jose\"); assert secrets.get(\"password\") .asString() .get() .equals(\"^ery$ecretP&amp;ssword\"); Loads all files from the conf/secrets directory. No need to use environment variables or system properties as sources in building the Config . The loaded config maps the key username to the value jose &#8230;&#8203; &#8230;&#8203;and the key password to ^ery$ecretP&amp;ssword . Remember that your application can process the contents of a given file as configuration. See the config sources section and the ConfigSources.file JavaDoc. In-memory Config Sources The config system provides several ways to create a Config tree from data already in memory. See the ConfigSources javadoc for further details. The numerous variants of the from method construct ConfigSource or Builder&lt;ConfigSource&gt; instances. Subtree of Another Config <markup lang=\"java\" >Config anotherConfig = Config.create(classpath(\"application.conf\")); Config config = Config.create( ConfigSources.create(anotherConfig.get(\"data\"))); Properties Object <markup lang=\"java\" >Config config = Config.create( ConfigSources.create(System.getProperties()).build()); String of a Given Media Type <markup lang=\"java\" >Config config = Config.create( ConfigSources.create(\"app.greeting = Hi\", \"text/x-java-properties\")); Map <markup lang=\"java\" >Config config = Config.crate( ConfigSources.create(Map.of(\"app.page-size\", \"20\")) .lax() .build()); ad hoc Config Nodes <markup lang=\"java\" >Config config = Config.create( ConfigSources.create(ObjectNode.builder() .addList(\"app.basic-range\", ListNode.builder() .addValue(\"-20\") .addValue(\"20\") .build()) .build())); ConfigSources.create variants for Properties or Map arguments return a ConfigSources.MapBuilder instance. A similar create variant accepts a Readable instead of a String . MapBuilder by default throws an exception if a key appears more than once in the map. The lax() method relaxes this; the config system logs a warning instead. Multi-Source Config s and Composite Config Sources Although the examples above use a single source, you can build a single Config from multiple sources. Handling Key Collisions Prefixed Config Sources Sometimes you might want to create a single config tree from multiple sources but in a way that keeps the config from different sources in different subtrees. The config system lets you assign a prefix to all keys from a given source using the ConfigSources.prefixed method. The following example shows two YAML files as config sources and the code to load each with a different prefix into a single Config tree: <markup lang=\"hocon\" title=\"File app.conf \" >greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] <markup lang=\"hocon\" title=\"File data.conf \" >providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] <markup lang=\"java\" title=\"Using prefixed config source\" >Config config = Config.create( ConfigSources.prefixed(\"app\", classpath(\"app.conf\")), ConfigSources.prefixed(\"data\", classpath(\"data.conf\"))); assert config.get(\"app.greeting\") .asString() .get() .equals(\"Hello\"); assert config.get(\"data.providers.0.name\") .asString() .get() .equals(\"Provider1\"); Specifies the prefix app for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Specifies the prefix data for the associated source. Supplier&lt;ConfigSource&gt; for the file app.conf loaded from the current classpath . Key app.greeting combines the app prefix and the original key greeting from the app.conf source. Key data.providers.0.name combines the data prefix and the original key providers.0.name property from data.conf source. This technique can be useful, for example, if multiple sources contain keys that might overlap; assigning different prefixes to the keys from different sources gives your application a way to access all config elements distinctly even if their keys would otherwise conflict. Merging Strategies The ConfigSources.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and ConfigSources.create(List&lt;Supplier&lt;ConfigSource&gt;&#8230;&#8203;) methods return a CompositeBuilder . By default, earlier sources in the list have higher priority than later ones, meaning that if the same key appears in two or more sources the source earlier in the list prevails. Each CompositeConfigSource 's merging strategy actually controls this behavior. The config system provides the FallbackMergingStrategy which implements the default, \"first wins\" algorithm. You can write your own implementation of ConfigSources.MergingStrategy and use it instead to provide a different algorithm. <markup lang=\"java\" title=\"Composite config source example\" >Config config = Config.create( ConfigSources.create(file(\"conf/dev.properties\").optional(), file(\"conf/config.properties\").optional()) .add(classpath(\"application.properties\")) .mergingStrategy(ConfigSources.MergingStrategy.fallback())); Creates a new Config instance from a single composite config source. Method ConfigSources.create(sources&#8230;&#8203;) returns CompositeBuilder instance initialized with two sources (from dev.properties and config.properties files). Adds third config source ( application.properties on classpath) to the same CompositeBuilder . Specifies the merging strategy. This example uses the default fallback merging strategy. How Config Chooses Parsers As the config sources and parsers section describes, these two work together to read and translate configuration data from some external form into the corresponding in-memory config tree. Although most applications are explicit about the config sources they use in building a Config , the config system often has to figure out what parser to use. It does so by: determining, the best that it can, the media type of the source, and locating a parser that can translate that media type. Identifying the Media Type By Inference Most applications let the config system try to infer the media type of the config source. By default config source implementations use the Java Service java.nio.file.spi.FileTypeDetector API to infer the source media type from the source, typically (but not always) based on the file type portion of the file path. The config system registers implementations of the java.nio.file.spi.FileTypeDetector SPI that recognize the supported formats: .properties , .yaml , .json and .conf . To handle other formats you can implement and register your own FileTypeDetector implementations. (Typically you would also write and register a config parser to translate that format; see Locating a Parser below.) By Application Directive Your application can specify what media type to use in interpreting a config source. Use this if your application knows the media type but the system might not be able to infer it correctly, either because no type detector would recognize it or because there might be more than one inferred media type. <markup lang=\"java\" title=\"Specify mediaType for config source\" >Config config = Config.create(classpath(\"props\") .mediaType(\"text/x-java-properties\")); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the media type explicitly. Note that a file type detector could be written to also inspect the contents of the file to infer the media type. The detector which the config system provides looks only for the .properties file type in the path. Locating a Parser By Inference from media-type Each config parser reports which media types it handles. Once the config system has determined a source&#8217;s media type, it searches the config parsers associated with the config builder for one that recognizes that media type. It then uses that parser to translate the config in the source into the in-memory config tree. The application can add one or more parsers to a Config.Builder using the addParser method. This makes the parser available for use by the config sources associated with that builder, but does not directly tie a given parser to a given source. The builder uses media-type matching to select one of the parsers registered with the builder for each source. If the config system cannot locate a parser that matches the media type of a source, it throws a ConfigException when trying to prepare the configuration. By Application Directive Your application can specify which parser to use for a config source. The AbstractParsableConfigSource.Builder class exposes the parser method, which accepts the ConfigParser to be used for that source. Several methods on ConfigSources such as classpath , directory , and file return this builder class. Generally try to rely on media-type matching rather than specifying a given parser for a given source in the application. This keeps your application more flexible, both by insulating it from implementation classes and by letting it easily take advantage of improvements in or alternatives to the parsers available for a given media type. <markup lang=\"java\" title=\"Specify parser for config source\" >Config config = Config.create(classpath(\"props\") .parser(ConfigParsers.properties())); The config system cannot infer the media type because there is no file type in the path props . The developer knows the file is in Java Properties format so specifies the properties parser explicitly. Parsing a Config Value as Config A config value node might contain an entire config document in String form, but in a format different from the containing document. Your application can tell the config system to parse such a node as config in a different format and replace the String value node in the original tree with the config tree that results from parsing that String . In this example, a YAML document contains a JSON document as a leaf. <markup lang=\"yaml\" title=\"YAML file with included JSON formated property\" >secrets: username: \"jose\" password: \"^ery$ecretP&amp;ssword\" app: &gt; { \"greeting\": \"Hello\", \"page-size\": 20, \"basic-range\": [ -20, 20 ] } The property app is itself formatted as a JSON document. Specify Key-to-media-type Mapping <markup lang=\"java\" title=\"Specify JSON as media type for node\" >Config config = Config.create( classpath(\"application.yaml\") .mediaTypeMapping( key -&gt; \"app\".equals(key.toString()) ? \"application/json\" : null)); assert config.get(\"secrets.username\").asString() .get().equals(\"jose\"); assert config.get(\"secrets.password\").asString() .get().equals(\"^ery$ecretP&amp;ssword\"); assert config.get(\"app\").type() == Type.OBJECT; assert config.get(\"app.greeting\") .asString().get().equals(\"Hello\"); assert config.get(\"app.page-size\") .asInt().get() == 20; assert config.get(\"app.basic-range.0\") .asInt().get() == -20; assert config.get(\"app.basic-range.1\") .asInt().get() == 20; The source builder&#8217;s mediaTypeMapping method accepts a function which returns the appropriate media types (if any) for config keys. The function says to treat the app property value as a JSON document and leave other nodes unchanged. Other properties are loaded as expected. Property app is now an structured object node. Because the function passed to mediaTypeMapping identifies the app node as a JSON document, the config system selects the config parser that is registered with the builder which also handles the JSON media type. Also, note that the config system replaces the original String value node with an object node resulting from parsing that String value as JSON. Specify Key-to-parser Mapping Alternatively, your application could map config keys to the specific parsers you want to use for parsing those keys' values. <markup lang=\"java\" title=\"Specify JSON formatted property' parser instance\" >Config config = Config.create( ConfigSources.classpath(\"application.yaml\") .parserMapping( key -&gt; \"app\".equals(key.toString()) ? HoconConfigParserBuilder.buildDefault() : null)); Uses the parserMapping method to map keys to parser instances. Tells the config system to use the HOCON parser for translating the String value of the app key. (HCON is a superset of JSON.) As before, the config system replaces the value node in the containing config tree with the config tree resulting from the additional parse. Loading Config using Meta-configuration Instead of including code in your application to construct config trees from builders, sources, etc., you can instead prepare meta-configuration in a file that declares the sources to load and their attributes. You can either specify the meta-config file in your application or allow the config system to search for and load meta-config from a preset list of possible sources. Loading Config by Specifying a Meta-configuration File Your application loads the configuration specified by a meta-config file by: invoking the ConfigSources.load(Config) method, passing a config object read from the meta-config source as the argument; invoking the Config.loadSourcesFrom method, or invoking the Config.builderLoadSourceFrom method. These methods return either a Config tree or a Config.Builder which your application can further fine-tune before using to construct a Config tree. The config system interprets the meta-config as directions for how to build a config tree, rather than as the config data itself. Loading Config from an Implicit Meta-configuration File The introduction section shows how to use Config.create() to load config from one of several possible default config files. That same method also searches for one of several possible default meta-config files from which to load config sources to be used for the default config. The Config.create() method determines the default configuration from the following search: Attempt to load meta-config from at most one of the following, checked in this order: meta-config.yaml - meta configuration file in YAML format meta-config.conf - meta configuration file in HOCON format meta-config.json - meta configuration file in JSON format meta-config.properties - meta configuration file in Java Properties format Otherwise, load config from: environment variables, and Java system properties, and at most one of the following, checking in this order: application.yaml - configuration file in YAML format application.conf - configuration file in HOCON format application.json - configuration file in JSON format application.properties - configuration file in Java Properties format Remember that the config system will check for these default meta-config and config files only if the classpath includes the corresponding parsers. The introduction section on built-in formats section describes this further. Meta-configuration File Format Each meta-configuration file must contain the top-level sources property that is an array (ordered list) of config sources. The meta-config file can contain other top-level keys as well but the config system ignores them when it interprets the contents as meta-configuration. Each sources property must contain exactly one of following top level properties: Meta-configuration Required Top-level Property Property Name Usage type Either: a predefined type (see below ), or a custom config source ID class Fully-qualified class name of either: a custom config source implementation, or a builder class with a build() method that returns ConfigSource If you specify both type and class , the config system ignores the class setting. In addition, each sources property can optionally have a properties property which assigns type-specific attributes for the config source being defined. Built-in Types The config system supports these built-in types: Built-in Meta-configuration Types Type Use Related ConfigSources Method Required Properties system-properties System properties are a config source ConfigSources.systemProperties() n/a environment-variables Environment variables are a config source ConfigSources.environmentVariables() n/a classpath Specified resource is used as a config source ConfigSources.classpath(String) resource - path to the resource to load file Specified file is used as a config source ConfigSources.file(Path) path - path to the file to load directory Each file in directory used as config entry, with key = file name and value = file contents ConfigSources.directory(String) path - path to the directory to use url Specified URL is read as a config source ConfigSources.url(URL) url - URL from which to load the config prefixed Associated config source is loaded with the specified prefix ConfigSources.prefixed(String,Supplier) key - key of config element in associated source to load type or class - associated config source specification properties - as needed to further qualify the associated config source Except for the system-properties and environment-variables types, the meta-config properties section for a source can also specify any optional settings for the corresponding config source type. The JavaDoc for the related config source type builders lists the supported properties for each type. (For example, FileConfigSource.FileBuilder .) Here is example meta-configuration in HOCON format. Note how the properties sections are at the same level as the type or class within a sources array entry. <markup lang=\"hocon\" title=\"Meta-configuration config-meta-all.conf illustrating all built-in sources available on the classpath\" >sources = [ { type = \"environment-variables\" } { type = \"system-properties\" } { type = \"directory\" properties { path = \"conf/secrets\" media-type-mapping { yaml = \"application/x-yaml\" password = \"application/base64\" } polling-strategy { type = \"regular\" properties { interval = \"PT15S\" } } } } { type = \"url\" properties { url = \"http://config-service/my-config\" media-type = \"application/hocon\" optional = true retry-policy { type = \"repeat\" properties { retries = 3 } } } } { type = \"file\" properties { path = \"conf/env.yaml\" polling-strategy { type = \"watch\" } } } { type = \"prefixed\" properties { key = \"app\" type = \"classpath\" properties { resource = \"app.conf\" } } } { type = \"classpath\" properties { resource = \"application.conf\" } } ] Note that the example shows how your meta-configuration can configure optional features such as polling strategies and retry policies for config sources. Meta-config for Custom Source Types You can use meta-config to set up custom config source types as well as the built-in ones described above. Meta-config supports this in two ways: by class name by custom type name Custom Source Types using class Use the class property in one of your sources entries and as its value give the fully-qualified class name of your custom source type. The config system will use that class as the ConfigSource (or as a builder for one) for that source. <markup lang=\"hocon\" >{ class = \"io.helidon.config.git.GitConfigSourceBuilder\" properties { path = \"application.conf\" directory = \"/app-config\" } } Custom Source Type using type You can add your own custom type names to the built-in ones by adding to a META-INF/resources/meta-config-sources.properties file on the classpath. In this file each property name is a custom config source type name and its value is the fully-qualified class name for a custom ConfigSource implementation or a builder for it. For example, the Helidon module helidon-config-git provides this META-INF/resources/meta-config-sources.properties file: <markup title=\"Definition of git Config Source Type\" >git = io.helidon.config.git.GitConfigSourceBuilder This definition lets you configure a git config source in meta-configuration as follows: <markup lang=\"hocon\" >{ type = \"git\" properties { path = \"application.conf\" directory = \"/app-config\" } } You can define and use your own custom config source type names similarly. Note that it is the AbstractSource SPI class that provides support for polling strategies and retry policies. If you create custom config sources that should also offer this support be sure they extend AbstractSource or one of its subclasses to inherit this behavior. Loading Config using Meta-configuration Here is how your application can use meta-configuration in a particular resource on the classpath to load a Config tree: <markup lang=\"java\" title=\"Loading Config using Meta-configuration\" >ConfigSource sourceFromMetaConfig = ConfigSources.load( classpath(\"config-meta-all.conf\")).build(); Config config = Config.create(sourceFromMetaConfig); The ConfigSources.load method creates a config source for the eventual config from the config source argument which specifies the meta-config. This example uses meta-config from a resource on the classpath but you can use meta-config from any valid config source. The load method populates the sourceFromMetaConfig ConfigSource from all the actual sources declared in the meta-configuration. The returned ConfigSource is ready for use in creating a Config instance. Meta-config for Polling Strategies and Retry Policies Your meta-config can include the set-up for polling strategies and retry policies if the config source supports them. Declare them in a way similar to how you declare the config sources themselves: by type or class and with accompanying properties . Meta-config Support for Built-in Polling Strategies Strategy Type Usage Properties regular Periodic polling - See PollingStrategies.regular method interval ( Duration ) - indicating how often to poll; e.g., PT15S represents 15 seconds watch Filesystem monitoring - See PollingStrategies.watch method path - file system path to the classpath , file , or directory to monitor Meta-config Support for Built-in Retry Policies Policy Type Usage Properties repeat Regularly-scheduled - see RetryPolicies.repeat . retries ( int ) - number of retries to perform Optional: delay ( Duration ) - initial delay between retries delay-factor ( double ) - delay is repeatedly multiplied by this each retry to compute the delay for each successive retry call-timeout ( Duration ) - timeout for a single invocation to load the source overall-timeout ( Duration ) - total timeout for all retry calls and delays To specify a custom polling strategy or custom retry policy, specify class (instead of type ) and give the fully-qualified class name for the implementation class. If your custom class needs parameters to control its behavior the config system uses io.helidon.config.ConfigMapper to initialize the class instance. See RetryPolicy and PollingStrategy JavaDoc sections. ",
            "title": "Advanced Config Sources and Config Parsers"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " As described in the hierarchical features section each config node (except the root) has a non-null key. Here is the formal definition of what keys can be: <markup lang=\"abnf\" title=\"The ABNF syntax of config key\" >config-key = *1( key-token *( \".\" key-token ) ) key-token = *( unescaped / escaped ) unescaped = %x00-2D / %x2F-7D / %x7F-10FFFF ; %x2E ('.') and %x7E ('~') are excluded from 'unescaped' escaped = \"~\" ( \"0\" / \"1\" ) ; representing '~' and '.', respectively Important To emphasize, the dot character (&#8220;.&#8221;) has special meaning as a name separator in keys. To include a dot as a character in a key escape it as &#8220;~1&#8221;. To include a tilda escape it as &#8220;~0&#8221;. For example, the following configuration file contains two object nodes with names oracle and oracle.com . <markup lang=\"json\" title=\"Example application.json with dot character in key\" >{ \"oracle\" : { \"com\" : true, \"cz\" : false }, \"oracle.com\" : { \"secured\" : true } } <markup lang=\"java\" title=\"Working with configuration with dot character in node name\" >Config config = Config.create(classpath(\"application.json\")); // node `oracle` assert config.get(\"oracle.com\").asBoolean().get() == true; assert config.get(\"oracle\").get(\"com\").asBoolean().get() == true; assert config.get(\"oracle.com\").type() == Type.VALUE; assert config.get(\"oracle.com\").name().equals(\"com\"); // node `oracle.com` assert config.get(\"oracle~1com.secured\").asBoolean().get() == true; assert config.get(Key.escapeName(\"oracle.com\")) .get(\"secured\").asBoolean().get() == true; assert config.get(Key.escapeName(\"oracle.com\")).type() == Type.OBJECT; assert config.get(Key.escapeName(\"oracle.com\")).name().equals(\"oracle.com\"); Work with the first oracle object as usual. As always you can use the fully-qualified key oracle.com or chain get(key) calls to access the com property value. Config node \"oracle\" / \"com\" is a leaf node (has type VALUE )&#8230;&#8203; &#8230;&#8203; and has the name com (the last token in its key). The second object has name oracle.com . The code must escape the dot in the node&#8217;s name using oracle~1com . Or, use the utility method Config.Key.escapeName(name) to escape dots or tildes that might be in the node&#8217;s name, in this example in oracle.com . The config node \"oracle.com\" has type OBJECT &#8230;&#8203; &#8230;&#8203;and name \"oracle.com\" . ",
            "title": "Configuration Key"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Each filter accepts a key and the value as defined in the source, and returns the value to be used. The filter can leave the value unchanged or alter it, as it sees fit. The built-in value-resolving filter enables the token substitution described below. See the ConfigFilter JavaDoc for more information. ",
            "title": "Filters"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The overrides feature allows you to create an external document containing key/value pairs which replace the value otherwise returned for the name, and then add that document as an override source to a config builder. There are some key differences between overrides and filters. Because overrides are loaded from sources those sources can change while your application runs and so the overrides they that prescribe can change. The override document can use wildcards in key expressions. Overrides can affect only keys that already exist in the original source; filters can supply values even if the key is absent from the config source. Each override entry consists of a Java properties-format definition. The key is an expression (which can use wildcards) to match config keys read from the current config sources, and the override value is the new value for any key matching the key expression from that entry. Order is important. The config system tests every key expression/value pair one by one in the order they appear in the overrides sources. Once the config system finds an override entry in which the key expression matches the configuration key, the system returns that entry&#8217;s value for the key being processed. See the OverrideSource JavaDoc for more detail. ",
            "title": "Overrides"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " A token reference is a key token starting with $ , optionally enclosed between { and } , i.e. $ref , ${ref} . Even a key composed of more than one token can be referenced in another key, i.e. ${env.ref} . As an example use case, you can use token references to declare the default values (see resolving-tokens.yaml below), while the references may be resolved in another config source, which identifies a current environment (see env.yaml examples below). You can then use the same overrides for different environments, say test and prod . The configuration in each environment is then overridden with a different values using wildcards (see overrides.properties below). <markup lang=\"java\" title=\"Initialize Config with Override Definition from overrides.properties file\" >Config config = Config.builder() .overrides(OverrideSources.file(\"conf/overrides.properties\")) .sources(file(\"conf/env.yaml\"), classpath(\"resolving-tokens.yaml\")) .build(); Loads overrides from the specified file. A deployment-specific environment configuration file. A default configuration containing token references that are resolved using the environment-specific override. ",
            "title": "Tokens"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " When your application retrieves a config value, the config system can transform it before returning the value, according to filters , overrides , and tokens . The config system provides some built-in instances of these you can use, and you can add your own as described in the sections which describe filters and overrides . Your application can add filters and overrides explicitly to a config builder and the config system by default uses the Java service loader mechanism to locate all available filters and overrides and add them automatically to all config builders (unless your code disables that behavior for a given builder). Filters Each filter accepts a key and the value as defined in the source, and returns the value to be used. The filter can leave the value unchanged or alter it, as it sees fit. The built-in value-resolving filter enables the token substitution described below. See the ConfigFilter JavaDoc for more information. Overrides The overrides feature allows you to create an external document containing key/value pairs which replace the value otherwise returned for the name, and then add that document as an override source to a config builder. There are some key differences between overrides and filters. Because overrides are loaded from sources those sources can change while your application runs and so the overrides they that prescribe can change. The override document can use wildcards in key expressions. Overrides can affect only keys that already exist in the original source; filters can supply values even if the key is absent from the config source. Each override entry consists of a Java properties-format definition. The key is an expression (which can use wildcards) to match config keys read from the current config sources, and the override value is the new value for any key matching the key expression from that entry. Order is important. The config system tests every key expression/value pair one by one in the order they appear in the overrides sources. Once the config system finds an override entry in which the key expression matches the configuration key, the system returns that entry&#8217;s value for the key being processed. See the OverrideSource JavaDoc for more detail. Tokens A token reference is a key token starting with $ , optionally enclosed between { and } , i.e. $ref , ${ref} . Even a key composed of more than one token can be referenced in another key, i.e. ${env.ref} . As an example use case, you can use token references to declare the default values (see resolving-tokens.yaml below), while the references may be resolved in another config source, which identifies a current environment (see env.yaml examples below). You can then use the same overrides for different environments, say test and prod . The configuration in each environment is then overridden with a different values using wildcards (see overrides.properties below). <markup lang=\"java\" title=\"Initialize Config with Override Definition from overrides.properties file\" >Config config = Config.builder() .overrides(OverrideSources.file(\"conf/overrides.properties\")) .sources(file(\"conf/env.yaml\"), classpath(\"resolving-tokens.yaml\")) .build(); Loads overrides from the specified file. A deployment-specific environment configuration file. A default configuration containing token references that are resolved using the environment-specific override. ",
            "title": "Filter, Overrides, and Token Substitution"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " The two methods PollingStrategies.regular(Duration) and PollingStrategies.watch(Path) return builders for their respective strategies. Both builders expose the executor method which your application can invoke, passing a java.util.concurrent.ScheduledExecutorService instance it wants used for the polling work. By default each polling strategy instance uses a separate thread pool executor. The following example shares the same executor for two different polling strategy instances. <markup lang=\"java\" title=\"Customize polling strategy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); Config config = Config.create( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy( PollingStrategies.regular(Duration.ofSeconds(2)) .executor(executor)), ConfigSources.create(\"conf/config.properties\") .pollingStrategy( path -&gt; PollingStrategies.watch(path) .executor(executor))); Prepares a thread pool executor with core pool size set 2 to be shared by all polling strategies. Selects the built-in periodic polling strategy. Tells the config system to use the specific executor to poll the dev.properties config source. Uses the Java filesystem WatchService to monitor the specified path. Tells the config system to use the same executor to monitor the path. ",
            "title": "Executors for Polling Strategy"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Recall that when a polling strategy detects a change in a source, it informs interested parties of the changes. By default each Config.Builder arranges for the resulting Config tree to use a shared executor that reuses available threads from a pool, creating new threads as needed. The same executor is used for actually reloading the source. Your application can invoke the polling strategy builder&#8217;s changesExecutor method to tell the builder to use a different Executor . (As an aside, your application can also control the size of the buffer used for holding source change events by invoking the builder&#8217;s changesMaxBuffer method. The default is 256.) <markup lang=\"java\" title=\"Customize config and override sources' executors\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.builder() .overrides( OverrideSources.file(\"conf/overrides.properties\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .sources( ConfigSources.file(\"conf/env.yaml\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .build(); Prepares a thread pool executor to be shared by selected sources. Tells the builder that the resulting overrides source should use the specified Executor for notifying interested parties of changes and for reloading the override source. Specifies an event buffer size of 4. Uses the same Executor and event buffer size for the config source as for the override source above. ",
            "title": "Publishers for Source Change Events"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " When your application supplies multiple sources to a config builder, as with Config.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and Config.create(List&lt;Supplier&lt;ConfigSource&gt;&gt;) , the config system automatically uses a composite config source which aggregates the separate sources but also listens for changes to any of the individual sources so it can delegate the change notification. For this change detection and notification the config system, by default, uses an executor with a dedicated thread pool that is shared across all Config instances. Your application can invoke the builder&#8217;s changesExecutor method to use a different ScheduledExecutorService instance. The builder returned by the from methods mentioned above is a CompositeBuilder which extends Config.Builder . Because a composite source might yield more numerous change events&#8201;&#8212;&#8201;because of the multiple underlying sources&#8201;&#8212;&#8201;your application can specify a debounce timeout for the composite source by invoking the CompositeBuilder.changesDebounce(Duration) method. The composite source aggregates multiple change events within this period into a single event and broadcasts that one instead and reloads the sources at that time, not necessarily in response to every single change in any source. The default is 100 milliseconds. <markup lang=\"java\" title=\"Customize composite source executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); Config config = Config.create( ConfigSources.create(file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies::watch), file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(4) .changesDebounce(Duration.ofSeconds(1))); Prepares a thread pool executor. ConfigSources.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) creates and returns a CompositeBuilder based on the two sources. Specifies a particular executor for monitoring and change event notification. Sets the subscriber&#8217;s buffer size to 4 events. The composite source discards any events not consumed by a subscriber if it needs to create room for more recent events. Change events will not fire more frequently than once per a second. ",
            "title": "Composite Config Source Executor"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " A loaded config tree subscribes to change events publishes by its source(s). By default, each Config uses an executor which manages a dedicated thread pool reusing previously-created threads when they are available and creating new threads as needed. All Config instances share the dedicated thread pool. Your application can specify a non-default Executor for a tree to use for accepting and propagating those events by invoking the changesExecutor method on the Config.Builder . Each source subscriber has a dedicated buffer for holding changes events. This defaults to 256 but you can tailor this value as needed. <markup lang=\"java\" title=\"Customize config executor\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.create( file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(16) .build(); Prepares a specific thread pool executor. Specifies the executor the Config tree will use to listen for and propagate change events. Sets the event subscriber buffer to 16 events. ",
            "title": "Config Custom Executor"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " You can control which executor a retry policy should use for its work. The RetryPolicies.repeat(int retries) method returns a RetryPolicies.Builder . Your application can invoke the retry policy builder&#8217;s executor method to specify which ScheduledExecutorService instance it should use to schedule and execute delayed retries. By default the config system uses a separate thread pool executor for each retry policy instance. <markup lang=\"java\" title=\"Customize retry policy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2, myThreadFactory); Config config = Config.create( ConfigSources.file(\"conf/dev.properties\") .optional() .retryPolicy(RetryPolicies.repeat(2) .executor(executor))); Prepares a thread pool executor with core pool size set to 2 and a custom java.util.concurrent.ThreadFactory . When the source is flagged as optional() , the loading attempt will be repeated as the retry policy defines, but an overall failure will not lead to failing the initial load or preventing the source from being polled if so configured. Uses the built-in repeating implementation of RetryPolicy that can be used with any config source, but typically for ones that might suffer brief, intermittent outages. Specifies the executor to use for loading and retries. ",
            "title": "Retry Policy Custom Executor"
        },
        {
            "location": "/config/06_advanced-configuration",
            "text": " Various parts of the config system work asychronously: polling strategies to detect changes to config sources, publishers to notify your application when such changes occur, Config instances which subscribe to and respond to change notifications for their underlying sources, and retry policies (which might wait between retries). Each of these uses an executor to perform its work. The config system provides default executors, but your application can specify different ones if necessary. Executors for Polling Strategy The two methods PollingStrategies.regular(Duration) and PollingStrategies.watch(Path) return builders for their respective strategies. Both builders expose the executor method which your application can invoke, passing a java.util.concurrent.ScheduledExecutorService instance it wants used for the polling work. By default each polling strategy instance uses a separate thread pool executor. The following example shares the same executor for two different polling strategy instances. <markup lang=\"java\" title=\"Customize polling strategy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); Config config = Config.create( ConfigSources.file(\"conf/dev.properties\") .pollingStrategy( PollingStrategies.regular(Duration.ofSeconds(2)) .executor(executor)), ConfigSources.create(\"conf/config.properties\") .pollingStrategy( path -&gt; PollingStrategies.watch(path) .executor(executor))); Prepares a thread pool executor with core pool size set 2 to be shared by all polling strategies. Selects the built-in periodic polling strategy. Tells the config system to use the specific executor to poll the dev.properties config source. Uses the Java filesystem WatchService to monitor the specified path. Tells the config system to use the same executor to monitor the path. Publishers for Source Change Events Recall that when a polling strategy detects a change in a source, it informs interested parties of the changes. By default each Config.Builder arranges for the resulting Config tree to use a shared executor that reuses available threads from a pool, creating new threads as needed. The same executor is used for actually reloading the source. Your application can invoke the polling strategy builder&#8217;s changesExecutor method to tell the builder to use a different Executor . (As an aside, your application can also control the size of the buffer used for holding source change events by invoking the builder&#8217;s changesMaxBuffer method. The default is 256.) <markup lang=\"java\" title=\"Customize config and override sources' executors\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.builder() .overrides( OverrideSources.file(\"conf/overrides.properties\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .sources( ConfigSources.file(\"conf/env.yaml\") .pollingStrategy(PollingStrategies::watch) .changesExecutor(executor) .changesMaxBuffer(4)) .build(); Prepares a thread pool executor to be shared by selected sources. Tells the builder that the resulting overrides source should use the specified Executor for notifying interested parties of changes and for reloading the override source. Specifies an event buffer size of 4. Uses the same Executor and event buffer size for the config source as for the override source above. Composite Config Source Executor When your application supplies multiple sources to a config builder, as with Config.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) and Config.create(List&lt;Supplier&lt;ConfigSource&gt;&gt;) , the config system automatically uses a composite config source which aggregates the separate sources but also listens for changes to any of the individual sources so it can delegate the change notification. For this change detection and notification the config system, by default, uses an executor with a dedicated thread pool that is shared across all Config instances. Your application can invoke the builder&#8217;s changesExecutor method to use a different ScheduledExecutorService instance. The builder returned by the from methods mentioned above is a CompositeBuilder which extends Config.Builder . Because a composite source might yield more numerous change events&#8201;&#8212;&#8201;because of the multiple underlying sources&#8201;&#8212;&#8201;your application can specify a debounce timeout for the composite source by invoking the CompositeBuilder.changesDebounce(Duration) method. The composite source aggregates multiple change events within this period into a single event and broadcasts that one instead and reloads the sources at that time, not necessarily in response to every single change in any source. The default is 100 milliseconds. <markup lang=\"java\" title=\"Customize composite source executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); Config config = Config.create( ConfigSources.create(file(\"conf/dev.properties\") .pollingStrategy(PollingStrategies::watch), file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(4) .changesDebounce(Duration.ofSeconds(1))); Prepares a thread pool executor. ConfigSources.create(Supplier&lt;ConfigSource&gt;&#8230;&#8203;) creates and returns a CompositeBuilder based on the two sources. Specifies a particular executor for monitoring and change event notification. Sets the subscriber&#8217;s buffer size to 4 events. The composite source discards any events not consumed by a subscriber if it needs to create room for more recent events. Change events will not fire more frequently than once per a second. Config Custom Executor A loaded config tree subscribes to change events publishes by its source(s). By default, each Config uses an executor which manages a dedicated thread pool reusing previously-created threads when they are available and creating new threads as needed. All Config instances share the dedicated thread pool. Your application can specify a non-default Executor for a tree to use for accepting and propagating those events by invoking the changesExecutor method on the Config.Builder . Each source subscriber has a dedicated buffer for holding changes events. This defaults to 256 but you can tailor this value as needed. <markup lang=\"java\" title=\"Customize config executor\" >Executor executor = Executors.newCachedThreadPool(); Config config = Config.create( file(\"conf/config.properties\") .pollingStrategy(PollingStrategies::watch)) .changesExecutor(executor) .changesMaxBuffer(16) .build(); Prepares a specific thread pool executor. Specifies the executor the Config tree will use to listen for and propagate change events. Sets the event subscriber buffer to 16 events. Retry Policy Custom Executor You can control which executor a retry policy should use for its work. The RetryPolicies.repeat(int retries) method returns a RetryPolicies.Builder . Your application can invoke the retry policy builder&#8217;s executor method to specify which ScheduledExecutorService instance it should use to schedule and execute delayed retries. By default the config system uses a separate thread pool executor for each retry policy instance. <markup lang=\"java\" title=\"Customize retry policy executors\" >ScheduledExecutorService executor = Executors.newScheduledThreadPool(2, myThreadFactory); Config config = Config.create( ConfigSources.file(\"conf/dev.properties\") .optional() .retryPolicy(RetryPolicies.repeat(2) .executor(executor))); Prepares a thread pool executor with core pool size set to 2 and a custom java.util.concurrent.ThreadFactory . When the source is flagged as optional() , the loading attempt will be repeated as the retry policy defines, but an overall failure will not lead to failing the initial load or preventing the source from being polled if so configured. Uses the built-in repeating implementation of RetryPolicy that can be used with any config source, but typically for ones that might suffer brief, intermittent outages. Specifies the executor to use for loading and retries. ",
            "title": "Executors for Asynchronous Config Activity"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " The config system represents configuration as a tree in memory. Many developers will choose to work directly with config values&#8201;&#8212;&#8201;values from the leaves in the tree&#8201;&#8212;&#8201;accessing them by their keys. You can also navigate explicitly among the nodes of the tree without using keys. This section describes what the tree looks like and how you can traverse it. ",
            "title": "preambule"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " The config system represents configuration in memory using three types of nodes, each a different interface defined within the ConfigNode interface. ConfigNode Types Type Java Interface Usage object ConfigNode.ObjectNode Represents complex structure (a subtree). Its child nodes can be of any type. list ConfigNode.ListNode Represents a list of nodes. Its components can be of any type. value ConfigNode.ValueNode Represents a leaf node. A node of any type can have a String value. Each config tree in memory will have an object node as its root with child nodes as dictated by the source config data from which the config system built the tree. Missing Config Nodes If your application attempts to access a non-existent node, for example using <markup lang=\"java\" >config.get(\"key.does.not.exist\") the config system returns a Config node object with type MISSING . The in-memory config tree contains nodes only of types OBJECT , LIST , and VALUE . ",
            "title": "Configuration Node Types"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " The following example is in HOCON (human-optimized config object notation) format. The config system supports HOCON as an extension module . <markup lang=\"hocon\" title=\"HOCON application.conf file\" >app { greeting = \"Hello\" page-size = 20 basic-range = [ -20, 20 ] } data { providers: [ { name = \"Provider1\" class = \"this.is.my.Provider1\" }, { name = \"Provider2\" class = \"this.is.my.Provider2\" } ] } The diagram below illustrates the in-memory tree for that configuration. Config Nodes structure of application.conf file Notes Each non-root node has a name which distinguishes it from other nodes with the same parent. The interpretation of the name depends on the node type. Node Type Name object value member name of the node within its parent list element index of the node within the containing list Each node&#8217;s key is the fully-qualified path using dotted names from the root to that node. The root has an empty key, empty name, and no value. The Config object exposes methods to return the name , key , and type of the node. ",
            "title": "In-memory Representation of Configuration"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " For many applications, accessing configuration values by key will be the simplest approach. If you write the code with a specific configuration structure in mind, your code can retrieve the value from a specific configuration node very easily. Your application can specify the entire navigation path as the key to a single get invocation, using dotted notation to separate the names of the nodes along the path. The code can navigate one level at a time using chained get invocations, each specifying one level of the path to the expected node. Or, you can mix the two styles. All of the following lines retrieve the same Config node. <markup lang=\"java\" title=\"Equivalent Config Retrievals\" >assert config.get(\"\") == config; Config provName1 = config.get(\"data.providers.0.name\"); Config provName2 = config.get(\"data.providers.0\").get(\"name\"); Config provName3 = config.get(\"data.providers\").get(\"0.name\"); Config provName4 = config.get(\"data\").get(\"providers.0\").get(\"name\"); Config provName5 = config.get(\"data\").get(\"providers\").get(\"0\").get(\"name\"); using a single key mixed style (composite key and single key) navigating one level with each get invocation The Config.get(key) method always returns a Config object without throwing an exception. If the specified key does not exist the method returns a Config node of type MISSING . There are several ways your application can tell whether a given config value exists. Method Usage exists Returns true or false ifExists Execute functional operations for present nodes type Returns enum value for the Config.Type ; Config.Type.MISSING if the node represents a config value that does not exist as Returns the ConfigValue with the correct type that has all methods of Optional and a few additional ones - see javadoc link:./apidocs/index.html?io/helidon/config/ConfigValue.html The config system throws a MissingValueException if the application tries to access the value of a missing node by invoking the ConfigValue.get() method. ",
            "title": "Access by Key"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " Some applications might need to work with configuration without knowing its structure or key names ahead of time, and such applications can use various methods on the Config class to do this. General Config Node Methods Method Usage asNodeList() Returns a ConfigValue&lt;List&lt;Config&gt;&gt;. For nodes of type OBJECT contains child nodes as a List . hasValue() For any node reports if the node has a value. This can be true for any node type except MISSING . isLeaf() Reports whether the node has no child nodes. Leaf nodes have no children and has a single value. key() Returns the fully-qualified path of the node using dotted notation. name() Returns the name of the node (the last part of the key). asNode() Returns a ConfigValue&lt;Config&gt; wrapped around the node traverse() traverse(Predicate&lt;Config&gt;) Returns a Stream&lt;Config&gt; as an iterative deepening depth-first traversal of the subtree type() Returns the Type enum value for the node: OBJECT , LIST , VALUE , or MISSING <markup lang=\"java\" title=\"List names of child nodes of an object node\" >List&lt;String&gt; appNodeNames = config.get(\"app\") .asNodeList() .map(nodes -&gt; { return nodes .stream() .map(Config::name) .sorted() .collect(Collectors.toList()); }) .orElse(Collections.emptyList()); assert appNodeNames.get(0).equals(\"basic-range\"); assert appNodeNames.get(1).equals(\"greeting\"); assert appNodeNames.get(2).equals(\"page-size\"); Get the ConfigValue with child Config instances. Map the node list to names using the Java Stream API (if present) Use an empty list if the \"app\" node does not exist Check that the list contains the expected child names: basic-range , greeting and page-size . <markup lang=\"java\" title=\"List child nodes of a list node\" >List&lt;Config&gt; providers = config.get(\"data.providers\") .asNodeList().orElse(Collections.emptyList()); assert providers.get(0).key().toString().equals(\"data.providers.0\"); assert providers.get(1).key().toString().equals(\"data.providers.1\"); Get child nodes of the data.providers list node as a List of Config instances. Check that the list contains the expected child nodes with keys data.providers.0 and data.providers.1 . The traverse() method returns a stream of the nodes in the subtree that is rooted at the current configuration node. Depending on the structure of the loaded configuration the stream contains a mix of object, list or leaf value nodes. <markup lang=\"java\" title=\"Traverse subtree below a list node\" >config.get(\"data.providers\") .traverse() .forEach(node -&gt; System.out.println(node.type() + \" \\t\" + node.key())); Visit the subtree rooted at the data.providers list node. Prints out following list of nodes (type and key): OBJECT data.providers.0 VALUE data.providers.0.name VALUE data.providers.0.class OBJECT data.providers.1 VALUE data.providers.1.name VALUE data.providers.1.class The optional Predicate&lt;Config&gt; argument to the traverse methods allows the application to prune the traversal of a subtree at any point. <markup lang=\"java\" title=\"Traverse root ( object ) node, skipping the entire data subtree\" >config.traverse(node -&gt; !node.name().equals(\"data\")) .forEach(node -&gt; System.out.println(node.type() + \" \\t\" + node.key())); Visit all root sub-nodes, excluding whole data tree structure but including others. Prints out following list of nodes (type and key): OBJECT app VALUE app.page-size VALUE app.greeting LIST app.basic-range VALUE app.basic-range.0 VALUE app.basic-range.1 ",
            "title": "Access by General Navigation"
        },
        {
            "location": "/config/03_hierarchical-features",
            "text": " Sometimes it can be convenient to write part of your application to deal with configuration without it knowing if or where the relevant configuration is plugged into a larger config tree. For example, the application.properties from the introduction section contains several settings prefixed with web such as web.page-size . Perhaps in another config source the same information might be stored as server.web.page-size : <markup lang=\"java\" title=\"Alternate Structure for Web Config\" >server.web.page-size: 40 server.web.debug = true server.web.ratio = 1.4 You might want to write the web portion of your app to work with a config subtree with keys that are independent of the subtree&#8217;s position in a larger tree. This would allow you to reuse the web portion of your application without change, regardless of which structure a config source used. One easy way to do this is to detach a subtree from a larger config tree. When your application invokes the Config.detach method it gets back a copy of the config node but with no parent. The copy and the original node both point to the same objects for their child nodes (if any). The original node is unchanged. <markup lang=\"java\" title=\"Detaching a Subtree\" >Config originalRoot = // from the original example `.conf` file Config alternateRoot = // from the alternate structure above Config detachedFromOriginal = originalRoot.get(\"web\").detach(); Config detachedFromAlternate = alternateRoot.get(\"server.web\").detach(); assert originalRoot.get(\"web.debug\").equals(\"true\"); assert alternateRoot.get(\"server.web.debug\").equals(\"true\"); assert detachedFromOriginal.get(\"debug\").equals(\"true\"); assert detachedFromAlternate.get(\"debug\").equals(\"true\"); Navigation depends on knowing the full structure of the config and so is different for the two cases. Detaching so the web node is the root can use the same key regardless of where the config subtree came from. ",
            "title": "Detaching a Config Subtree"
        },
        {
            "location": "/microprofile/05_security",
            "text": " To add security, such as protecting resource methods with authentication, to a MicroProfile application, add the Helidon security integration dependency to your project. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/05_security",
            "text": " For web server static content, see Configuration Secrets. For JAX-RS resources, declare security by adding annotations to a resource class or method. <markup lang=\"java\" title=\"Protected resource method\" >@GET @io.helidon.security.annotations.Authenticated @io.helidon.security.annotations.Authorized // you can also use io.helidon.security.abac.role.RoleValidator.Roles @RolesAllowed(\"admin\") public String adminResource(@Context io.helidon.security.SecurityContext securityContext) { return \"you are \" + securityContext.getUser(); } Security in Helidon MicroProfile is built on top of Jersey&#8217;s and can be enabled/disabled using the property security.jersey.enabled=[true|false] . ",
            "title": "Securing a Web Resource"
        },
        {
            "location": "/microprofile/05_security",
            "text": "<markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.microprofile&lt;/groupId&gt; &lt;artifactId&gt;helidon-microprofile-security&lt;/artifactId&gt; &lt;/dependency&gt; Securing a Web Resource For web server static content, see Configuration Secrets. For JAX-RS resources, declare security by adding annotations to a resource class or method. <markup lang=\"java\" title=\"Protected resource method\" >@GET @io.helidon.security.annotations.Authenticated @io.helidon.security.annotations.Authorized // you can also use io.helidon.security.abac.role.RoleValidator.Roles @RolesAllowed(\"admin\") public String adminResource(@Context io.helidon.security.SecurityContext securityContext) { return \"you are \" + securityContext.getUser(); } Security in Helidon MicroProfile is built on top of Jersey&#8217;s and can be enabled/disabled using the property security.jersey.enabled=[true|false] . ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/09_jsonb-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.media.jsonb&lt;/groupId&gt; &lt;artifactId&gt;helidon-media-jsonb-server&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/09_jsonb-support",
            "text": " To enable JSON-B support, first create and register a JsonBindingSupport instance with a Routing.Builder . JsonBindingSupport is a Service , so it will install its own Handler that will provide serialization and deserialization services using Yasson , an implementation of the JSON-B specification . <markup lang=\"java\" title=\"Create and register JsonBindingSupport first\" >final JsonBindingSupport jsonBindingSupport = JsonBindingSupport.create(); final Routing.Builder routingBuilder = Routing.builder(); routingBuilder.register(jsonBindingSupport); Create a JsonBindingSupport instance. This instance may be reused freely. Register that JsonBindingSupport instance to enable automatic deserialization of Java objects from and serialization of Java objects to JSON. Now that automatic JSON serialization and deserialization facilities have been set up, you can register a Handler that works with Java objects instead of raw JSON. Deserialization from and serialization to JSON will be handled according to the JSON-B specification . Suppose you have a Person class that looks like this: <markup lang=\"java\" title=\"Hypothetical Person class\" >public class Person { private String name; public Person() { super(); } public String getName() { return this.name; } public void setName(final String name) { this.name = name; } } Then you can set up a Handler like this: <markup lang=\"java\" title=\"A Handler that works with Java objects instead of raw JSON\" >final Routing routing = routingBuilder.post(\"/echo\", Handler.create(Person.class, (req, res, person) -&gt; res.send(person)))) .build(); Set up a route for POST requests using the Routing.Builder#post(String, Handler&#8230;&#8203;) method Use the Handler#create(Class, Handler.EntityHandler) method to install a Handler.EntityHandler that works with Person instances. This Handler.EntityHandler consumes a Person instance ( person ) and simply echoes it back. Note that there is no working with raw JSON here. <markup lang=\"bash\" title=\"Example of posting JSON to the /echo endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/echo -d '{\"name\":\"Joe\"}' {\"name\":\"Joe\"} ",
            "title": "Usage"
        },
        {
            "location": "/webserver/09_jsonb-support",
            "text": " The WebServer supports the JSON-B specification . When this support is enabled, Java objects will be serialized to and deserialized from JSON automatically using Yasson , an implementation of the JSON-B specification . Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.media.jsonb&lt;/groupId&gt; &lt;artifactId&gt;helidon-media-jsonb-server&lt;/artifactId&gt; &lt;/dependency&gt; Usage To enable JSON-B support, first create and register a JsonBindingSupport instance with a Routing.Builder . JsonBindingSupport is a Service , so it will install its own Handler that will provide serialization and deserialization services using Yasson , an implementation of the JSON-B specification . <markup lang=\"java\" title=\"Create and register JsonBindingSupport first\" >final JsonBindingSupport jsonBindingSupport = JsonBindingSupport.create(); final Routing.Builder routingBuilder = Routing.builder(); routingBuilder.register(jsonBindingSupport); Create a JsonBindingSupport instance. This instance may be reused freely. Register that JsonBindingSupport instance to enable automatic deserialization of Java objects from and serialization of Java objects to JSON. Now that automatic JSON serialization and deserialization facilities have been set up, you can register a Handler that works with Java objects instead of raw JSON. Deserialization from and serialization to JSON will be handled according to the JSON-B specification . Suppose you have a Person class that looks like this: <markup lang=\"java\" title=\"Hypothetical Person class\" >public class Person { private String name; public Person() { super(); } public String getName() { return this.name; } public void setName(final String name) { this.name = name; } } Then you can set up a Handler like this: <markup lang=\"java\" title=\"A Handler that works with Java objects instead of raw JSON\" >final Routing routing = routingBuilder.post(\"/echo\", Handler.create(Person.class, (req, res, person) -&gt; res.send(person)))) .build(); Set up a route for POST requests using the Routing.Builder#post(String, Handler&#8230;&#8203;) method Use the Handler#create(Class, Handler.EntityHandler) method to install a Handler.EntityHandler that works with Person instances. This Handler.EntityHandler consumes a Person instance ( person ) and simply echoes it back. Note that there is no working with raw JSON here. <markup lang=\"bash\" title=\"Example of posting JSON to the /echo endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/echo -d '{\"name\":\"Joe\"}' {\"name\":\"Joe\"} ",
            "title": "JSON-B Support"
        },
        {
            "location": "/tracing/01_tracing",
            "text": " Declare the following dependency in your project to use the tracer abstraction: <markup lang=\"xml\" title=\"Tracer Abstraction\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.tracing&lt;/groupId&gt; &lt;artifactId&gt;helidon-tracing&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/tracing/01_tracing",
            "text": " To configure tracer with WebServer: <markup lang=\"java\" title=\"Configuring OpenTracing Tracer \" >ServerConfiguration.builder() .tracer(TracerBuilder.create(\"my-application\") .collectorUri(URI.create(\"http://10.0.0.18:9411\")) .build()) .build() The name of the application (service) to associate with the tracing events The endpoint for tracing events, specific to the tracer used, usually loaded from Config ",
            "title": "Configuring Tracing"
        },
        {
            "location": "/tracing/01_tracing",
            "text": " Helidon includes support for tracing through the OpenTracing APIs. Tracing is integrated with WebServer and Security. Support for specific tracers is abstracted. Your application can depend on the abstraction layer and provide a specific tracer implementation as a Java ServiceLoader service. Maven Coordinates Declare the following dependency in your project to use the tracer abstraction: <markup lang=\"xml\" title=\"Tracer Abstraction\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.tracing&lt;/groupId&gt; &lt;artifactId&gt;helidon-tracing&lt;/artifactId&gt; &lt;/dependency&gt; Configuring Tracing To configure tracer with WebServer: <markup lang=\"java\" title=\"Configuring OpenTracing Tracer \" >ServerConfiguration.builder() .tracer(TracerBuilder.create(\"my-application\") .collectorUri(URI.create(\"http://10.0.0.18:9411\")) .build()) .build() The name of the application (service) to associate with the tracing events The endpoint for tracing events, specific to the tracer used, usually loaded from Config ",
            "title": "Tracing Support"
        },
        {
            "location": "/guides/05_jib",
            "text": " This guide describes how to build container images for Helidon applications using Jib and Maven. ",
            "title": "preambule"
        },
        {
            "location": "/guides/05_jib",
            "text": " About 10 minutes Helidon Prerequisites ",
            "title": "What You Need"
        },
        {
            "location": "/guides/05_jib",
            "text": " Jib is a java tool chain for building Docker images for Java applications. It is integrated with Maven and Gradle and uses a distroless base image to produce small images. Jib does not require the docker command or the Docker daemon, there is no need to solve the Docker-in-Docker problem in order to build Docker images as part of your continuous integration. The docker command is only required for local usage when registering images in your local Docker registry. The example below shows how to build an image and register it in the local registry using the jib-maven-plugin . Add the following plugin declaration to your pom.xml: <markup lang=\"xml\" >&lt;plugin&gt; &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt; &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.10.1&lt;/version&gt; &lt;configuration&gt; &lt;to&gt; &lt;image&gt;jib-${project.artifactId}&lt;/image&gt; &lt;tags&gt; &lt;tag&gt;${project.version}&lt;/tag&gt; &lt;tag&gt;latest&lt;/tag&gt; &lt;/tags&gt; &lt;/to&gt; &lt;container&gt; &lt;!-- good defaults intended for containers --&gt; &lt;jvmFlags&gt; &lt;jmxFlag&gt;-server&lt;/jmxFlag&gt; &lt;jmxFlag&gt;-Djava.awt.headless=true&lt;/jmxFlag&gt; &lt;jmxFlag&gt;-XX:+UnlockExperimentalVMOptions&lt;/jmxFlag&gt; &lt;jmxFlag&gt;-XX:+UseCGroupMemoryLimitForHeap&lt;/jmxFlag&gt; &lt;jmxFlag&gt;-XX:InitialRAMFraction=2&lt;/jmxFlag&gt; &lt;jmxFlag&gt;-XX:MinRAMFraction=2&lt;/jmxFlag&gt; &lt;jmxFlag&gt;-XX:MaxRAMFraction=2&lt;/jmxFlag&gt; &lt;jmxFlag&gt;-XX:+UseG1GC&lt;/jmxFlag&gt; &lt;/jvmFlags&gt; &lt;mainClass&gt;${mainClass}&lt;/mainClass&gt; &lt;ports&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/ports&gt; &lt;/container&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;dockerBuild&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; By default, Jib uses distroless/java as the base image. You can override the default with configuration see the documentation <markup lang=\"bash\" title=\"Run the image\" >docker run --rm -p 8080:8080 jib-quickstart-se <markup lang=\"bash\" title=\"Ping the application\" >curl -X GET http://localhost:8080/greet <markup lang=\"bash\" title=\"Take a look at the image size\" >docker images jib-quickstart-se:latest <markup lang=\"bash\" >REPOSITORY TAG IMAGE ID CREATED SIZE jib-quickstart-se latest 384aebda5594 48 years ago 124MB Ignore the fact that it says the image was created 48 years ago. Refer to the Jib FAQ for explanations. the Jib image is smaller because of the use of a distroless base image. ",
            "title": "Creating a Docker Image Using Jib"
        },
        {
            "location": "/tracing/02_zipkin",
            "text": " Helidon is integrated with the Zipkin tracer. The Zipkin builder is loaded through ServiceLoader and configured. You could also use the Zipkin builder directly, though this would create a source-code dependency on the Zipkin tracer. ",
            "title": "preambule"
        },
        {
            "location": "/tracing/02_zipkin",
            "text": " To use Zipkin as a tracer, add the following dependency to your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.tracing&lt;/groupId&gt; &lt;artifactId&gt;helidon-tracing-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/tracing/02_zipkin",
            "text": " The Zipkin tracer supports the following configuration options: Key Default value Builder method Description service N/A serviceName Name of the service, to distinguish traces crossing service boundaries; Zipkin is using lower-case only, name will be automatically lower-cased protocol http collectorProtocol Protocol of the Zipkin trace collector (http or https) host localhost collectorHost Host of the Zipkin trace collector (IP Address, hostname, or FQDN) port 9411 collectorPort Port of the Zipkin trace collector path defined by version collectorPath Path of the Zipkin trace collector, each version uses a different path by default. api-version 2 version Zipkin specific method, set the protocol version to communicate with trace collector enabled true enabled If set to false, tracing would be disabled tags N/A addTracerTag(String, String) String tags to add to each span boolean-tags N/A addTracerTag(String, boolean) boolean tags to add to each span int-tags N/A addTracerTag(String, int) int tags to add to each span The following is an example of a Zipkin configuration, specified in the YAML format. <markup lang=\"yaml\" >tracing: zipkin: service: \"helidon-service\" protocol: \"https\" host: \"192.168.1.1\" port: 9987 api-version: 1 # this is the default path for API version 1 path: \"/api/v1/spans\" tags: tag1: \"tag1-value\" tag2: \"tag2-value\" boolean-tags: tag3: true tag4: false int-tags: tag5: 145 tag6: 741 Example of Zipkin trace: ",
            "title": "Configuring Zipkin"
        },
        {
            "location": "/microprofile/04_static-content",
            "text": " You can serve static content from a location in a file system or from the classpath. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/04_static-content",
            "text": "<markup lang=\"properties\" title=\"META-INF/microprofile-config.properties - File system static content\" ># Location of content on file system server.static.path.location=/var/www/html # default is index.html server.static.classpath.welcome=resource.html # static content path - default is \"/\" # server.static.classpath.context=/static-file <markup lang=\"properties\" title=\"META-INF/microprofile-config.properties - Classpath static content\" ># src/main/resources/WEB in your source tree server.static.classpath.location=/WEB # default is index.html server.static.classpath.welcome=resource.html # static content path - default is \"/\" # server.static.classpath.context=/static-cp ",
            "title": "Serving Static Content"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Configuration can be loaded from different types of locations and expressed in different formats. This section describes how your application can use config sources and config parsers together to load configuration data. ",
            "title": "preambule"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Each config source reads data from a location of a specific type, without regard to the format of the config data there. Each config parser converts data expressed in a particular format into the in-memory config data structure that the rest of the config system uses, without any concern for where that data resides or how it is physically retrieved. These two work together to prepare data in a given format at a given location for the config system. When your application prepares a Config.Builder it sets what ConfigSource s and ConfigParser s the builder should use in constructing the resulting Config object. ",
            "title": "Overview"
        },
        {
            "location": "/config/02_config-sources",
            "text": " If your application uses the default configuration, then the config system automatically sets up the config sources for you, as described in the config introduction . If instead your application uses a Config.Builder , then it can invoke one of the sources methods on that builder to set which config sources it should use. The config system includes support for several types of config sources, for example: a resource on the runtime classpath, environment variables, a file, Java system properties, a URL, a variety of in-memory data structures ( String , Map , Properties ) See the JavaDoc for the ConfigSources class for a complete list of the built-in config source types and how to use them. You can also extend the config system to handle other types of sources by implementing the ConfigSource interface. See the extensions documentation for complete information. See the advanced topics page for further information on some more involved aspects of config sources. ",
            "title": "Config Sources"
        },
        {
            "location": "/config/02_config-sources",
            "text": " When it reads configuration text from sources, the config system uses config parsers to translate that text into the in-memory data structures representing that configuration. The config system includes several built-in parsers, such as for the Java properties, YAML, JSON, and HOCON formats. See this section in the introduction for how to change your pom.xml to make parsers for those formats available to your application. Then your application can invoke the config builder&#8217;s addParser method so that builder will use the parsers you choose. You can extend the system with custom parsers of your own. Implement the ConfigParser interface, then construct a Config.Builder using the addParser method, passing an instance of your customer parser. Invoke one of the sources methods to include a source that uses the custom format and then build the Config object. ",
            "title": "Config Parsers"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Each Config object which the config system returns to your application is immutable; even if the information in one of the underlying config sources changes, an in-memory data structure built from the earlier content remains unchanged. Even so, the config system allows your application to learn when such underlying changes in the data occur and respond accordingly. The mutability section explains this in detail, and the PollingStrategies JavaDoc describes the built-in implementations. You can, of course, write your own by implementing the PollingStrategy interface. On a config source builder invoke pollingStrategy with an instance of your custom strategy and then invoke build to create the ConfigSource . ",
            "title": "Detecting and Responding to Changes in Config Data"
        },
        {
            "location": "/config/02_config-sources",
            "text": " Config sources, especially those that depend on fallible mechanisms such as the network or a shared file system, might fail to load during momentary outages. The config system allows you to build resiliency into your application&#8217;s use of configuration that relies on such technologies. When your application builds a ConfigSource it can specify a retry policy . When the config system needs to load data from that source it delegates the load operation to that retry policy. That policy is responsible not only for loading the data but also for detecting errors during loading and implementing the algorithm for deciding when and how many times to retry a failed load before reporting a failure back to your application. The config system includes two predefined retry policies: Predefined Retry Policies Policy Summary \"just call\" (default) asks the config source to load the data with no retry \"repeat\" performs a settable number of time-based retries, reporting failure only after all available retries have failed See the RetryPolicies JavaDoc for complete details on these built-in retry policies. You can devise your own policy. Implement the RetryPolicy interface. Then pass an instance of your policy implementation to the config source builder&#8217;s retryPolicy method. ",
            "title": "Dealing with Loading Errors: Retry Policies"
        },
        {
            "location": "/guides/04_dockerfile",
            "text": " This guide describes how to create a Docker image for your Helidon application, using a Java 8 base image or a custom Java 11 JRE built with jlink . ",
            "title": "preambule"
        },
        {
            "location": "/guides/04_dockerfile",
            "text": " About 10 minutes Helidon Prerequisites You&#8217;ll also need Java 11 if you want to create custom JRE&#8217;s using jlink ",
            "title": "What You Need"
        },
        {
            "location": "/guides/04_dockerfile",
            "text": " The Helidon team recommends setting-up the class-path inside the META-INF/MANIFEST.MF file with the Class-Path entry pointing to dependency jar files in a co-located lib directory. See the Maven and Gradle examples for more details on how to package your Helidon application. This approach is a good fit for Docker images: the application code and dependencies can be separate image layers. the image layer containing your dependencies is re-built only when dependencies are updated. the deployment environment(s) pull the images layer containing your dependencies only when changed. Why no fat jars? Fat Jars are jar files that contain the application and its dependencies ; they are not optimal for Docker images as it results in a single image layer. ",
            "title": "Java Packaging"
        },
        {
            "location": "/guides/04_dockerfile",
            "text": " This section describes the Dockerfile provided by the quickstarts . The Dockerfile is located at src/main/docker/Dockerfile and contains the following: <markup lang=\"yaml\" >FROM openjdk:8-jre-slim RUN mkdir /app COPY libs /app/libs COPY ${project.artifactId}.jar /app CMD [\"java\", \"-jar\", \"/app/${project.artifactId}.jar\"] The base image is the Java 8 JRE image provided by the OpenJDK project. First, the application dependencies are copied to /app . Then, the application jar file is copied to /app . The command to start the application. Incremental build When rebuilding an image Docker rebuilds from the first layer that is effectively changed. Copying the application jar file after the libraries ensures that Docker does not rebuild the prior layers. What is ${project.artifactId}? It&#8217;s a Maven property. The file above is processed during the Maven build, a new file is created under the target directory and the property value is expanded. <markup lang=\"bash\" title=\"Build the project\" >mvn package <markup lang=\"bash\" title=\"Build the Docker image\" >docker build -t quickstart-se target <markup lang=\"bash\" title=\"Run the docker container\" >docker run --rm -p 8080:8080 quickstart-se:latest <markup lang=\"bash\" title=\"Ping the application\" >curl -X GET http://localhost:8080/greet ",
            "title": "Creating a Java 8 Based Docker Image"
        },
        {
            "location": "/guides/04_dockerfile",
            "text": " For Helidon MP you need to add a couple more modules to the jlink command: <markup lang=\"yaml\" >RUN [\"jlink\", \"--compress=2\", \"--strip-debug\", \"--no-header-files\", \\ \"--add-modules\", \\ \"java.base,java.logging,java.sql,java.desktop,java.management,java.naming,jdk.unsupported\", \\ \"--output\", \"/var/tmp/myjre\"] ",
            "title": "What about Helidon MP?"
        },
        {
            "location": "/guides/04_dockerfile",
            "text": " This section describes how to build an image with a custom Java 11 JRE using jlink . Replace src/main/docker/Dockerfile with the following: <markup lang=\"yaml\" ># Multistage Docker build. # Stage 1: Build custom Java 11 JRE and put it in /var/tmp/myjre FROM openjdk:11-slim AS myjre RUN [\"jlink\", \"--compress=2\", \"--strip-debug\", \"--no-header-files\", \\ \"--add-modules\", \"java.base,java.logging,java.sql,java.desktop,java.management\", \\ \"--output\", \"/var/tmp/myjre\"] # Work around for https://github.com/docker-library/openjdk/issues/217 RUN [ \"apt\", \"update\"] RUN [ \"apt-get\", \"install\", \"-y\", \"binutils\"] RUN [\"strip\", \"-p\", \"--strip-unneeded\", \"/var/tmp/myjre/lib/server/libjvm.so\"] # End work-around # Stage 2: Build application image using JRE from Stage 1 FROM debian:sid-slim COPY --from=myjre /var/tmp/myjre /opt/jre ENV PATH=$PATH:/opt/jre/bin RUN mkdir /app COPY libs /app/libs COPY ${project.artifactId}.jar /app CMD [\"java\", \"-jar\", \"/app/${project.artifactId}.jar\"] This is a multi-stage Docker build. See more info here The first stage that creates our custom JRE. The modules listed in this example are for Helidon SE. See below for Helidon MP. This is a work-around for https://github.com/docker-library/openjdk/issues/217 . The final stage that creates the image for our application. Use debian:sid-slim to match the base image of openjdk:11-slim Copy the JRE from the image of the first stage myjre <markup lang=\"bash\" title=\"Process the new Dockerfile\" >mvn process-resources <markup lang=\"bash\" title=\"Build the Docker image\" >docker build -t java11-quickstart-se target <markup lang=\"bash\" title=\"Run the docker container\" >docker run --rm -p 8080:8080 java11-quickstart-se:latest <markup lang=\"bash\" title=\"Ping the application\" >curl -X GET http://localhost:8080/greet <markup lang=\"bash\" title=\"Take a look at the image size\" >docker images java11-quickstart-se:latest <markup lang=\"bash\" >REPOSITORY TAG IMAGE ID CREATED SIZE java11-quickstart-se latest f07a7b8bda78 About a minute ago 136MB ~140MB is less than the pre-built OpenJDK slim JRE images. Results might differ a bit depending on your platform. What about Helidon MP? For Helidon MP you need to add a couple more modules to the jlink command: <markup lang=\"yaml\" >RUN [\"jlink\", \"--compress=2\", \"--strip-debug\", \"--no-header-files\", \\ \"--add-modules\", \\ \"java.base,java.logging,java.sql,java.desktop,java.management,java.naming,jdk.unsupported\", \\ \"--output\", \"/var/tmp/myjre\"] ",
            "title": "Creating a Docker Image with a Custom JRE"
        },
        {
            "location": "/webserver/05_error-handling",
            "text": " If no user-defined error handler is matched, or if the last error handler of the exception called req.next() , then the exception is translated to an HTTP response as follows: Subtypes of HttpException are translated to their associated HTTP error codes. <markup lang=\"java\" title=\"Reply with the 406 HTTP error code by throwing an exception\" >(req, res) -&gt; throw new HttpException(\"Amount of money must be greater than 0.\", Http.Status.NOT_ACCEPTABLE_406) Otherwise, the exceptions are translated to an Internal Server Error HTTP error code 500 . ",
            "title": "Default error handling"
        },
        {
            "location": "/webserver/05_error-handling",
            "text": " You may register an error handler for a specific Throwable in the Routing.Builder method. <markup lang=\"java\" >Routing routing = Routing.builder() .error(MyException.class, (req, res, ex) -&gt; { // handle the error, set the HTTP status code res.send(errorDescriptionObject); }) .build Registers an error handler that handles MyException that are thrown from the upstream handlers Finishes the request handling by sending a response Error handlers are called when an exception is thrown from a handler req.next(ex) is called, where ex is an instance of Throwable As with the standard handlers, the error handler must either send a response <markup lang=\"java\" >.error(MyException.class, (req, res, ex) -&gt; { res.status(Http.Status.BAD_REQUEST_400); res.send(\"Unable to parse request. Message: \" + ex.getMessage()); }) or, forward the error handling to the downstream error handlers <markup lang=\"java\" >.error(Throwable.class, (req, res, ex) -&gt; { // some logic req.next(ex); }) Error handling can&#8217;t be forwarded to the standard handlers. In fact, invoking req.next(ex) or req.next() in an error handler are equivalent. <markup lang=\"java\" >.error(Throwable.class, (req, res, ex) -&gt; { if (condition) { req.next(ex); } else { req.next(); } }) Call a downstream error handler with the Throwable instance. Here, req.next() is the same as req.next(ex) . In both cases, the downstream error handler is called. Default error handling If no user-defined error handler is matched, or if the last error handler of the exception called req.next() , then the exception is translated to an HTTP response as follows: Subtypes of HttpException are translated to their associated HTTP error codes. <markup lang=\"java\" title=\"Reply with the 406 HTTP error code by throwing an exception\" >(req, res) -&gt; throw new HttpException(\"Amount of money must be greater than 0.\", Http.Status.NOT_ACCEPTABLE_406) Otherwise, the exceptions are translated to an Internal Server Error HTTP error code 500 . ",
            "title": "Error Routing"
        },
        {
            "location": "/webserver/05_error-handling",
            "text": " You can also register an application that has its own handlers at a path prefix or context root. <markup lang=\"java\" title=\"Registering routing logic for a context root\" >.register(\"/context-root\", new MyComplexApplication()) <markup lang=\"java\" title=\"Routing logic implementation\" >public class MyComplexApplication implements Consumer&lt;Routing.Config&gt; { @Override public void accept(Routing.Config config) { config.get(\"/subpath\", (req, res) -&gt; {/* handler */}); } } In this example, the GET handler matches requests to /context-root/subpath . ",
            "title": "Registering an application - Organizing code into services"
        },
        {
            "location": "/security/04_tools",
            "text": " Support for encrypting secrets in configuration files. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-encryption&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Secure configuration"
        },
        {
            "location": "/security/04_tools",
            "text": " Configuration support for accessing private keys, public keys, certificates and certificate chains including runtime access to instances of such. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.common&lt;/groupId&gt; &lt;artifactId&gt;helidon-common-key-util&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Key and certificate configuration"
        },
        {
            "location": "/security/04_tools",
            "text": " Secure configuration Support for encrypting secrets in configuration files. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-encryption&lt;/artifactId&gt; &lt;/dependency&gt; Key and certificate configuration Configuration support for accessing private keys, public keys, certificates and certificate chains including runtime access to instances of such. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.common&lt;/groupId&gt; &lt;artifactId&gt;helidon-common-key-util&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Tools"
        },
        {
            "location": "/about/05_kubernetes",
            "text": " For development it&#8217;s often convenient to run Kubernetes on your desktop. Two popular ways to do this are with Kubernetes Minikube or Kubernetes support in Docker for Desktop . In this guide we&#8217;ll use Docker for Desktop. ",
            "title": "preambule"
        },
        {
            "location": "/about/05_kubernetes",
            "text": " Install Docker for Mac or Docker for Windows . To use the Kubernetes support you&#8217;ll want to get the Edge Channel installer. ",
            "title": "Install"
        },
        {
            "location": "/about/05_kubernetes",
            "text": " Enable Kubernetes Support for Mac or Kubernetes Support for Windows . Once Kubernetes installation is complete, make sure you have your context set correctly to use docker-for-desktop. <markup lang=\"bash\" title=\"Make sure K8s context is set to docker-for-desktop\" >kubectl config get-contexts kubectl config use-context docker-for-desktop kubectl cluster-info kubectl version --short kubectl get nodes ",
            "title": "Enable Kubernetes Support"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Helidon Config provides several extension modules that support other configuration formats (parsers) and sources. This section describes how to add these modules to your build and how to use them from your application. ",
            "title": "preambule"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " This document describes the additional config formats and sources the Helidon config system supports and how to include them and use them in your project. In each case you need to add module dependencies to your project and, in some cases, write your application accordingly. ",
            "title": "Introduction"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " With each of the parsers described here, your application can either explicitly add a parser of the correct implementation to the Config.Builder , or rely on Java service loading and the config system&#8217;s matching of file types and media types to parsers. If your application creates a Config.Builder with parser services disabled (see disableParserServices then that builder will not find the Java services for the various parsers and so will be unable to match the file type or media type of sources with the corresponding parser automatically. So if you want to use automatic type matching with a given builder, do not invoke Config.Builder.disableParserServices() . ",
            "title": "Automatic Media Type and File Type Handling"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency in your project: <markup lang=\"xml\" title=\"Config YAML Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-yaml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config YAML Dependency in module-info.java \" >module myModule { requires io.helidon.config.yaml; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The YAML parser handles the following media type: application/x-yaml - YAML format (file type .yaml ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.create(classpath(\"application.yaml\")); The config system automatically maps the file type .yaml to the media type application/x-yaml which the Helidon YAML parser matches. <markup lang=\"java\" title=\"YAML parser specified - no file type on source\" >Config config = Config.create(classpath(\"my-config\") .parser(YamlConfigParserBuilder.buildDefault())); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config on the runtime classpath using the YAML parser instance created by the YamlConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.create(classpath(\"my-config\") .mediaType(\"application/x-yaml\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"YAML parser specified because parser services disabled\" >Config config = Config.builder(classpath(\"application.yaml\")) .disableParserServices() .addParser(YamlConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the YAML parser is therefore required. ",
            "title": "Using the YAML Parser"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config YAML Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-yaml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config YAML Dependency in module-info.java \" >module myModule { requires io.helidon.config.yaml; } Using the YAML Parser The YAML parser handles the following media type: application/x-yaml - YAML format (file type .yaml ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.create(classpath(\"application.yaml\")); The config system automatically maps the file type .yaml to the media type application/x-yaml which the Helidon YAML parser matches. <markup lang=\"java\" title=\"YAML parser specified - no file type on source\" >Config config = Config.create(classpath(\"my-config\") .parser(YamlConfigParserBuilder.buildDefault())); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config on the runtime classpath using the YAML parser instance created by the YamlConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.create(classpath(\"my-config\") .mediaType(\"application/x-yaml\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"YAML parser specified because parser services disabled\" >Config config = Config.builder(classpath(\"application.yaml\")) .disableParserServices() .addParser(YamlConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the YAML parser is therefore required. ",
            "title": "YAML"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency in your project: <markup lang=\"xml\" title=\"Config HOCON Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-hocon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config HOCON Dependency in module-info.java \" >module myModule { requires io.helidon.config.hocon; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The parser handles the following media types: application/hocon - HOCON format (file type .conf ) application/json - JSON format (file type .json ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.create(classpath(\"application.conf\")); The config system automatically maps the file type .conf to the media type `application/hocon which the Helidon HOCON parser matches. The same module and parser supports file type .json and the media type application/json . <markup lang=\"java\" title=\"HOCON parser specified - no file type on source\" >Config config = Config.create(classpath(\"my-config\") .parser(HoconConfigParserBuilder.buildDefault())); the media type of the source `my-config`is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config using the HOCON parser created by the HoconConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.create(classpath(\"my-config\") .mediaType(\"application/hocon\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"HOCON parser specified because parser services disabled\" >Config config = Config.builder(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the HOCON parser is therefore required. <markup lang=\"java\" title=\"Customized HOCON parser\" >Config config = Config.builder(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.create() .disableResolving() .build()) .build(); Creates new instance of the parser builder. Disables resolution of substitutions. (See the HOCON documentation .) Builds a new instance of the HOCON config parser. You can also specify ConfigResolveOptions using the HoconConfigParserBuilder.resolveOptions method. ",
            "title": "Using the HOCON/JSON Parser"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Helidon HOCON config module handles sources in the HOCON and JSON formats. Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config HOCON Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-hocon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config HOCON Dependency in module-info.java \" >module myModule { requires io.helidon.config.hocon; } Using the HOCON/JSON Parser The parser handles the following media types: application/hocon - HOCON format (file type .conf ) application/json - JSON format (file type .json ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.create(classpath(\"application.conf\")); The config system automatically maps the file type .conf to the media type `application/hocon which the Helidon HOCON parser matches. The same module and parser supports file type .json and the media type application/json . <markup lang=\"java\" title=\"HOCON parser specified - no file type on source\" >Config config = Config.create(classpath(\"my-config\") .parser(HoconConfigParserBuilder.buildDefault())); the media type of the source `my-config`is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config using the HOCON parser created by the HoconConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.create(classpath(\"my-config\") .mediaType(\"application/hocon\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"HOCON parser specified because parser services disabled\" >Config config = Config.builder(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the HOCON parser is therefore required. <markup lang=\"java\" title=\"Customized HOCON parser\" >Config config = Config.builder(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.create() .disableResolving() .build()) .build(); Creates new instance of the parser builder. Disables resolution of substitutions. (See the HOCON documentation .) Builds a new instance of the HOCON config parser. You can also specify ConfigResolveOptions using the HoconConfigParserBuilder.resolveOptions method. ",
            "title": "HOCON/JSON"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Automatic Media Type and File Type Handling With each of the parsers described here, your application can either explicitly add a parser of the correct implementation to the Config.Builder , or rely on Java service loading and the config system&#8217;s matching of file types and media types to parsers. If your application creates a Config.Builder with parser services disabled (see disableParserServices then that builder will not find the Java services for the various parsers and so will be unable to match the file type or media type of sources with the corresponding parser automatically. So if you want to use automatic type matching with a given builder, do not invoke Config.Builder.disableParserServices() . YAML Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config YAML Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-yaml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config YAML Dependency in module-info.java \" >module myModule { requires io.helidon.config.yaml; } Using the YAML Parser The YAML parser handles the following media type: application/x-yaml - YAML format (file type .yaml ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.create(classpath(\"application.yaml\")); The config system automatically maps the file type .yaml to the media type application/x-yaml which the Helidon YAML parser matches. <markup lang=\"java\" title=\"YAML parser specified - no file type on source\" >Config config = Config.create(classpath(\"my-config\") .parser(YamlConfigParserBuilder.buildDefault())); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config on the runtime classpath using the YAML parser instance created by the YamlConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.create(classpath(\"my-config\") .mediaType(\"application/x-yaml\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"YAML parser specified because parser services disabled\" >Config config = Config.builder(classpath(\"application.yaml\")) .disableParserServices() .addParser(YamlConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the YAML parser is therefore required. HOCON/JSON The Helidon HOCON config module handles sources in the HOCON and JSON formats. Maven Coordinates Add the following dependency in your project: <markup lang=\"xml\" title=\"Config HOCON Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-hocon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config HOCON Dependency in module-info.java \" >module myModule { requires io.helidon.config.hocon; } Using the HOCON/JSON Parser The parser handles the following media types: application/hocon - HOCON format (file type .conf ) application/json - JSON format (file type .json ) <markup lang=\"java\" title=\"Automatic selection\" >Config config = Config.create(classpath(\"application.conf\")); The config system automatically maps the file type .conf to the media type `application/hocon which the Helidon HOCON parser matches. The same module and parser supports file type .json and the media type application/json . <markup lang=\"java\" title=\"HOCON parser specified - no file type on source\" >Config config = Config.create(classpath(\"my-config\") .parser(HoconConfigParserBuilder.buildDefault())); the media type of the source `my-config`is unknown, so the config system cannot choose a parser automatically. The config system will parse the resource my-config using the HOCON parser created by the HoconConfigParserBuilder . The buildDefault() method creates a config parser with default behavior. <markup lang=\"java\" title=\"Media type specified\" >Config config = Config.create(classpath(\"my-config\") .mediaType(\"application/hocon\")); The media type of the source my-config is unknown, so the config system cannot choose a parser automatically. Specifying the media type for the config source allows the config system to use its matching algorithm with the available parsers to choose a parser for that type. <markup lang=\"java\" title=\"HOCON parser specified because parser services disabled\" >Config config = Config.builder(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.buildDefault()) .build(); Disables automatic parser lookup and registration. Explicit registration of the HOCON parser is therefore required. <markup lang=\"java\" title=\"Customized HOCON parser\" >Config config = Config.builder(classpath(\"application.conf\")) .disableParserServices() .addParser(HoconConfigParserBuilder.create() .disableResolving() .build()) .build(); Creates new instance of the parser builder. Disables resolution of substitutions. (See the HOCON documentation .) Builds a new instance of the HOCON config parser. You can also specify ConfigResolveOptions using the HoconConfigParserBuilder.resolveOptions method. ",
            "title": "Additional Config Formats and Parsers"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency to your project: <markup lang=\"xml\" title=\"Config Etcd Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-etcd&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config Etcd Dependency in module-info.java \" >module myModule { requires io.helidon.config.etcd; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " To read configuration from an Etcd source, your application uses the EtcdConfigSourceBuilder . <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.create( EtcdConfigSourceBuilder .create(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdConfigSourceBuilder.EtcdApi.v3)); Use the factory method EtcdConfigSourceBuilder.create to initialize the builder. Specify the Etcd endpoint address. Specify the Etcd key of the configuration document. Version of the Etcd API to use; v2 and v3 are supported. The config system will use the YAML parser automatically in this example because the file type of the key is .yaml . The EtcdConfigSourceBuilder class extends AbstractParsableConfigSource.Builder and so supports the usual settings on config sources. ",
            "title": "Using the Etcd Config Source"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Etcd support includes a polling strategy designed for an etcd config source. <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.create( EtcdConfigSourceBuilder .create(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdApi.v3) .pollingStrategy(EtcdWatchPollingStrategy::new)); Use the etcd-specific polling strategy. ",
            "title": "Monitoring for Source Changes"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from an Etcd source set the following required properties for the source: type to etcd , or class to io.helidon.config.etcd.EtcdConfigSourceBuilder uri (type URI ) - Etcd endpoint URI. key (type String ) - Etcd key that is associated with the configuration. api (type EtcdConfigSourceBuilder.EtcdApi , i.e. v2 or v3 ) - Etcd API version. Other optional properties are inherited from AbstractParsableConfigSource.Builder . (see javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-etcd.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-etcd.yaml for the etcd source\" >sources: - type: \"etcd\" properties: uri: \"http://my-etcd:2379\" key: \"/config.yaml\" api: \"v3\" polling-strategy: class: \"io.helidon.config.etcd.EtcdWatchPollingStrategy\" etcd config source type Etcd source-specific (mandatory) properties : uri , key and api . Polling strategy EtcdWatchPollingStrategy is automatically initialized by specified mandatory properties . ",
            "title": "Loading Meta-configuration via Etcd"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Helidon Etcd config module supports reading configuration from a specified Etcd key. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config Etcd Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-etcd&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config Etcd Dependency in module-info.java \" >module myModule { requires io.helidon.config.etcd; } Using the Etcd Config Source To read configuration from an Etcd source, your application uses the EtcdConfigSourceBuilder . <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.create( EtcdConfigSourceBuilder .create(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdConfigSourceBuilder.EtcdApi.v3)); Use the factory method EtcdConfigSourceBuilder.create to initialize the builder. Specify the Etcd endpoint address. Specify the Etcd key of the configuration document. Version of the Etcd API to use; v2 and v3 are supported. The config system will use the YAML parser automatically in this example because the file type of the key is .yaml . The EtcdConfigSourceBuilder class extends AbstractParsableConfigSource.Builder and so supports the usual settings on config sources. Monitoring for Source Changes The Etcd support includes a polling strategy designed for an etcd config source. <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.create( EtcdConfigSourceBuilder .create(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdApi.v3) .pollingStrategy(EtcdWatchPollingStrategy::new)); Use the etcd-specific polling strategy. Loading Meta-configuration via Etcd The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from an Etcd source set the following required properties for the source: type to etcd , or class to io.helidon.config.etcd.EtcdConfigSourceBuilder uri (type URI ) - Etcd endpoint URI. key (type String ) - Etcd key that is associated with the configuration. api (type EtcdConfigSourceBuilder.EtcdApi , i.e. v2 or v3 ) - Etcd API version. Other optional properties are inherited from AbstractParsableConfigSource.Builder . (see javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-etcd.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-etcd.yaml for the etcd source\" >sources: - type: \"etcd\" properties: uri: \"http://my-etcd:2379\" key: \"/config.yaml\" api: \"v3\" polling-strategy: class: \"io.helidon.config.etcd.EtcdWatchPollingStrategy\" etcd config source type Etcd source-specific (mandatory) properties : uri , key and api . Polling strategy EtcdWatchPollingStrategy is automatically initialized by specified mandatory properties . ",
            "title": "Etcd"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Add the following dependency to your project: <markup lang=\"xml\" title=\"Config git Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-git&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config git Dependency in module-info.java \" >module myModule { requires io.helidon.config.git; } ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " To read configuration from a git source, your application uses the GitConfigSourceBuilder . <markup lang=\"java\" title=\"Use git config source\" >Config config = Config.create( GitConfigSourceBuilder .create(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .directory(Paths.get(\"/config\")) .branch(\"dev\")); Use the factory method GitConfigSourceBuilder.create to initialize the builder with a mandatory path to the configuration file. Specify the git repository URI. Specify a directory where the git repository is already cloned or it will be cloned. Specify the git branch. Note that the config system will use the HOCON parser in this example because the file type is .conf . Recall that for this to work the HOCON config module must be on module-path or classpath. The GitConfigSourceBuilder supports the usual source builder properties because it extends AbstractParsableConfigSource.Builder . ",
            "title": "Using the git Config Source"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Your application can monitor changes to a configuration loaded from a git source associating the regular built-in polling strategy with the source. <markup lang=\"java\" title=\"Use of git config source with polling strategy\" >Config config = Config.create( GitConfigSourceBuilder .create(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .pollingStrategy(PollingStrategies.regular(Duration.ofMinutes(5)))); Use PollingStrategies.regular(Duration duration) to monitor for config changes. You can also implemention your own polling strategy by implementing PollingStrategy . See the mutability support and polling strategy discussions. ",
            "title": "Monitoring for Source Changes"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from a git config source set the following properties for the source: type to git or class to io.helidon.config.git.GitConfigSourceBuilder path (type String ) - Relative path to the configuration file in repository. uri (type URI ) - URI to the git repository. directory (type Path ) - Directory with a cloned repository, by default a temporary directory. branch (type String ) - git branch (default is master ). The meta-configuration must set the path and one of uri or directory . Other optional properties are inherited from AbstractParsableConfigSource.Builder (see javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-git.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-git.yaml for the git source\" >sources: - type: \"git\" properties: path: \"application.conf\" uri: \"https://github.com/okosatka/test-config.git\" directory: \"/config\" branch: \"dev\" polling-strategy: type: \"regular\" properties: interval: \"PT5M\" git config source type git source-specific properties: path , uri , directory and branch . Polling strategy regular with an interval, in Duration format, of 5 minutes in this example. ",
            "title": "Loading Meta-configuration via git"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " The Helidon git config module supports reading configuration from a git repository. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config git Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-git&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config git Dependency in module-info.java \" >module myModule { requires io.helidon.config.git; } Using the git Config Source To read configuration from a git source, your application uses the GitConfigSourceBuilder . <markup lang=\"java\" title=\"Use git config source\" >Config config = Config.create( GitConfigSourceBuilder .create(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .directory(Paths.get(\"/config\")) .branch(\"dev\")); Use the factory method GitConfigSourceBuilder.create to initialize the builder with a mandatory path to the configuration file. Specify the git repository URI. Specify a directory where the git repository is already cloned or it will be cloned. Specify the git branch. Note that the config system will use the HOCON parser in this example because the file type is .conf . Recall that for this to work the HOCON config module must be on module-path or classpath. The GitConfigSourceBuilder supports the usual source builder properties because it extends AbstractParsableConfigSource.Builder . Monitoring for Source Changes Your application can monitor changes to a configuration loaded from a git source associating the regular built-in polling strategy with the source. <markup lang=\"java\" title=\"Use of git config source with polling strategy\" >Config config = Config.create( GitConfigSourceBuilder .create(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .pollingStrategy(PollingStrategies.regular(Duration.ofMinutes(5)))); Use PollingStrategies.regular(Duration duration) to monitor for config changes. You can also implemention your own polling strategy by implementing PollingStrategy . See the mutability support and polling strategy discussions. Loading Meta-configuration via git The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from a git config source set the following properties for the source: type to git or class to io.helidon.config.git.GitConfigSourceBuilder path (type String ) - Relative path to the configuration file in repository. uri (type URI ) - URI to the git repository. directory (type Path ) - Directory with a cloned repository, by default a temporary directory. branch (type String ) - git branch (default is master ). The meta-configuration must set the path and one of uri or directory . Other optional properties are inherited from AbstractParsableConfigSource.Builder (see javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-git.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-git.yaml for the git source\" >sources: - type: \"git\" properties: path: \"application.conf\" uri: \"https://github.com/okosatka/test-config.git\" directory: \"/config\" branch: \"dev\" polling-strategy: type: \"regular\" properties: interval: \"PT5M\" git config source type git source-specific properties: path , uri , directory and branch . Polling strategy regular with an interval, in Duration format, of 5 minutes in this example. ",
            "title": "git"
        },
        {
            "location": "/config/08_supported-formats",
            "text": " Etcd The Helidon Etcd config module supports reading configuration from a specified Etcd key. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config Etcd Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-etcd&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config Etcd Dependency in module-info.java \" >module myModule { requires io.helidon.config.etcd; } Using the Etcd Config Source To read configuration from an Etcd source, your application uses the EtcdConfigSourceBuilder . <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.create( EtcdConfigSourceBuilder .create(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdConfigSourceBuilder.EtcdApi.v3)); Use the factory method EtcdConfigSourceBuilder.create to initialize the builder. Specify the Etcd endpoint address. Specify the Etcd key of the configuration document. Version of the Etcd API to use; v2 and v3 are supported. The config system will use the YAML parser automatically in this example because the file type of the key is .yaml . The EtcdConfigSourceBuilder class extends AbstractParsableConfigSource.Builder and so supports the usual settings on config sources. Monitoring for Source Changes The Etcd support includes a polling strategy designed for an etcd config source. <markup lang=\"java\" title=\"Use Etcd config source\" >Config config = Config.create( EtcdConfigSourceBuilder .create(URI.create(\"http://my-etcd:2379\"), \"/config.yaml\", EtcdApi.v3) .pollingStrategy(EtcdWatchPollingStrategy::new)); Use the etcd-specific polling strategy. Loading Meta-configuration via Etcd The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from an Etcd source set the following required properties for the source: type to etcd , or class to io.helidon.config.etcd.EtcdConfigSourceBuilder uri (type URI ) - Etcd endpoint URI. key (type String ) - Etcd key that is associated with the configuration. api (type EtcdConfigSourceBuilder.EtcdApi , i.e. v2 or v3 ) - Etcd API version. Other optional properties are inherited from AbstractParsableConfigSource.Builder . (see javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-etcd.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-etcd.yaml for the etcd source\" >sources: - type: \"etcd\" properties: uri: \"http://my-etcd:2379\" key: \"/config.yaml\" api: \"v3\" polling-strategy: class: \"io.helidon.config.etcd.EtcdWatchPollingStrategy\" etcd config source type Etcd source-specific (mandatory) properties : uri , key and api . Polling strategy EtcdWatchPollingStrategy is automatically initialized by specified mandatory properties . git The Helidon git config module supports reading configuration from a git repository. Maven Coordinates Add the following dependency to your project: <markup lang=\"xml\" title=\"Config git Dependency in pom.xml \" >&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-git&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; <markup lang=\"java\" title=\"Config git Dependency in module-info.java \" >module myModule { requires io.helidon.config.git; } Using the git Config Source To read configuration from a git source, your application uses the GitConfigSourceBuilder . <markup lang=\"java\" title=\"Use git config source\" >Config config = Config.create( GitConfigSourceBuilder .create(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .directory(Paths.get(\"/config\")) .branch(\"dev\")); Use the factory method GitConfigSourceBuilder.create to initialize the builder with a mandatory path to the configuration file. Specify the git repository URI. Specify a directory where the git repository is already cloned or it will be cloned. Specify the git branch. Note that the config system will use the HOCON parser in this example because the file type is .conf . Recall that for this to work the HOCON config module must be on module-path or classpath. The GitConfigSourceBuilder supports the usual source builder properties because it extends AbstractParsableConfigSource.Builder . Monitoring for Source Changes Your application can monitor changes to a configuration loaded from a git source associating the regular built-in polling strategy with the source. <markup lang=\"java\" title=\"Use of git config source with polling strategy\" >Config config = Config.create( GitConfigSourceBuilder .create(\"application.conf\") .uri(URI.create(\"https://github.com/okosatka/test-config.git\")) .pollingStrategy(PollingStrategies.regular(Duration.ofMinutes(5)))); Use PollingStrategies.regular(Duration duration) to monitor for config changes. You can also implemention your own polling strategy by implementing PollingStrategy . See the mutability support and polling strategy discussions. Loading Meta-configuration via git The config system can load information about config sources from meta-configuration rather than requiring your application to construct the builder. To read meta-configuration from a git config source set the following properties for the source: type to git or class to io.helidon.config.git.GitConfigSourceBuilder path (type String ) - Relative path to the configuration file in repository. uri (type URI ) - URI to the git repository. directory (type Path ) - Directory with a cloned repository, by default a temporary directory. branch (type String ) - git branch (default is master ). The meta-configuration must set the path and one of uri or directory . Other optional properties are inherited from AbstractParsableConfigSource.Builder (see javadoc ) <markup lang=\"java\" title=\"Load Config from meta-configuration\" >Config config = Config.loadSourcesFrom(classpath(\"config-meta-git.yaml\")); <markup lang=\"YAML\" title=\"Meta-config config-meta-git.yaml for the git source\" >sources: - type: \"git\" properties: path: \"application.conf\" uri: \"https://github.com/okosatka/test-config.git\" directory: \"/config\" branch: \"dev\" polling-strategy: type: \"regular\" properties: interval: \"PT5M\" git config source type git source-specific properties: path , uri , directory and branch . Polling strategy regular with an interval, in Duration format, of 5 minutes in this example. ",
            "title": "Additional Config Source Types"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " MicroProfile is a platform definition that is familiar to Java EE developers. If you have experience with JAX-RS, JSON-P, and CDI, you may prefer to use this model. To extend the functionality of your MicroProfile application, you might also decide to use the Helidon core APIs, especially for configuration and security. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.microprofile.bundles&lt;/groupId&gt; &lt;artifactId&gt;helidon-microprofile-1.2&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Create a JAX-RS Resource class with at least one resource method. <markup lang=\"java\" title=\"Sample JAX-RS Resource Class\" >@Path(\"/\") @RequestScoped public class HelloWorldResource { @GET @Produces(MediaType.TEXT_PLAIN) public String message() { return \"Hello World\"; } } And create a JAX-RS application. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >@ApplicationScoped @ApplicationPath(\"/\") public class HelloWorldApplication extends Application { @Override public Set&lt;Class&lt;?&gt;&gt; getClasses() { return Set.of( HelloWorldResource.class ); } } Add beans.xml in src/main/resources/META-INF so the CDI implementation can pick up your classes. <markup lang=\"xml\" title=\"beans.xml\" >&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans/&gt; As a last step, add a main method to your application (or a dedicated Main class) to start everything up. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >public static void main(String[] args) { io.helidon.microprofile.server.Main.main(args); } Run the main class. The server will start on port 7001 and serve your resources. ",
            "title": "Project files"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Jandex is an indexing tool for Weld (CDI implementation) that helps speed up the boot time of an application. To use Jandex, configure a Maven plugin that adds the index to your JAR file and a dependency on Jandex. <markup lang=\"xml\" title=\"jandex dependency\" >&lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.0.4.Final&lt;/version&gt; &lt;/dependency&gt; <markup lang=\"xml\" title=\"jandex plugin configuration\" >&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt; &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-index&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jandex&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ",
            "title": "Adding Jandex"
        },
        {
            "location": "/microprofile/01_introduction",
            "text": " Complete these tasks to get started with your MicroProfile application. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.microprofile.bundles&lt;/groupId&gt; &lt;artifactId&gt;helidon-microprofile-1.2&lt;/artifactId&gt; &lt;/dependency&gt; Project files Create a JAX-RS Resource class with at least one resource method. <markup lang=\"java\" title=\"Sample JAX-RS Resource Class\" >@Path(\"/\") @RequestScoped public class HelloWorldResource { @GET @Produces(MediaType.TEXT_PLAIN) public String message() { return \"Hello World\"; } } And create a JAX-RS application. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >@ApplicationScoped @ApplicationPath(\"/\") public class HelloWorldApplication extends Application { @Override public Set&lt;Class&lt;?&gt;&gt; getClasses() { return Set.of( HelloWorldResource.class ); } } Add beans.xml in src/main/resources/META-INF so the CDI implementation can pick up your classes. <markup lang=\"xml\" title=\"beans.xml\" >&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans/&gt; As a last step, add a main method to your application (or a dedicated Main class) to start everything up. <markup lang=\"java\" title=\"Sample JAX-RS Application\" >public static void main(String[] args) { io.helidon.microprofile.server.Main.main(args); } Run the main class. The server will start on port 7001 and serve your resources. Adding Jandex Jandex is an indexing tool for Weld (CDI implementation) that helps speed up the boot time of an application. To use Jandex, configure a Maven plugin that adds the index to your JAR file and a dependency on Jandex. <markup lang=\"xml\" title=\"jandex dependency\" >&lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.0.4.Final&lt;/version&gt; &lt;/dependency&gt; <markup lang=\"xml\" title=\"jandex plugin configuration\" >&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt; &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-index&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jandex&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ",
            "title": "Getting Started with Helidon MicroProfile"
        },
        {
            "location": "/about/03_prerequisites",
            "text": " Everything you need to use Helidon is listed here. ",
            "title": "preambule"
        },
        {
            "location": "/about/03_prerequisites",
            "text": " Helidon requires Java 8 (or greater) and Maven. You need Docker if you want to build and deploy Docker containers. If you want to deploy to Kubernetes, you need kubectl and a Kubernetes cluster (you can install one on your desktop ). The following list shows the minimum versions. <div class=\"table__overflow elevation-1 flex sm7 \"> Java&#160;SE&#160;8 or Open&#160;JDK&#160;8 &#160; Maven 3.5 &#160; Docker 18.02 Use the Edge channel to run Kubernetes on your desktop Kubectl 1.7.4 &#160; <markup lang=\"bash\" title=\"Verify Prerequisites\" >java -version mvn --version docker --version kubectl version --short ",
            "title": "Prerequisites"
        },
        {
            "location": "/about/03_prerequisites",
            "text": "<markup lang=\"bash\" title=\"Setting JAVA_HOME\" ># On Mac export JAVA_HOME=`/usr/libexec/java_home -v 1.8` # On Linux # Use the appropriate path to your JDK export JAVA_HOME=/usr/lib/jvm/jdk-8 ",
            "title": "Setting JAVA_HOME"
        },
        {
            "location": "/about/03_prerequisites",
            "text": " Now you are ready to try the Quickstart Examples . ",
            "title": "Try the Quickstart Examples"
        },
        {
            "location": "/metrics/01_metrics",
            "text": " Helidon SE provides the following to support metrics: The endpoint /metrics : A configurable endpoint that exposes metrics information in JSON format (as specified by the MicroProfile Metrics specification) or in plain text (for Prometheus metrics). A base set of metrics, available at /metrics/base , as specified by the MicroProfile Metrics specification. A set of Helidon-specific metrics, available at /metrics/vendor ",
            "title": "preambule"
        },
        {
            "location": "/metrics/01_metrics",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;io.helidon.metrics&lt;/groupId&gt; &lt;artifactId&gt;helidon-metrics&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/metrics/01_metrics",
            "text": " To enable Metrics, register it with the WebServer. <markup lang=\"java\" >import io.helidon.metrics.MetricsSupport; //... Routing.builder() .register(MetricsSupport.create()) .register(\"/myapp\", new MyService()) .build(); Then you can use metrics in your service. <markup lang=\"java\" title=\"Define and use a Metrics Counter\" >import io.helidon.metrics.RegistryFactory; import org.eclipse.microprofile.metrics.Counter; import org.eclipse.microprofile.metrics.MetricRegistry; //... public class MyService implements Service { private final MetricRegistry registry = RegistryFactory.getRegistryFactory().get() .getRegistry(MetricRegistry.Type.APPLICATION); private final Counter accessCtr = registry.counter(\"accessctr\"); @Override public void update(Routing.Rules rules) { rules .any(this::countAccess) .get(\"/\", this::myGet); } private void countAccess(ServerRequest request, ServerResponse response) { accessCtr.inc(); request.next(); } } Get the application metrics registry Create a counter in that registry Increment the counter for every request ",
            "title": "Using Metrics in Your Application"
        },
        {
            "location": "/metrics/01_metrics",
            "text": " Access metrics data via the /metrics endpoint. Two reporting formats are supported. The HTTP Accept header sent by the client determines the reporting format: JSON format - used when the HTTP Accept header matches application/json Prometheus text format - used when the HTTP Accept header is text/plain or otherwise does not match application/json <markup lang=\"bash\" title=\"Example Reporting: Prometheus format\" >curl -s -H 'Accept: text/plain' -X GET http://localhost:8080/metrics/ # TYPE base:classloader_total_loaded_class_count counter # HELP base:classloader_total_loaded_class_count Displays the total number of classes that have been loaded since the Java virtual machine has started execution. base:classloader_total_loaded_class_count 3157 #... <markup lang=\"bash\" title=\"Example Reporting: JSON format\" >curl -s -H 'Accept: application/json' -X GET http://localhost:8080/metrics/ | json_pp { \"base\" : { \"memory.maxHeap\" : 3817865216, \"memory.committedHeap\" : 335544320, #... In addition to your application metrics the reports contain other metrics of interest such as system and VM information. For full details see the MicroProfile Metrics specification. The Metrics component in Helidon SE is the core for the Helidon MP implementation of the MicroProfile Metrics specification. ",
            "title": "Accessing Metrics Endpoint"
        },
        {
            "location": "/guides/03_quickstart-mp",
            "text": " This guide describes a basic example of an Helidon MP application using Docker and Kubernetes. ",
            "title": "preambule"
        },
        {
            "location": "/guides/03_quickstart-mp",
            "text": " <div class=\"table__overflow elevation-1 flex sm7 \"> About 5 minutes Helidon Prerequisites ",
            "title": "What you need"
        },
        {
            "location": "/guides/03_quickstart-mp",
            "text": " Generate the project sources using one (or both) of the Helidon Maven archetypes. The result is a simple project that shows the basics of configuring the WebServer and implementing basic routing rules. <markup lang=\"bash\" title=\"Run the Maven archetype\" >mvn archetype:generate -DinteractiveMode=false \\ -DarchetypeGroupId=io.helidon.archetypes \\ -DarchetypeArtifactId=helidon-quickstart-mp \\ -DarchetypeVersion=1.0.2 \\ -DgroupId=io.helidon.examples \\ -DartifactId=helidon-quickstart-mp \\ -Dpackage=io.helidon.examples.quickstart.mp The archetype generates a Maven project in your current directory (for example, helidon-quickstart-mp ). Change into this directory. <markup lang=\"bash\" >cd helidon-quickstart-mp If you want to use the generated project as a starter for your own application, then you can replace groupId, artifactId and package with values appropriate for your application. <markup lang=\"bash\" title=\"Build the Application\" >mvn package The project builds an application jar for the example and saves all runtime dependencies in the target/libs directory. This means you can easily start the application by running the application jar file: <markup lang=\"bash\" title=\"Run the application\" >java -jar target/helidon-quickstart-mp.jar The example is a very simple \"Hello World\" greeting service. It supports GET requests for generating a greeting message, and a PUT request for changing the greeting itself. The response is encoded using JSON. For example: <markup lang=\"bash\" title=\"Try the Application\" >curl -X GET http://localhost:8080/greet {\"message\":\"Hello World!\"} curl -X GET http://localhost:8080/greet/Joe {\"message\":\"Hello Joe!\"} curl -X PUT -H \"Content-Type: application/json\" -d '{\"greeting\" : \"Hola\"}' http://localhost:8080/greet/greeting curl -X GET http://localhost:8080/greet/Jose {\"message\":\"Hola Jose!\"} ",
            "title": "Generate The Project"
        },
        {
            "location": "/guides/03_quickstart-mp",
            "text": " The project also contains a Dockerfile so that you can easily build and run a Docker image. Because the example&#8217;s runtime dependencies are already in target/libs , the Dockerfile is pretty simple (see target/Dockerfile ). To build the Docker image, you need to have Docker installed and running on your system. <markup lang=\"bash\" title=\"Docker build\" >docker build -t helidon-quickstart-mp target <markup lang=\"bash\" title=\"Run Docker Image\" >docker run --rm -p 8080:8080 quickstart-mp:latest Then you can try the application as you did before. ",
            "title": "Build a Docker Image"
        },
        {
            "location": "/guides/03_quickstart-mp",
            "text": " If you don&#8217;t have access to a Kubernetes cluster, you can install one on your desktop . Then deploy the example: <markup lang=\"bash\" title=\"Verify connectivity to cluster\" >kubectl cluster-info kubectl get nodes <markup lang=\"bash\" title=\"Deploy the application to Kubernetes\" >kubectl create -f target/app.yaml kubectl get pods # Wait for quickstart pod to be RUNNING The step above created a service that is exposed into any node port. Lookup the service to find the port. <markup lang=\"bash\" title=\"Lookup the service\" >kubectl get service helidon-quickstart-mp Note the PORTs. You can now exercise the application as you did before but use the second port number (the NodePort) instead of 8080. For example: <markup lang=\"bash\" >curl -X GET http://localhost:31431/greet After you&#8217;re done, cleanup. <markup lang=\"bash\" title=\"Remove the application from Kubernetes\" >kubectl delete -f target/app.yaml ",
            "title": "Deploy the application to Kubernetes"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"Webserver JSON-P Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.media.jsonp&lt;/groupId&gt; &lt;artifactId&gt;helidon-media-jsonp-server&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " To enable JSON-P support, first register it with the route builder. Then you can add routes that handle and return JSON. <markup lang=\"java\" title=\"Configure JsonSupport and use it for reading and writing of entities\" >Routing.builder() .register(JsonSupport.create()) .post(\"/sayhello\", Handler.create(JsonObject.class, this::sayHello)) .build(); Register JsonSupport to enable transformation from and to JsonObject objects Register a handler that receives a JsonObject as its input. <markup lang=\"java\" title=\"Handler that receives and returns JSON objects\" >private static final JsonBuilderFactory jsonFactory = Json.createBuilderFactory(Collections.emptyMap()); private void sayHello(ServerRequest req, ServerResponse res, JsonObject json) { JsonObject msg = jsonFactory.createObjectBuilder() .add(\"message\", \"Hello \" + json.getString(\"name\")) .build(); res.send(msg); } Using a JsonBuilderFactory is more efficient than Json.createObjectBuilder() JsonObject is passed to handler Create a JsonObject using JSON-P to hold return data Send JsonObject in response <markup lang=\"bash\" title=\"Example of posting JSON to sayHello endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/sayhello -d '{\"name\":\"Joe\"}' {\"message\":\"Hello Joe\"} ",
            "title": "Usage"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " To configure JSON-P JsonReaderFactory and JsonWriterFactory that are used by the JsonSupport instance, create the JsonSupport object: <markup lang=\"java\" title=\"Create JsonSupport with the provided configuration\" >JsonSupport.create(Map.of(JsonGenerator.PRETTY_PRINTING, false)) ",
            "title": "Configuring Json Reader/Writer factories"
        },
        {
            "location": "/webserver/08_json-support",
            "text": " The WebServer supports JSON-P. When enabled, you can send and receive JSON-P objects transparently. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" title=\"Webserver JSON-P Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.media.jsonp&lt;/groupId&gt; &lt;artifactId&gt;helidon-media-jsonp-server&lt;/artifactId&gt; &lt;/dependency&gt; Usage To enable JSON-P support, first register it with the route builder. Then you can add routes that handle and return JSON. <markup lang=\"java\" title=\"Configure JsonSupport and use it for reading and writing of entities\" >Routing.builder() .register(JsonSupport.create()) .post(\"/sayhello\", Handler.create(JsonObject.class, this::sayHello)) .build(); Register JsonSupport to enable transformation from and to JsonObject objects Register a handler that receives a JsonObject as its input. <markup lang=\"java\" title=\"Handler that receives and returns JSON objects\" >private static final JsonBuilderFactory jsonFactory = Json.createBuilderFactory(Collections.emptyMap()); private void sayHello(ServerRequest req, ServerResponse res, JsonObject json) { JsonObject msg = jsonFactory.createObjectBuilder() .add(\"message\", \"Hello \" + json.getString(\"name\")) .build(); res.send(msg); } Using a JsonBuilderFactory is more efficient than Json.createObjectBuilder() JsonObject is passed to handler Create a JsonObject using JSON-P to hold return data Send JsonObject in response <markup lang=\"bash\" title=\"Example of posting JSON to sayHello endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/sayhello -d '{\"name\":\"Joe\"}' {\"message\":\"Hello Joe\"} Configuring Json Reader/Writer factories To configure JSON-P JsonReaderFactory and JsonWriterFactory that are used by the JsonSupport instance, create the JsonSupport object: <markup lang=\"java\" title=\"Create JsonSupport with the provided configuration\" >JsonSupport.create(Map.of(JsonGenerator.PRETTY_PRINTING, false)) ",
            "title": "Json Support"
        },
        {
            "location": "/extensions/02_cdi_datasource-hikaricp",
            "text": " This CDI portable extension provides support for injecting HikariCP data sources in your Helidon MicroProfile applications. ",
            "title": "preambule"
        },
        {
            "location": "/extensions/02_cdi_datasource-hikaricp",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.integrations.cdi&lt;/groupId&gt; &lt;artifactId&gt;helidon-integrations-cdi-datasource-hikaricp&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/extensions/02_cdi_datasource-hikaricp",
            "text": " The following examples show how to create a DataSource named orders in your application. <markup lang=\"java\" title=\"Field-injection example\" > @Inject @Named(\"orders\") private DataSource ordersDataSource; <markup lang=\"java\" title=\"Constructor-injection example\" > private final DataSource ds; @Inject public YourConstructor(@Named(\"orders\") DataSource ds) { super(); this.ds = ds; } The extension implements this injection point by creating a HikariDataSource object in the application scope . You can configure the object using MicroProfile config . For example, the data source created above can be configured as follows: <markup lang=\"properties\" title=\"META-INF/microprofile-config.properties\" >javax.sql.DataSource.orders.dataSourceClassName=oracle.jdbc.pool.OracleDataSource javax.sql.DataSource.orders.dataSource.url = jdbc:oracle:thin:@localhost:1521:ORCL javax.sql.DataSource.orders.dataSource.user = sys as sysoper javax.sql.DataSource.orders.dataSource.password = Oracle Property names that start with javax.sql.DataSource.dataSourceName. are parsed, and the remaining portion of each name is treated as a Hikari connection pool property . ",
            "title": "Injecting a HikariCP data source"
        },
        {
            "location": "/extensions/04_cdi_oci-objectstorage",
            "text": " This CDI portable extension provides support for injecting an Oracle Cloud Infrastructure Object Storage client in your Helidon MicroProfile applications. ",
            "title": "preambule"
        },
        {
            "location": "/extensions/04_cdi_oci-objectstorage",
            "text": " To install the extension for Oracle Cloud Infrastructure Object Storage clients, you must first clone and install the Oracle Cloud Infrastructure Java SDK because it is not available, currently, in Maven Central. Clone the SDK: <markup lang=\"bash\" >git clone --depth 1 --branch v1.2.44 https://github.com/oracle/oci-java-sdk.git Install the SDK: <markup lang=\"bash\" >cd oci-java-sdk &amp;&amp; mvn -B -U -f oci-java-sdk/pom.xml \\ -Dmaven.test.skip=true \\ -Dmaven.source.skip=true \\ -Dmaven.javadoc.skip=true \\ -Dlombok.delombok.skip=true \\ -pl bmc-objectstorage \\ -am \\ install Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.integrations.cdi&lt;/groupId&gt; &lt;artifactId&gt;helidon-integrations-cdi-oci-objectstorage&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/extensions/04_cdi_oci-objectstorage",
            "text": "<markup lang=\"java\" title=\"Field-injection example\" > @Inject private ObjectStorage client; <markup lang=\"java\" title=\"Constructor-injection example\" > private final ObjectStorage client; @Inject public YourConstructor(@Named(\"orders\") ObjectStorage client) { super(); this.client = client; } The extension implements this injection point by creating an Object Storage client object in the application scope . You can configure the object using MicroProfile config . For example, the Object Storage client created above can be configured as follows: <markup lang=\"properties\" title=\"META-INF/microprofile-config.properties\" >oci.auth.fingerprint= oci.auth.keyFile= oci.auth.passphraseCharacters= oci.auth.user= oci.auth.tenancy= oci.objectstorage.region= oci.objectstorage.namespace= These properties are described in the Oracle Cloud Infrastructure Object Storage Java SDK documentation . ",
            "title": "Injecting an Object Storage client"
        },
        {
            "location": "/security/02_providers",
            "text": " All configuration options: key default value description optional  false If set to true, the provider will return \"ABSTAIN\" rather than \"FAILURE\" if token is not present in request authenticate true Whether to attempt authentication propagate true Whether to attempt identity propagation/JWT creation principal-type USER Whether we authenticate a user or a service (other option is SERVICE) atn-token A group for configuring authentication of the request atn-token/jwk-* Configuration of the JWK to obtain key(s) to validate signatures of inbound token. The JWK should contain public keys. This may be: jwk-path, jwk-resource-path, jwk-url, jwk-content-plain (actual JSON string), jwk-content (base64) atn-token/handler Authorization bearer A handler configuration for inbound token - e.g. how to extract it atn-token/handler/header Authorization Name of a header the token is expected in atn-token/handler/prefix bearer Prefix before the token value (optional) atn-token/handler/regexp Regular expression to obtain the token, first matching group is used (optional) sign-token A group for configuring outbound security sign-token/jwk-* Configuration of the JWK to use when generating tokens (follows same rules as atn-token/jwk above), this JWK must contain private keys when using asymmetric ciphers sign-token/jwt-issuer When we issue a new token, this is the issuer to be placed into it (validated by target service) sign-token/outbound A group for configuring outbound rules (based on transport, host and/or path) sign-token/outbound/name A short descriptive name for configured target service(s) sign-token/outbound/transports * An array of transports this outbound matches (e.g. https) sign-token/outbound/hosts * An array of hosts this outbound matches, may use * as a a wild-card (e.g. *.oracle.com) sign-token/outbound/paths * An array of paths on the host this outbound matches, may use * as a wild-card (e.g. /some/path/*) sign-token/outbound/outbound-token Authorization bearer Configuration of outbound token handler (same as atn-token/handler) sign-token/outbound/outbound-token/format Java text format for generating the value of outbound token header (e.g. \"bearer %1$s\") sign-token/outbound/jwk-kid If this key is defined, we are generating a new token, otherwise we propagate existing. Defines the key id of a key definition in the JWK file to use for signing the outbound token sign-token/outbound/jwt-kid A key to use in the generated JWT - this is for the other service to locate the verification key in their JWK sign-token/outbound/jwt-audience Audience this key is generated for (e.g. http://www.example.org/api/myService ) - validated by the other service sign-token/outbound/jwt-not-before-seconds 5 Makes this key valid this amount of seconds into the past. Allows a certain time-skew for the generated token to be valid before current time (e.g. when we expect a certain misalignment of clocks) sign-token/outbound/jwt-validity-seconds 1 day Token validity in seconds Example configuration with authentication and outbound security: <markup lang=\"yaml\" >- jwt: atn-token: jwk-path: \"/config/securiy/verify-jwk.json\" sign-token: jwk-path: \"/config/security/sign-jwk.json\" jwt-issuer: \"http://www.example.org/myservice\" outbound: - name: \"internal-services\" # create a new token hosts: - \"*.example.org\" jwk-kid: \"internal-key\" jwt-audience: \"http://www.example.org/services\" - name: \"b2b-service-49\" # create a new token and send it in a custom header hosts: - \"b2b.partner.org\" paths: - \"/services/49\" jwk-kid: \"partner-b2b\" jwt-audience: \"http://b2b.partner.org\" outbound-token: header: \"X-Partner-Auth\" - name: \"as-is\" # identity propagation (use existing token) hosts: - \"*.internal.org\" ",
            "title": "Configuration Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " JSON Web Token (JWT) provider has support for authentication and outbound security. Authentication is based on validating the token (signature, valid before etc.) and on asserting the subject of the JWT subject claim. For outbound, we support either token propagation (e.g. the token from request is propagated further) or support for generating a brand new token based on configuration of this provider. Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-jwt Provider package io.helidon.security.providers.jwt Provider class JwtProvider Provider key jwt This provider is: Authentication Provider Outbound Security Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-jwt&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description optional  false If set to true, the provider will return \"ABSTAIN\" rather than \"FAILURE\" if token is not present in request authenticate true Whether to attempt authentication propagate true Whether to attempt identity propagation/JWT creation principal-type USER Whether we authenticate a user or a service (other option is SERVICE) atn-token A group for configuring authentication of the request atn-token/jwk-* Configuration of the JWK to obtain key(s) to validate signatures of inbound token. The JWK should contain public keys. This may be: jwk-path, jwk-resource-path, jwk-url, jwk-content-plain (actual JSON string), jwk-content (base64) atn-token/handler Authorization bearer A handler configuration for inbound token - e.g. how to extract it atn-token/handler/header Authorization Name of a header the token is expected in atn-token/handler/prefix bearer Prefix before the token value (optional) atn-token/handler/regexp Regular expression to obtain the token, first matching group is used (optional) sign-token A group for configuring outbound security sign-token/jwk-* Configuration of the JWK to use when generating tokens (follows same rules as atn-token/jwk above), this JWK must contain private keys when using asymmetric ciphers sign-token/jwt-issuer When we issue a new token, this is the issuer to be placed into it (validated by target service) sign-token/outbound A group for configuring outbound rules (based on transport, host and/or path) sign-token/outbound/name A short descriptive name for configured target service(s) sign-token/outbound/transports * An array of transports this outbound matches (e.g. https) sign-token/outbound/hosts * An array of hosts this outbound matches, may use * as a a wild-card (e.g. *.oracle.com) sign-token/outbound/paths * An array of paths on the host this outbound matches, may use * as a wild-card (e.g. /some/path/*) sign-token/outbound/outbound-token Authorization bearer Configuration of outbound token handler (same as atn-token/handler) sign-token/outbound/outbound-token/format Java text format for generating the value of outbound token header (e.g. \"bearer %1$s\") sign-token/outbound/jwk-kid If this key is defined, we are generating a new token, otherwise we propagate existing. Defines the key id of a key definition in the JWK file to use for signing the outbound token sign-token/outbound/jwt-kid A key to use in the generated JWT - this is for the other service to locate the verification key in their JWK sign-token/outbound/jwt-audience Audience this key is generated for (e.g. http://www.example.org/api/myService ) - validated by the other service sign-token/outbound/jwt-not-before-seconds 5 Makes this key valid this amount of seconds into the past. Allows a certain time-skew for the generated token to be valid before current time (e.g. when we expect a certain misalignment of clocks) sign-token/outbound/jwt-validity-seconds 1 day Token validity in seconds Example configuration with authentication and outbound security: <markup lang=\"yaml\" >- jwt: atn-token: jwk-path: \"/config/securiy/verify-jwk.json\" sign-token: jwk-path: \"/config/security/sign-jwk.json\" jwt-issuer: \"http://www.example.org/myservice\" outbound: - name: \"internal-services\" # create a new token hosts: - \"*.example.org\" jwk-kid: \"internal-key\" jwt-audience: \"http://www.example.org/services\" - name: \"b2b-service-49\" # create a new token and send it in a custom header hosts: - \"b2b.partner.org\" paths: - \"/services/49\" jwk-kid: \"partner-b2b\" jwt-audience: \"http://b2b.partner.org\" outbound-token: header: \"X-Partner-Auth\" - name: \"as-is\" # identity propagation (use existing token) hosts: - \"*.internal.org\" ",
            "title": "JWT Provider"
        },
        {
            "location": "/security/02_providers",
            "text": " All configuration options: key default value description realm  helidon Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users none A list of users (login, password and roles). Currently to externalize this you must use builder approach. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-basic-auth: users: - login: \"jack\" password: \"jackIsGreat\" roles: [\"user\", \"admin\"] Example configuration with a single user (may have more) using secured config filter (to encrypt passwords) - in this example, the password is intentionally in clear text to show its value (see Configuration Secrets ) <markup lang=\"yaml\" >- http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] ",
            "title": "Configuration Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpBasicAuthProvider.builder() .realm(\"helidon\") .subjectType(SubjectType.SERVICE) .userStore(aUserStore) .build(); ",
            "title": "Builder Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Basic authentication support authentication of request and identity propagation for outbound calls. Outbound security with basic authentication only works if the request is authenticated with basic authentication (e.g. we re-use the username and password from inbound request). Basic authentication is an HTTP header named Authorization with value of basic base64(username:password) . This provider also supports \"challenging\" the client to provide basic authentication if missing from request. See https://tools.ietf.org/html/rfc7617 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-http-auth Provider package io.helidon.security.providers.httpauth Provider class HttpBasicAuthProvider Provider key http-basic-auth This provider is: Authentication Provider Outbound Security Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description realm  helidon Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users none A list of users (login, password and roles). Currently to externalize this you must use builder approach. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-basic-auth: users: - login: \"jack\" password: \"jackIsGreat\" roles: [\"user\", \"admin\"] Example configuration with a single user (may have more) using secured config filter (to encrypt passwords) - in this example, the password is intentionally in clear text to show its value (see Configuration Secrets ) <markup lang=\"yaml\" >- http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder Based Approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpBasicAuthProvider.builder() .realm(\"helidon\") .subjectType(SubjectType.SERVICE) .userStore(aUserStore) .build(); ",
            "title": "HTTP Basic Authentication Provider"
        },
        {
            "location": "/security/02_providers",
            "text": " All configuration options: key default value description realm helidon Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users none A list of users (login, password and roles). Currently to externalize this you must use builder approach. algorithm MD5 Only MD5 supported nonce-timeout-millis 1 day Number of milliseconds for the nonce timeout server-secret random A string to use as a server secret - this is to use digest auth between multiple servers (e.g. when in a cluster). Used to encrypt nonce. This must not be known outside of this app, as others may create digest requests we would trust. qop NONE only AUTH supported. If left empty, uses the legacy approach (older RFC version). AUTH-INT is not supported. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-digest-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] ",
            "title": "Configuration based approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpDigestAuthProvider.builder() .realm(\"helidon\") .digestServerSecret(\"aPassword\".toCharArray()) .userStore(buildUserStore()) ",
            "title": "Builder based approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Digest authentication provider supports only authentication of inbound requests (no outbound). This provider also supports \"challenging\" the client to provide digest authentication if missing from request. See https://tools.ietf.org/html/rfc7616 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-http-auth Provider package io.helidon.security.providers.httpauth Provider class HttpDigestAuthProvider Provider key http-digest-auth This provider is: Authentication Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration based approach All configuration options: key default value description realm helidon Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users none A list of users (login, password and roles). Currently to externalize this you must use builder approach. algorithm MD5 Only MD5 supported nonce-timeout-millis 1 day Number of milliseconds for the nonce timeout server-secret random A string to use as a server secret - this is to use digest auth between multiple servers (e.g. when in a cluster). Used to encrypt nonce. This must not be known outside of this app, as others may create digest requests we would trust. qop NONE only AUTH supported. If left empty, uses the legacy approach (older RFC version). AUTH-INT is not supported. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-digest-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder based approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpDigestAuthProvider.builder() .realm(\"helidon\") .digestServerSecret(\"aPassword\".toCharArray()) .userStore(buildUserStore()) ",
            "title": "HTTP Digest Authentication"
        },
        {
            "location": "/security/02_providers",
            "text": " All configuration options: key default value description optional  false If set to true, provider will abstain rather then fail if header not available authenticate true If set to false, authentication will not be attempted propagate true If set to false, identity propagation will not be done principal-type USER Can be USER or SERVICE atn-token none Token extraction and propagation, you can define which header to use and how to extract it outbound-token atn-token If outbound token should be created differently than inbound Example configuration: <markup lang=\"yaml\" >- header-atn: optional: true principal-type: SERVICE atn-token: header: \"X-AUTH-USER\" outbound-token: header: \"Authorization\" format: \"bearer %1$s\" ",
            "title": "Configuration Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " Example of a builder that configures the provider the same way as the above configuration approach. <markup lang=\"java\" >HeaderAtnProvider.builder() .optional(true) .subjectType(SubjectType.SERVICE) .atnTokenHandler(TokenHandler.builder() .tokenHeader(\"X-AUTH-USER\") .build()) .outboundTokenHandler(TokenHandler.builder() .tokenHeader(\"Authorization\") .tokenFormat(\"bearer %1$s\") .build()) .build(); ",
            "title": "Builder Based Approach"
        },
        {
            "location": "/security/02_providers",
            "text": " This provider inspects a specified request header and extracts the username/service name from it and asserts it as current subject&#8217;s principal. This can be used when we use perimether authentication (e.g. there is a gateway that takes care of authentication and propagates the user in a header). Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-header Provider package io.helidon.security.providers.header Provider class HeaderAtnProvider Provider key header-atn This provider is: Authentication Provider Outbound Security Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-header&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description optional  false If set to true, provider will abstain rather then fail if header not available authenticate true If set to false, authentication will not be attempted propagate true If set to false, identity propagation will not be done principal-type USER Can be USER or SERVICE atn-token none Token extraction and propagation, you can define which header to use and how to extract it outbound-token atn-token If outbound token should be created differently than inbound Example configuration: <markup lang=\"yaml\" >- header-atn: optional: true principal-type: SERVICE atn-token: header: \"X-AUTH-USER\" outbound-token: header: \"Authorization\" format: \"bearer %1$s\" Builder Based Approach Example of a builder that configures the provider the same way as the above configuration approach. <markup lang=\"java\" >HeaderAtnProvider.builder() .optional(true) .subjectType(SubjectType.SERVICE) .atnTokenHandler(TokenHandler.builder() .tokenHeader(\"X-AUTH-USER\") .build()) .outboundTokenHandler(TokenHandler.builder() .tokenHeader(\"Authorization\") .tokenFormat(\"bearer %1$s\") .build()) .build(); ",
            "title": "Header Authentication Provider"
        },
        {
            "location": "/security/02_providers",
            "text": " standard: based on https://tools.ietf.org/html/draft-cavage-http-signatures-03 key-id: an arbitrary string used to locate signature configuration - when a request is received the provider locates validation configuration based on this id (e.g. HMAC shared secret or RSA public key). Commonly used meanings are: key fingerprint (RSA); API Key ",
            "title": "Signature basics"
        },
        {
            "location": "/security/02_providers",
            "text": " We act as a server and another party is calling us with a signed HTTP request. We validate the signature and assume identity of the caller. Builder example, starting from inside out: <markup lang=\"java\" title=\"Inbound signature configuration\" >// Configuration of public key certificate to validate inbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.create(Paths.get(\"keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .certAlias(\"service_cert\") .build(); // Create inbound client definition (e.g. map key-id to a public key and principal name) InboundClientDefinition rsaInbound = InboundClientDefinition.builder(\"service1-rsa\") .principalName(\"Service1\") .publicKeyConfig(keyConfig) .build(); // Now create a HTTP signature provider with inbound support (with a single supported signature) HttpSignProvider.builder() .addInbound(rsaInbound) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { inbound { keys: [ { key-id = \"service1-hmac\" # name of principal of the connecting party principal-name = \"Service1\" # SERVICE or USER, defaults to SERVICE principal-type = SERVICE # defaults to the one we configure (e.g. if hmac.secret is configured # it is hmac-sha256; if public-key is configured, it is rsa-sha256) algorithm = \"hmac-sha256\" # shared secret for symmetric signatures hmac.secret = \"${CLEAR=encryptMe}\" }, { key-id = \"service1-rsa\" principal-name = \"Service1\" # configuration of public key to validate signature public-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # defaults to PKCS12 keystore-type = \"PKCS12\" # password of the keystore # the ${CLEAR=} is a feature of keystore-passphrase = \"${CLEAR=password}\" # alias of the certificate to get public key from cert-alias = \"service_cert\" } } ] } } ",
            "title": "Inbound signatures"
        },
        {
            "location": "/security/02_providers",
            "text": " We act as a client and we sign our outgoing requests. Builder example, starting from inside out (rsa only, as hmac is significantly simpler): <markup lang=\"java\" title=\"Outbound signature configuration\" >// Configuration of private key to sign outbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.create(Paths.get(\"src/main/resources/keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .keyAlias(\"myPrivateKey\") .build(); OutboundTarget rsaTarget = OutboundTarget.builder(\"service2-rsa\") .addHost(\"service2\") // considering service registry .addPath(\"/service2-rsa\") .customObject(OutboundTargetDefinition.class, OutboundTargetDefinition.builder(\"service1-rsa\") .privateKeyConfig(keyConfig) .build()) .build(); // Now create a HTTP signature provider with outbound support (with a single supported signature) HttpSignProvider.builder() .outbound(OutboundConfig.builder() .addTarget(rsaTarget) .build()) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { outbound: [ { # Logical name of this outbound configuration name = \"service2-trust-circle\" # If ommited or one value is \"*\", all are supported transports = [\"http\", \"https\"] # If ommited or one value is \"*\", all are supported, may contain * as a sequence \"any\" characters/nubmers hosts = [\"service2\"] # If ommited, all are supported - regular expression paths = [\"/service2\"] # Configuration of signature (signing the request) signature { key-id = \"service2-shared-secret\" # HMAC shared secret (algorithm hmac-sha256) hmac.secret = \"${CLEAR=somePasswordForHmacShouldBeEncrypted}\" } }, { name = \"service2-rsa\" hosts = [\"service2\"] paths = [\"/service2-rsa\"] signature { key-id = \"service1-rsa\" # RSA private key (algorithm rsa-sha256) private-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # Keystore type # PKCS12, JSK or RSA (not really a keystore, but directly the linux style private key unencrypted) # defaults to jdk default keystore-type = \"PKCS12\" # password of the keystore keystore-passphrase = \"password\" # alias of the key to sign request key-alias = \"myPrivateKey\" } } } ] } ",
            "title": "Outbound signatures"
        },
        {
            "location": "/security/02_providers",
            "text": " Support for HTTP Signatures (both inbound and outbound). <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers -http-sign&lt;/artifactId&gt; &lt;/dependency&gt; Signature basics standard: based on https://tools.ietf.org/html/draft-cavage-http-signatures-03 key-id: an arbitrary string used to locate signature configuration - when a request is received the provider locates validation configuration based on this id (e.g. HMAC shared secret or RSA public key). Commonly used meanings are: key fingerprint (RSA); API Key Inbound signatures We act as a server and another party is calling us with a signed HTTP request. We validate the signature and assume identity of the caller. Builder example, starting from inside out: <markup lang=\"java\" title=\"Inbound signature configuration\" >// Configuration of public key certificate to validate inbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.create(Paths.get(\"keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .certAlias(\"service_cert\") .build(); // Create inbound client definition (e.g. map key-id to a public key and principal name) InboundClientDefinition rsaInbound = InboundClientDefinition.builder(\"service1-rsa\") .principalName(\"Service1\") .publicKeyConfig(keyConfig) .build(); // Now create a HTTP signature provider with inbound support (with a single supported signature) HttpSignProvider.builder() .addInbound(rsaInbound) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { inbound { keys: [ { key-id = \"service1-hmac\" # name of principal of the connecting party principal-name = \"Service1\" # SERVICE or USER, defaults to SERVICE principal-type = SERVICE # defaults to the one we configure (e.g. if hmac.secret is configured # it is hmac-sha256; if public-key is configured, it is rsa-sha256) algorithm = \"hmac-sha256\" # shared secret for symmetric signatures hmac.secret = \"${CLEAR=encryptMe}\" }, { key-id = \"service1-rsa\" principal-name = \"Service1\" # configuration of public key to validate signature public-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # defaults to PKCS12 keystore-type = \"PKCS12\" # password of the keystore # the ${CLEAR=} is a feature of keystore-passphrase = \"${CLEAR=password}\" # alias of the certificate to get public key from cert-alias = \"service_cert\" } } ] } } Outbound signatures We act as a client and we sign our outgoing requests. Builder example, starting from inside out (rsa only, as hmac is significantly simpler): <markup lang=\"java\" title=\"Outbound signature configuration\" >// Configuration of private key to sign outbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.create(Paths.get(\"src/main/resources/keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .keyAlias(\"myPrivateKey\") .build(); OutboundTarget rsaTarget = OutboundTarget.builder(\"service2-rsa\") .addHost(\"service2\") // considering service registry .addPath(\"/service2-rsa\") .customObject(OutboundTargetDefinition.class, OutboundTargetDefinition.builder(\"service1-rsa\") .privateKeyConfig(keyConfig) .build()) .build(); // Now create a HTTP signature provider with outbound support (with a single supported signature) HttpSignProvider.builder() .outbound(OutboundConfig.builder() .addTarget(rsaTarget) .build()) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { outbound: [ { # Logical name of this outbound configuration name = \"service2-trust-circle\" # If ommited or one value is \"*\", all are supported transports = [\"http\", \"https\"] # If ommited or one value is \"*\", all are supported, may contain * as a sequence \"any\" characters/nubmers hosts = [\"service2\"] # If ommited, all are supported - regular expression paths = [\"/service2\"] # Configuration of signature (signing the request) signature { key-id = \"service2-shared-secret\" # HMAC shared secret (algorithm hmac-sha256) hmac.secret = \"${CLEAR=somePasswordForHmacShouldBeEncrypted}\" } }, { name = \"service2-rsa\" hosts = [\"service2\"] paths = [\"/service2-rsa\"] signature { key-id = \"service1-rsa\" # RSA private key (algorithm rsa-sha256) private-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # Keystore type # PKCS12, JSK or RSA (not really a keystore, but directly the linux style private key unencrypted) # defaults to jdk default keystore-type = \"PKCS12\" # password of the keystore keystore-passphrase = \"password\" # alias of the key to sign request key-alias = \"myPrivateKey\" } } } ] } ",
            "title": "HTTP Signatures"
        },
        {
            "location": "/security/02_providers",
            "text": " Checks whether user/service is in role(s) Configuration Key: role-validator Annotations: @RolesAllowed, @Roles <markup lang=\"java\" title=\"Example\" >@Roles(\"user_role\") @Roles(value = \"service_role\", subjectType = SubjectType.SERVICE) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Role Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " Checks whether user has the defined scopes Configuration Key: scope-validator Annotations: @Scope <markup lang=\"java\" title=\"Example\" >@Scope(\"calendar_read\") @Scope(\"calendar_edit\") @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Scope Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " Policy executor using Java EE policy expression language (EL) Configuration Key: policy-javax-el Annotations: @PolicyStatement <markup lang=\"java\" title=\"Example\" >@PolicyStatement(\"${env.time.year &gt;= 2017}\") @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Expression Language Policy Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " Supports time of day and day of week checks Configuration Key: time-validator Annotations: @DaysOfWeek, @TimesOfDay <markup lang=\"java\" title=\"Example\" >@TimeOfDay(from = \"08:15:00\", to = \"12:00:00\") @TimeOfDay(from = \"12:30:00\", to = \"17:30:00\") @DaysOfWeek({DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY}) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Time Validator"
        },
        {
            "location": "/security/02_providers",
            "text": " This provider is an authorization provider validating various attributes against configured validators. Any attribute of the following objects can be used: environment (such as time of request) - e.g. env.time.year subject (user) - e.g. subject.principal.id subject (service) - e.g. service.principal.id object (must be explicitly invoked by developer in code, as object cannot be automatically added to security context) - e.g. object.owner This provider checks that all defined ABAC validators are validated. If there is a definition for a validator (e.g. an annotation) that is not checked, the request is denied. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-abac&lt;/artifactId&gt; &lt;/dependency&gt; The following validators are implemented: Roles Scopes EL Policy Time <markup lang=\"java\" title=\"Example of using an object\" >@Authenticated @Path(\"/abac\") public class AbacResource { @GET @Authorized(explicit = true) @PolicyStatement(\"${env.time.year &gt;= 2017 &amp;&amp; object.owner == subject.principal.id}\") public Response process(@Context SecurityContext context) { // probably looked up from a database SomeResource res = new SomeResource(\"user\"); AuthorizationResponse atzResponse = context.authorize(res); if (atzResponse.isPermitted()) { //do the update return Response.ok().entity(\"fine, sir\").build(); } else { return Response.status(Response.Status.FORBIDDEN) .entity(atzResponse.getDescription().orElse(\"Access not granted\")) .build(); } } } Role Validator Checks whether user/service is in role(s) Configuration Key: role-validator Annotations: @RolesAllowed, @Roles <markup lang=\"java\" title=\"Example\" >@Roles(\"user_role\") @Roles(value = \"service_role\", subjectType = SubjectType.SERVICE) @Authenticated @Path(\"/abac\") public class AbacResource { } Scope Validator Checks whether user has the defined scopes Configuration Key: scope-validator Annotations: @Scope <markup lang=\"java\" title=\"Example\" >@Scope(\"calendar_read\") @Scope(\"calendar_edit\") @Authenticated @Path(\"/abac\") public class AbacResource { } Expression Language Policy Validator Policy executor using Java EE policy expression language (EL) Configuration Key: policy-javax-el Annotations: @PolicyStatement <markup lang=\"java\" title=\"Example\" >@PolicyStatement(\"${env.time.year &gt;= 2017}\") @Authenticated @Path(\"/abac\") public class AbacResource { } Time Validator Supports time of day and day of week checks Configuration Key: time-validator Annotations: @DaysOfWeek, @TimesOfDay <markup lang=\"java\" title=\"Example\" >@TimeOfDay(from = \"08:15:00\", to = \"12:00:00\") @TimeOfDay(from = \"12:30:00\", to = \"17:30:00\") @DaysOfWeek({DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY}) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "ABAC (Attribute based access control) Authorization Provider"
        },
        {
            "location": "/security/02_providers",
            "text": " The following providers are implemented: JWT Provider HTTP Basic Authentication HTTP Digest Authentication Header Assertion HTTP Signatures ABAC Authorization Google Login Authentication Provider please see security example: https://github.com/oracle/helidon/tree/master/examples/security/google-login OIDC (Open ID Connect) Authentication provider - an OAuth extension for authentication please see security example: https://github.com/oracle/helidon/tree/master/examples/security/idcs-login IDCS Role Mapping Provider - a role mapper that can be used with any authentication provider, retrieves roles from IDCS please see security example: https://github.com/oracle/helidon/tree/master/examples/security/idcs-login JWT Provider JSON Web Token (JWT) provider has support for authentication and outbound security. Authentication is based on validating the token (signature, valid before etc.) and on asserting the subject of the JWT subject claim. For outbound, we support either token propagation (e.g. the token from request is propagated further) or support for generating a brand new token based on configuration of this provider. Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-jwt Provider package io.helidon.security.providers.jwt Provider class JwtProvider Provider key jwt This provider is: Authentication Provider Outbound Security Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-jwt&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description optional  false If set to true, the provider will return \"ABSTAIN\" rather than \"FAILURE\" if token is not present in request authenticate true Whether to attempt authentication propagate true Whether to attempt identity propagation/JWT creation principal-type USER Whether we authenticate a user or a service (other option is SERVICE) atn-token A group for configuring authentication of the request atn-token/jwk-* Configuration of the JWK to obtain key(s) to validate signatures of inbound token. The JWK should contain public keys. This may be: jwk-path, jwk-resource-path, jwk-url, jwk-content-plain (actual JSON string), jwk-content (base64) atn-token/handler Authorization bearer A handler configuration for inbound token - e.g. how to extract it atn-token/handler/header Authorization Name of a header the token is expected in atn-token/handler/prefix bearer Prefix before the token value (optional) atn-token/handler/regexp Regular expression to obtain the token, first matching group is used (optional) sign-token A group for configuring outbound security sign-token/jwk-* Configuration of the JWK to use when generating tokens (follows same rules as atn-token/jwk above), this JWK must contain private keys when using asymmetric ciphers sign-token/jwt-issuer When we issue a new token, this is the issuer to be placed into it (validated by target service) sign-token/outbound A group for configuring outbound rules (based on transport, host and/or path) sign-token/outbound/name A short descriptive name for configured target service(s) sign-token/outbound/transports * An array of transports this outbound matches (e.g. https) sign-token/outbound/hosts * An array of hosts this outbound matches, may use * as a a wild-card (e.g. *.oracle.com) sign-token/outbound/paths * An array of paths on the host this outbound matches, may use * as a wild-card (e.g. /some/path/*) sign-token/outbound/outbound-token Authorization bearer Configuration of outbound token handler (same as atn-token/handler) sign-token/outbound/outbound-token/format Java text format for generating the value of outbound token header (e.g. \"bearer %1$s\") sign-token/outbound/jwk-kid If this key is defined, we are generating a new token, otherwise we propagate existing. Defines the key id of a key definition in the JWK file to use for signing the outbound token sign-token/outbound/jwt-kid A key to use in the generated JWT - this is for the other service to locate the verification key in their JWK sign-token/outbound/jwt-audience Audience this key is generated for (e.g. http://www.example.org/api/myService ) - validated by the other service sign-token/outbound/jwt-not-before-seconds 5 Makes this key valid this amount of seconds into the past. Allows a certain time-skew for the generated token to be valid before current time (e.g. when we expect a certain misalignment of clocks) sign-token/outbound/jwt-validity-seconds 1 day Token validity in seconds Example configuration with authentication and outbound security: <markup lang=\"yaml\" >- jwt: atn-token: jwk-path: \"/config/securiy/verify-jwk.json\" sign-token: jwk-path: \"/config/security/sign-jwk.json\" jwt-issuer: \"http://www.example.org/myservice\" outbound: - name: \"internal-services\" # create a new token hosts: - \"*.example.org\" jwk-kid: \"internal-key\" jwt-audience: \"http://www.example.org/services\" - name: \"b2b-service-49\" # create a new token and send it in a custom header hosts: - \"b2b.partner.org\" paths: - \"/services/49\" jwk-kid: \"partner-b2b\" jwt-audience: \"http://b2b.partner.org\" outbound-token: header: \"X-Partner-Auth\" - name: \"as-is\" # identity propagation (use existing token) hosts: - \"*.internal.org\" HTTP Basic Authentication Provider Basic authentication support authentication of request and identity propagation for outbound calls. Outbound security with basic authentication only works if the request is authenticated with basic authentication (e.g. we re-use the username and password from inbound request). Basic authentication is an HTTP header named Authorization with value of basic base64(username:password) . This provider also supports \"challenging\" the client to provide basic authentication if missing from request. See https://tools.ietf.org/html/rfc7617 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-http-auth Provider package io.helidon.security.providers.httpauth Provider class HttpBasicAuthProvider Provider key http-basic-auth This provider is: Authentication Provider Outbound Security Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description realm  helidon Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users none A list of users (login, password and roles). Currently to externalize this you must use builder approach. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-basic-auth: users: - login: \"jack\" password: \"jackIsGreat\" roles: [\"user\", \"admin\"] Example configuration with a single user (may have more) using secured config filter (to encrypt passwords) - in this example, the password is intentionally in clear text to show its value (see Configuration Secrets ) <markup lang=\"yaml\" >- http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder Based Approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpBasicAuthProvider.builder() .realm(\"helidon\") .subjectType(SubjectType.SERVICE) .userStore(aUserStore) .build(); HTTP Digest Authentication Digest authentication provider supports only authentication of inbound requests (no outbound). This provider also supports \"challenging\" the client to provide digest authentication if missing from request. See https://tools.ietf.org/html/rfc7616 . These authentication schemes should be obsolete , though they provide a very easy way to test a protected resource. Note that basic authentication sends username and password unencrypted over the network! Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-http-auth Provider package io.helidon.security.providers.httpauth Provider class HttpDigestAuthProvider Provider key http-digest-auth This provider is: Authentication Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-http-auth&lt;/artifactId&gt; &lt;/dependency&gt; Configuration based approach All configuration options: key default value description realm helidon Authentication realm - may be shown to user by browser principal-type USER Type of subject authenticated by this provider - USER or SERVICE users none A list of users (login, password and roles). Currently to externalize this you must use builder approach. algorithm MD5 Only MD5 supported nonce-timeout-millis 1 day Number of milliseconds for the nonce timeout server-secret random A string to use as a server secret - this is to use digest auth between multiple servers (e.g. when in a cluster). Used to encrypt nonce. This must not be known outside of this app, as others may create digest requests we would trust. qop NONE only AUTH supported. If left empty, uses the legacy approach (older RFC version). AUTH-INT is not supported. Example configuration with a single user (may have more): <markup lang=\"yaml\" >- http-digest-auth: realm: \"helidon\" users: - login: \"jack\" password: \"${CLEAR=jackIsGreat}\" roles: [\"user\", \"admin\"] Builder based approach Example of builder with a user store (UserStore is an interface that must be implemented). There is an existing implementation \"ConfigUserStore\" that can read configuration of users from Helidon config instance (see \"users\" configuration key above). The built instance can then be registered with security to be used for request authentication. <markup lang=\"java\" >HttpDigestAuthProvider.builder() .realm(\"helidon\") .digestServerSecret(\"aPassword\".toCharArray()) .userStore(buildUserStore()) Header Authentication Provider This provider inspects a specified request header and extracts the username/service name from it and asserts it as current subject&#8217;s principal. This can be used when we use perimether authentication (e.g. there is a gateway that takes care of authentication and propagates the user in a header). Property Value Maven groupId io.helidon.security.providers Maven artifactId helidon-security-providers-header Provider package io.helidon.security.providers.header Provider class HeaderAtnProvider Provider key header-atn This provider is: Authentication Provider Outbound Security Provider <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-header&lt;/artifactId&gt; &lt;/dependency&gt; Configuration Based Approach All configuration options: key default value description optional  false If set to true, provider will abstain rather then fail if header not available authenticate true If set to false, authentication will not be attempted propagate true If set to false, identity propagation will not be done principal-type USER Can be USER or SERVICE atn-token none Token extraction and propagation, you can define which header to use and how to extract it outbound-token atn-token If outbound token should be created differently than inbound Example configuration: <markup lang=\"yaml\" >- header-atn: optional: true principal-type: SERVICE atn-token: header: \"X-AUTH-USER\" outbound-token: header: \"Authorization\" format: \"bearer %1$s\" Builder Based Approach Example of a builder that configures the provider the same way as the above configuration approach. <markup lang=\"java\" >HeaderAtnProvider.builder() .optional(true) .subjectType(SubjectType.SERVICE) .atnTokenHandler(TokenHandler.builder() .tokenHeader(\"X-AUTH-USER\") .build()) .outboundTokenHandler(TokenHandler.builder() .tokenHeader(\"Authorization\") .tokenFormat(\"bearer %1$s\") .build()) .build(); HTTP Signatures Support for HTTP Signatures (both inbound and outbound). <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers -http-sign&lt;/artifactId&gt; &lt;/dependency&gt; Signature basics standard: based on https://tools.ietf.org/html/draft-cavage-http-signatures-03 key-id: an arbitrary string used to locate signature configuration - when a request is received the provider locates validation configuration based on this id (e.g. HMAC shared secret or RSA public key). Commonly used meanings are: key fingerprint (RSA); API Key Inbound signatures We act as a server and another party is calling us with a signed HTTP request. We validate the signature and assume identity of the caller. Builder example, starting from inside out: <markup lang=\"java\" title=\"Inbound signature configuration\" >// Configuration of public key certificate to validate inbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.create(Paths.get(\"keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .certAlias(\"service_cert\") .build(); // Create inbound client definition (e.g. map key-id to a public key and principal name) InboundClientDefinition rsaInbound = InboundClientDefinition.builder(\"service1-rsa\") .principalName(\"Service1\") .publicKeyConfig(keyConfig) .build(); // Now create a HTTP signature provider with inbound support (with a single supported signature) HttpSignProvider.builder() .addInbound(rsaInbound) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { inbound { keys: [ { key-id = \"service1-hmac\" # name of principal of the connecting party principal-name = \"Service1\" # SERVICE or USER, defaults to SERVICE principal-type = SERVICE # defaults to the one we configure (e.g. if hmac.secret is configured # it is hmac-sha256; if public-key is configured, it is rsa-sha256) algorithm = \"hmac-sha256\" # shared secret for symmetric signatures hmac.secret = \"${CLEAR=encryptMe}\" }, { key-id = \"service1-rsa\" principal-name = \"Service1\" # configuration of public key to validate signature public-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # defaults to PKCS12 keystore-type = \"PKCS12\" # password of the keystore # the ${CLEAR=} is a feature of keystore-passphrase = \"${CLEAR=password}\" # alias of the certificate to get public key from cert-alias = \"service_cert\" } } ] } } Outbound signatures We act as a client and we sign our outgoing requests. Builder example, starting from inside out (rsa only, as hmac is significantly simpler): <markup lang=\"java\" title=\"Outbound signature configuration\" >// Configuration of private key to sign outbound requests KeyConfig keyConfig = KeyConfig.keystoreBuilder() .keystore(Resource.create(Paths.get(\"src/main/resources/keystore.p12\"))) .keystorePassphrase(\"password\".toCharArray()) .keyAlias(\"myPrivateKey\") .build(); OutboundTarget rsaTarget = OutboundTarget.builder(\"service2-rsa\") .addHost(\"service2\") // considering service registry .addPath(\"/service2-rsa\") .customObject(OutboundTargetDefinition.class, OutboundTargetDefinition.builder(\"service1-rsa\") .privateKeyConfig(keyConfig) .build()) .build(); // Now create a HTTP signature provider with outbound support (with a single supported signature) HttpSignProvider.builder() .outbound(OutboundConfig.builder() .addTarget(rsaTarget) .build()) .build(); Configuration examples for hmac-sha256 and rsa-sha256 algorithms (as supported by this provider): <markup lang=\"conf\" title=\"Inbound signature configuration\" >http-signatures { outbound: [ { # Logical name of this outbound configuration name = \"service2-trust-circle\" # If ommited or one value is \"*\", all are supported transports = [\"http\", \"https\"] # If ommited or one value is \"*\", all are supported, may contain * as a sequence \"any\" characters/nubmers hosts = [\"service2\"] # If ommited, all are supported - regular expression paths = [\"/service2\"] # Configuration of signature (signing the request) signature { key-id = \"service2-shared-secret\" # HMAC shared secret (algorithm hmac-sha256) hmac.secret = \"${CLEAR=somePasswordForHmacShouldBeEncrypted}\" } }, { name = \"service2-rsa\" hosts = [\"service2\"] paths = [\"/service2-rsa\"] signature { key-id = \"service1-rsa\" # RSA private key (algorithm rsa-sha256) private-key { # path to keystore keystore-path = \"src/main/resources/keystore.p12\" # Keystore type # PKCS12, JSK or RSA (not really a keystore, but directly the linux style private key unencrypted) # defaults to jdk default keystore-type = \"PKCS12\" # password of the keystore keystore-passphrase = \"password\" # alias of the key to sign request key-alias = \"myPrivateKey\" } } } ] } ABAC (Attribute based access control) Authorization Provider This provider is an authorization provider validating various attributes against configured validators. Any attribute of the following objects can be used: environment (such as time of request) - e.g. env.time.year subject (user) - e.g. subject.principal.id subject (service) - e.g. service.principal.id object (must be explicitly invoked by developer in code, as object cannot be automatically added to security context) - e.g. object.owner This provider checks that all defined ABAC validators are validated. If there is a definition for a validator (e.g. an annotation) that is not checked, the request is denied. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.providers&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-providers-abac&lt;/artifactId&gt; &lt;/dependency&gt; The following validators are implemented: Roles Scopes EL Policy Time <markup lang=\"java\" title=\"Example of using an object\" >@Authenticated @Path(\"/abac\") public class AbacResource { @GET @Authorized(explicit = true) @PolicyStatement(\"${env.time.year &gt;= 2017 &amp;&amp; object.owner == subject.principal.id}\") public Response process(@Context SecurityContext context) { // probably looked up from a database SomeResource res = new SomeResource(\"user\"); AuthorizationResponse atzResponse = context.authorize(res); if (atzResponse.isPermitted()) { //do the update return Response.ok().entity(\"fine, sir\").build(); } else { return Response.status(Response.Status.FORBIDDEN) .entity(atzResponse.getDescription().orElse(\"Access not granted\")) .build(); } } } Role Validator Checks whether user/service is in role(s) Configuration Key: role-validator Annotations: @RolesAllowed, @Roles <markup lang=\"java\" title=\"Example\" >@Roles(\"user_role\") @Roles(value = \"service_role\", subjectType = SubjectType.SERVICE) @Authenticated @Path(\"/abac\") public class AbacResource { } Scope Validator Checks whether user has the defined scopes Configuration Key: scope-validator Annotations: @Scope <markup lang=\"java\" title=\"Example\" >@Scope(\"calendar_read\") @Scope(\"calendar_edit\") @Authenticated @Path(\"/abac\") public class AbacResource { } Expression Language Policy Validator Policy executor using Java EE policy expression language (EL) Configuration Key: policy-javax-el Annotations: @PolicyStatement <markup lang=\"java\" title=\"Example\" >@PolicyStatement(\"${env.time.year &gt;= 2017}\") @Authenticated @Path(\"/abac\") public class AbacResource { } Time Validator Supports time of day and day of week checks Configuration Key: time-validator Annotations: @DaysOfWeek, @TimesOfDay <markup lang=\"java\" title=\"Example\" >@TimeOfDay(from = \"08:15:00\", to = \"12:00:00\") @TimeOfDay(from = \"12:30:00\", to = \"17:30:00\") @DaysOfWeek({DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY}) @Authenticated @Path(\"/abac\") public class AbacResource { } ",
            "title": "Implemented Security Providers"
        },
        {
            "location": "/webserver/01_introduction",
            "text": " WebServer provides an asynchonous and reactive API for creating web applications. The API is inspired by popular NodeJS and Java frameworks. ",
            "title": "preambule"
        },
        {
            "location": "/webserver/01_introduction",
            "text": " Here is the code for a minimalist web application that runs on a random free port: <markup lang=\"java\" > public static void main(String[] args) throws Exception { WebServer webServer = WebServer .create(Routing.builder() .any((req, res) -&gt; res.send(\"It works!\")) .build()) .start() .toCompletableFuture() .get(10, TimeUnit.SECONDS); System.out.println(\"Server started at: http://localhost:\" + webServer.port()); } For any kind of request, at any path, respond with It works! . Start the server. Wait for the server to start while throwing possible errors as exceptions. The server is bound to a random free port. ",
            "title": "Quick Start"
        },
        {
            "location": "/webserver/01_introduction",
            "text": " The Getting Started page describes how you should declare dependency management for Helidon applications. Then declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver&lt;/artifactId&gt; &lt;/dependency&gt; Dependency on WebServer. ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/06_static-content-support",
            "text": " Use the StaticContentSupport class to serve files and classpath resources. StaticContentSupport can be created for any readable directory or classpath context root and registered on a path in Routing . You can combine dynamic handlers with StaticContentSupport objects: if no file matches the request path, then the request is forwarded to the next handler. <markup lang=\"java\" >Routing.builder() .register(\"/pictures\", StaticContentSupport.create(Paths.get(\"/some/WEB/pics\")) .register(\"/\", StaticContentSupport.builder(\"/static-content\") .welcomeFileName(\"index.html\") .build()); Create a new StaticContentSupport object to serve data from the file system, and associate it with the \"/pictures\" context path. Create a StaticContentSupport object to serve resources from the contextual ClassLoader . The specific classloader can be also defined. A builder lets you provide more configuration values. index.html is the file that is returned if a directory is requested. A StaticContentSupport object can be created using create(&#8230;&#8203;) factory methods or a builder . The builder lets you provide more configuration values, including welcome file-name and mappings of filename extensions to media types. ",
            "title": "Static Content Support"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " There are two steps to configure security with web server: Create security instance and register it with server Protect routes of web server with various security features <markup lang=\"java\" title=\"Example using builders\" >// web server's Routing Routing.builder() // This is step 1 - register security instance with web server processing // security - instance of security either from config or from a builder // securityDefaults - default enforcement for each route that has a security definition .register(WebSecurity.create(security).securityDefaults(WebSecurity.authenticate())) // this is step 2 - protect a route // protect this route with authentication (from defaults) and role \"user\" .get(\"/service1\", WebSecurity.rolesAllowed(\"user\"), (req, res) -&gt; { processService1Request(req, res); }) .build(); <markup lang=\"java\" title=\"Example using configuration\" >Routing.builder() // helper method to load both security and web server security from configuration .register(WebSecurity.create(config)) // continue with web server route configuration .build(); <markup lang=\"conf\" title=\"Example using configuration - configuration (HOCON)\" ># This may change in the future - to align with web server configuration, once it is supported security.web-server { # Configuration of integration with web server defaults { authenticate = true } paths: [ { path = \"/service1\" methods = [\"get\"] roles-allowed = [\"user\"] } ] } ",
            "title": "Bootstrapping"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " Integration of reactive web server <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.integration&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-webserver&lt;/artifactId&gt; &lt;/dependency&gt; Bootstrapping There are two steps to configure security with web server: Create security instance and register it with server Protect routes of web server with various security features <markup lang=\"java\" title=\"Example using builders\" >// web server's Routing Routing.builder() // This is step 1 - register security instance with web server processing // security - instance of security either from config or from a builder // securityDefaults - default enforcement for each route that has a security definition .register(WebSecurity.create(security).securityDefaults(WebSecurity.authenticate())) // this is step 2 - protect a route // protect this route with authentication (from defaults) and role \"user\" .get(\"/service1\", WebSecurity.rolesAllowed(\"user\"), (req, res) -&gt; { processService1Request(req, res); }) .build(); <markup lang=\"java\" title=\"Example using configuration\" >Routing.builder() // helper method to load both security and web server security from configuration .register(WebSecurity.create(config)) // continue with web server route configuration .build(); <markup lang=\"conf\" title=\"Example using configuration - configuration (HOCON)\" ># This may change in the future - to align with web server configuration, once it is supported security.web-server { # Configuration of integration with web server defaults { authenticate = true } paths: [ { path = \"/service1\" methods = [\"get\"] roles-allowed = [\"user\"] } ] } ",
            "title": "Web server"
        },
        {
            "location": "/security/03_containers-integration",
            "text": "<markup lang=\"java\" title=\"Integrate with Jersey\" >ResourceConfig resourceConfig = new ResourceConfig() // register JAX-RS resource .register(JaxRsResource.class) // integrate security .register(new io.helidon.security.jersey.SecurityFeature(security)); ",
            "title": "Inbound security"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " Integration of Jersey (JAX-RS implementation) both for inbound and outbound security. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.integration&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-jersey&lt;/artifactId&gt; &lt;/dependency&gt; Inbound security <markup lang=\"java\" title=\"Integrate with Jersey\" >ResourceConfig resourceConfig = new ResourceConfig() // register JAX-RS resource .register(JaxRsResource.class) // integrate security .register(new io.helidon.security.jersey.SecurityFeature(security)); ",
            "title": "Jersey"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " The current approach does not have a configuration option. The security must be configured through annotations. Security currently supports @Authenticated and @Authorized. When a resource is annotated with one of these annotations (application class, resource class, or resource method), security will be triggered. <markup lang=\"java\" title=\"Securing a resource method\" >// this is sufficient for security to be triggered, see javadoc for further details @Authenticated @Path(\"/{name}\") @GET @Produces(MediaType.TEXT_PLAIN) // due to Jersey approach to path matching, we need two methods to match both the \"root\" and \"root\" + subpaths public String getHelloName(@PathParam(\"name\") String name) { return \"Hello \" + name + \", your current subject: \" + securityContext.getSubject(); } ",
            "title": "Protecting a resource"
        },
        {
            "location": "/security/03_containers-integration",
            "text": "<markup lang=\"java\" title=\"Call remote target with outbound security\" >// I expect you have injected the ClientSecurityFeature as shown above Client client = ClientBuilder.newClient() // integrate security .register(new ClientSecurityFeature()); try { // call the resource, will propagate identity as configured in Security String response = client.target(\"http://www.google.com\") .request() // configure the security context for this request (as client and targets may be re-used) .property(ClientSecurityFeature.PROPERTY_CONTEXT, securityContext) .get(String.class); } finally { client.close(); } ",
            "title": "Outbound security"
        },
        {
            "location": "/security/03_containers-integration",
            "text": "<markup lang=\"java\" title=\"Support in a JAX-RS resource\" >// inject io.helidon.security.SecurityContext @Context private SecurityContext securityContext; Outbound security <markup lang=\"java\" title=\"Call remote target with outbound security\" >// I expect you have injected the ClientSecurityFeature as shown above Client client = ClientBuilder.newClient() // integrate security .register(new ClientSecurityFeature()); try { // call the resource, will propagate identity as configured in Security String response = client.target(\"http://www.google.com\") .request() // configure the security context for this request (as client and targets may be re-used) .property(ClientSecurityFeature.PROPERTY_CONTEXT, securityContext) .get(String.class); } finally { client.close(); } ",
            "title": "Access context"
        },
        {
            "location": "/security/03_containers-integration",
            "text": " The following containers are integrated with Helidon Security: Web server Integration of reactive web server <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.integration&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-webserver&lt;/artifactId&gt; &lt;/dependency&gt; Bootstrapping There are two steps to configure security with web server: Create security instance and register it with server Protect routes of web server with various security features <markup lang=\"java\" title=\"Example using builders\" >// web server's Routing Routing.builder() // This is step 1 - register security instance with web server processing // security - instance of security either from config or from a builder // securityDefaults - default enforcement for each route that has a security definition .register(WebSecurity.create(security).securityDefaults(WebSecurity.authenticate())) // this is step 2 - protect a route // protect this route with authentication (from defaults) and role \"user\" .get(\"/service1\", WebSecurity.rolesAllowed(\"user\"), (req, res) -&gt; { processService1Request(req, res); }) .build(); <markup lang=\"java\" title=\"Example using configuration\" >Routing.builder() // helper method to load both security and web server security from configuration .register(WebSecurity.create(config)) // continue with web server route configuration .build(); <markup lang=\"conf\" title=\"Example using configuration - configuration (HOCON)\" ># This may change in the future - to align with web server configuration, once it is supported security.web-server { # Configuration of integration with web server defaults { authenticate = true } paths: [ { path = \"/service1\" methods = [\"get\"] roles-allowed = [\"user\"] } ] } Jersey Integration of Jersey (JAX-RS implementation) both for inbound and outbound security. <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security.integration&lt;/groupId&gt; &lt;artifactId&gt;helidon-security-integration-jersey&lt;/artifactId&gt; &lt;/dependency&gt; Inbound security <markup lang=\"java\" title=\"Integrate with Jersey\" >ResourceConfig resourceConfig = new ResourceConfig() // register JAX-RS resource .register(JaxRsResource.class) // integrate security .register(new io.helidon.security.jersey.SecurityFeature(security)); Protecting a resource The current approach does not have a configuration option. The security must be configured through annotations. Security currently supports @Authenticated and @Authorized. When a resource is annotated with one of these annotations (application class, resource class, or resource method), security will be triggered. <markup lang=\"java\" title=\"Securing a resource method\" >// this is sufficient for security to be triggered, see javadoc for further details @Authenticated @Path(\"/{name}\") @GET @Produces(MediaType.TEXT_PLAIN) // due to Jersey approach to path matching, we need two methods to match both the \"root\" and \"root\" + subpaths public String getHelloName(@PathParam(\"name\") String name) { return \"Hello \" + name + \", your current subject: \" + securityContext.getSubject(); } Access context <markup lang=\"java\" title=\"Support in a JAX-RS resource\" >// inject io.helidon.security.SecurityContext @Context private SecurityContext securityContext; Outbound security <markup lang=\"java\" title=\"Call remote target with outbound security\" >// I expect you have injected the ClientSecurityFeature as shown above Client client = ClientBuilder.newClient() // integrate security .register(new ClientSecurityFeature()); try { // call the resource, will propagate identity as configured in Security String response = client.target(\"http://www.google.com\") .request() // configure the security context for this request (as client and targets may be re-used) .property(ClientSecurityFeature.PROPERTY_CONTEXT, securityContext) .get(String.class); } finally { client.close(); } ",
            "title": "Cloud Security Container Integrations"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " Configure the WebServer using the Helidon configuration framework, either programmatically or via a configuration file. ",
            "title": "preambule"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " The easiest way to configure the WebServer is in your application code. <markup lang=\"java\" >ServerConfiguration configuration = ServerConfiguration.builder() .bindAddress(InetAddress.getLocalHost()) .port(8080) .build(); WebServer webServer = WebServer.create(configuration, routing); ",
            "title": "Configuring the WebServer in your code"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " You can also define the configuration in a file. <markup lang=\"hocon\" title=\"WebServer configuration file application.conf \" >webserver { port: 8080, bind-address: \"0.0.0.0\", } Then, in your application code, load the configuration from that file. <markup lang=\"java\" title=\"WebServer initialization using the application.conf file located on the classpath\" >ServerConfiguration configuration = ServerConfiguration.create( Config.builder() .sources(classpath(\"application.conf\")) .build()); WebServer webServer = WebServer.create(configuration, routing); ",
            "title": "Configuring the WebServer in a configuration file"
        },
        {
            "location": "/webserver/02_configuration",
            "text": " See all configuration options here . ",
            "title": "Configuration options"
        },
        {
            "location": "/webserver/10_jackson-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.media.jackson&lt;/groupId&gt; &lt;artifactId&gt;helidon-media-jackson-server&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/10_jackson-support",
            "text": " To enable Jackson support, first create and register a JacksonSupport instance with a Routing.Builder . JacksonSupport is a Service , so it will install its own Handler that will provide serialization and deserialization services using Jackson . <markup lang=\"java\" title=\"Create and register JacksonSupport first\" >final JacksonSupport jacksonSupport = JacksonSupport.create(); final Routing.Builder routingBuilder = Routing.builder(); routingBuilder.register(jacksonSupport); Create a JacksonSupport instance. This instance may be reused freely. Register that JacksonSupport instance to enable automatic deserialization of Java objects from and serialization of Java objects to JSON. Now that automatic JSON serialization and deserialization facilities have been set up, you can register a Handler that works with Java objects instead of raw JSON. Deserialization from and serialization to JSON will be handled by Jackson . Suppose you have a Person class that looks like this: <markup lang=\"java\" title=\"Hypothetical Person class\" >public class Person { private String name; public Person() { super(); } public String getName() { return this.name; } public void setName(final String name) { this.name = name; } } Then you can set up a Handler like this: <markup lang=\"java\" title=\"A Handler that works with Java objects instead of raw JSON\" >final Routing routing = routingBuilder.post(\"/echo\", Handler.create(Person.class, (req, res, person) -&gt; res.send(person)))) .build(); Set up a route for POST requests using the Routing.Builder#post(String, Handler&#8230;&#8203;) method Use the Handler#create(Class, Handler.EntityHandler) method to install a Handler.EntityHandler that works with Person instances. This Handler.EntityHandler consumes a Person instance ( person ) and simply echoes it back. Note that there is no working with raw JSON here. <markup lang=\"bash\" title=\"Example of posting JSON to the /echo endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/echo -d '{\"name\":\"Joe\"}' {\"name\":\"Joe\"} ",
            "title": "Usage"
        },
        {
            "location": "/webserver/10_jackson-support",
            "text": " The WebServer supports Jackson . When this support is enabled, Java objects will be serialized to and deserialized from JSON automatically using Jackson. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.media.jackson&lt;/groupId&gt; &lt;artifactId&gt;helidon-media-jackson-server&lt;/artifactId&gt; &lt;/dependency&gt; Usage To enable Jackson support, first create and register a JacksonSupport instance with a Routing.Builder . JacksonSupport is a Service , so it will install its own Handler that will provide serialization and deserialization services using Jackson . <markup lang=\"java\" title=\"Create and register JacksonSupport first\" >final JacksonSupport jacksonSupport = JacksonSupport.create(); final Routing.Builder routingBuilder = Routing.builder(); routingBuilder.register(jacksonSupport); Create a JacksonSupport instance. This instance may be reused freely. Register that JacksonSupport instance to enable automatic deserialization of Java objects from and serialization of Java objects to JSON. Now that automatic JSON serialization and deserialization facilities have been set up, you can register a Handler that works with Java objects instead of raw JSON. Deserialization from and serialization to JSON will be handled by Jackson . Suppose you have a Person class that looks like this: <markup lang=\"java\" title=\"Hypothetical Person class\" >public class Person { private String name; public Person() { super(); } public String getName() { return this.name; } public void setName(final String name) { this.name = name; } } Then you can set up a Handler like this: <markup lang=\"java\" title=\"A Handler that works with Java objects instead of raw JSON\" >final Routing routing = routingBuilder.post(\"/echo\", Handler.create(Person.class, (req, res, person) -&gt; res.send(person)))) .build(); Set up a route for POST requests using the Routing.Builder#post(String, Handler&#8230;&#8203;) method Use the Handler#create(Class, Handler.EntityHandler) method to install a Handler.EntityHandler that works with Person instances. This Handler.EntityHandler consumes a Person instance ( person ) and simply echoes it back. Note that there is no working with raw JSON here. <markup lang=\"bash\" title=\"Example of posting JSON to the /echo endpoint\" >curl --noproxy '*' -X POST -H \"Content-Type: application/json\" \\ http://localhost:8080/echo -d '{\"name\":\"Joe\"}' {\"name\":\"Joe\"} ",
            "title": "Jackson Support"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Routing lets you use request matching criteria to bind requests to a handler that implements your custom business logic. Matching criteria include one or more HTTP Method(s) and, optionally, a request path matcher . Use the RequestPredicate class to specify more routing criteria. ",
            "title": "preambule"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Routing also supports Error Routing which binds Java Throwable to the handling logic. Configure HTTP request routing using Routing.Builder . <markup lang=\"java\" title=\"Using Routing.Builder to specify how HTTP requests are handled\" >Routing routing = Routing.builder() .get(\"/hello\", (req, res) -&gt; res.send(\"Hello World!\")) .build(); WebServer webServer = WebServer.create(configuration, routing); Handle all GETs to /hello path. Send the Hello World! string. Add the routing to the WebServer. ",
            "title": "Basics"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Routing.Builder lets you specify how to handle each HTTP method. For example: HTTP Method Routing.Builder example GET .get((req, res) -&gt; { /* handler */ }) PUT .put((req, res) -&gt; { /* handler */ }) POST .post((req, res) -&gt; { /* handler */ }) HEAD .head((req, res) -&gt; { /* handler */ }) DELETE .delete((req, res) -&gt; { /* handler */ }) TRACE .trace((req, res) -&gt; { /* handler */ }) OPTIONS .options((req, res) -&gt; { /* handler */ }) any method .any((req, res) -&gt; { /* handler */ }) multiple methods .anyOf(List.of(Http.Method.GET, Http.Method.POST), (req, res) -&gt; { /* handler */ }) ",
            "title": "HTTP Method Routing"
        },
        {
            "location": "/webserver/03_routing",
            "text": " You can combine HTTP method routing with request path matching. <markup lang=\"java\" >Routing.builder() .post(\"/some/path\", (req, res) -&gt; { /* handler */ }) You can use path pattern instead of path with the following syntax: /foo/bar/baz - Exact path match against resolved path even with non-usual characters /foo/{}/baz - {} Unnamed regular expression segment ([^/]+) /foo/{var}/baz - Named regular expression segment ([^/]+) /foo/{var:\\d+} - Named regular expression segment with a specified expression /foo/{:\\d+} - Unnamed regular expression segment with a specified expression /foo/{+var} - Convenience shortcut for {var:.+}. A matcher is not a true URI template (as defined by RFC) but this convenience is in sync with the Apiary templates /foo/{+} - Convenience shortcut for unnamed segment with regular expression {:.+} /foo[/bar] - An optional block, which translates to the /foo(/bar)? regular expression Path (matcher) routing is exact . For example, a /foo/bar request is not routed to .post('/foo', &#8230;&#8203;) . Always start path and path patterns with the / character. ",
            "title": "Path Matcher Routing"
        },
        {
            "location": "/webserver/03_routing",
            "text": " Use the RequestPredicate utility class to identify more criteria. You can construct (build) a predicate based on typical request criteria such as content type, or the existence of a header or cookie. You can also construct a handler that only processes requests accepted by the predicate. All other requests are nexted , meaning that they are routed to the next valid handler. <markup lang=\"java\" >.post(\"/foo\", RequestPredicate.create() .containsHeader(\"my-gr8-header\") .accepts(MediaType.TEXT_PLAIN) .and(this::isUserAuthenticated) .thenApply((req, resp) -&gt; { // Some logic }) .otherwise((req, resp) -&gt; { /* Otherwise logic */ }); // Optional. Default logic is req.next() ",
            "title": "Request Predicate"
        },
        {
            "location": "/metrics/02_prometheus",
            "text": " Helidon WebServer can serve Prometheus metrics. This document describes how to register Prometheus support with WebServer and how to customize the configuration. For information about using Prometheus, see the Prometheus documentation: https://prometheus.io/docs/introduction/overview/ . Note that Helidon has an in-built metrics implementation. See Helidon Metrics . ",
            "title": "preambule"
        },
        {
            "location": "/metrics/02_prometheus",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" > &lt;dependency&gt; &lt;groupId&gt;io.helidon.metrics&lt;/groupId&gt; &lt;artifactId&gt;helidon-metrics-prometheus&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Prerequisites"
        },
        {
            "location": "/metrics/02_prometheus",
            "text": " To enable Prometheus metrics, register it with the web server. <markup lang=\"java\" >import io.helidon.metrics.prometheus.PrometheusSupport; //... Routing.builder() .register(PrometheusSupport.create()) .register(\"/myapp\", new MyService()) .build(); This example uses the default CollectorRegistry and exposes an endpoint /metrics . You can use fluent API builder obtained by PrometheusSupport.builder() to configure a different CollectorRegistry or a different path. ",
            "title": "Using Prometheus metrics in your application"
        },
        {
            "location": "/security/05_extensibility",
            "text": " This guide describes how you can extend the Security component. The component has the following extension points: Security providers Provider selection policy Integration with a framework ",
            "title": "preambule"
        },
        {
            "location": "/security/05_extensibility",
            "text": " To create a custom authentication provider, create a class that implements io.helidon.security.spi.AuthenticationProvider . Implementation is responsible for taking a request and asserting a subject based on that request. In case the protocol is multi-request (e.g. challenge for basic authentication), you have the possibility to return specific headers and a response code. The default semantics of these is HTTP, though providers may exist that are not HTTP specific. ",
            "title": "Authentication provider"
        },
        {
            "location": "/security/05_extensibility",
            "text": " To create a custom authorization provider, create a class that implements io.helidon.security.spi.AuthorizationProvider . Implementation is responsible for taking a request and checking whether the request can continue processing (e.g. if the current user and/or service subject has a right to execute it). If authentication is configured, the Security component guarantees it resolved before authorization. ",
            "title": "Authorization provider"
        },
        {
            "location": "/security/05_extensibility",
            "text": " To create a custom outbound security provider, create a class that implements io.helidon.security.spi.OutboundSecurityProvider . Implementation can update outgoing message headers to handle security for an outgoing request (e.g. identity propagation, mapping etc.). ",
            "title": "Outbound security provider"
        },
        {
            "location": "/security/05_extensibility",
            "text": " To create a custom audit provider, create a class that implements io.helidon.security.spi.AuditProvider . Security component feeds each audit provider all messages from all components that invoke audit method on \"Security\" class, including internal audit events pre-configured in the component itself (e.g. authentication, authorization events). Implementation may do whatever desired with these messages, e.g.: filter them log them store them to a database forward them to an audit component discard them ",
            "title": "Audit provider"
        },
        {
            "location": "/security/05_extensibility",
            "text": " You can build a custom provider for each type of security concept supported. By default, each provider is asynchronous. For simple cases, a class exists in \"spi\" package to help implement a synchronous approach: SynchronousProvider . You have two options: Implement a provider interface and reference it in configuration (or from builder) by class Implement a provider interface and provide a Java ServiceLoader service implementing io.helidon.security.spi.SecurityProviderService The second option allows for easier configuration, as the configuration key can be used without a class definition and creates a default name of a provider. Authentication provider To create a custom authentication provider, create a class that implements io.helidon.security.spi.AuthenticationProvider . Implementation is responsible for taking a request and asserting a subject based on that request. In case the protocol is multi-request (e.g. challenge for basic authentication), you have the possibility to return specific headers and a response code. The default semantics of these is HTTP, though providers may exist that are not HTTP specific. Authorization provider To create a custom authorization provider, create a class that implements io.helidon.security.spi.AuthorizationProvider . Implementation is responsible for taking a request and checking whether the request can continue processing (e.g. if the current user and/or service subject has a right to execute it). If authentication is configured, the Security component guarantees it resolved before authorization. Outbound security provider To create a custom outbound security provider, create a class that implements io.helidon.security.spi.OutboundSecurityProvider . Implementation can update outgoing message headers to handle security for an outgoing request (e.g. identity propagation, mapping etc.). Audit provider To create a custom audit provider, create a class that implements io.helidon.security.spi.AuditProvider . Security component feeds each audit provider all messages from all components that invoke audit method on \"Security\" class, including internal audit events pre-configured in the component itself (e.g. authentication, authorization events). Implementation may do whatever desired with these messages, e.g.: filter them log them store them to a database forward them to an audit component discard them ",
            "title": "Security providers"
        },
        {
            "location": "/security/05_extensibility",
            "text": " Each request is processed by a single authentication and/or authorization provider. The selection policy provides the security component information about which provider to use. Out of the box, there are three policies: \"First\" policy - first configured provider (or explicitly defined default provider) is used by default, if a named provider is requested, it would be used \"Composite\" policy - this policy allows for a sequence of providers to be executed (e.g. one request may have more than one provider) - used for example to resolve service and user authentication \"Class\" policy - this allows usage of a custom policy defined by fully qualified class name To create a custom provider selection policy, create a class that implements \"io.helidon.security.spi.ProviderSelectionPolicy\". ",
            "title": "Provider selection policy"
        },
        {
            "location": "/security/05_extensibility",
            "text": " The Security component supports integration with Helidon WebServer ( helidon-security-integration-webserver ) and with Jersey ( helidon-security-integration-jersey ). Existing integrations (WebServer and Jersey) use Helidon Security APIs that are available to integrate any framework/application (for example we could integrate security with messaging, such as JMS). To create a new integration, an instance of Security class is needed, as it handles all configured providers. Usually a single Security instance is used for an application. Security is then used to create an instance of SecurityContext , which is used for interaction with a single user. A single SecurityContext is created for each HTTP request in Jersey and WebServer integration. SecurityContext is used to invoke authentication, authorization, and outbound security requests. Helidon Security also defines a set of annotations: @Authenticated - access to resources must follow authentication rules defined by the annotation @Authorized - access to resources must follow authorization rules defined by the annotation @Audited - to configure auditing If the protected resources (in Helidon MP, these are JAX-RS resource classes and methods) can be annotated, the integration component must use these annotations when deciding how to secure the endpoint. For example, the Jersey integration checks whether the @Authenticated annotation exists. If it does, then the integration component attempts to authenticate the request. Because other components of Helidon Security (such as ABAC validators) query the request for annotations, the integration component should also collect all annotations from the resource and correctly configure them when creating the security request. ",
            "title": "Framework integration"
        },
        {
            "location": "/guides/01_overview",
            "text": " Quickstart SE Quickly create your first Helidon SE application in under 5 minutes. Quickstart MP Quickly create your first Helidon MP application in under 5 minutes. ",
            "title": "Getting Started"
        },
        {
            "location": "/guides/01_overview",
            "text": " Create Docker Images Learn how to package your application and the necessary runtime dependencies as a Docker image. Build Container Images with Jib Learn how to use Jib to create a container image without Docker. Deploying to OKE Learn how to deploy your application to Oracle Cloud Infrastructure Container Engine for Kubernetes (OKE). ",
            "title": "More Guides"
        },
        {
            "location": "/extensions/01_overview",
            "text": " Helidon provides CDI portable extensions that you can use to inject the following objects into your Helidon MicroProfile applications: HikariCP data sources Create and inject a HikariCP data source in your application code. Jedis clients Create and inject a Jedis pool in your application code. OCI Object Storage clients Create and inject an Oracle Cloud Infrastructure Object Storage client in your application code. ",
            "title": "CDI extensions"
        },
        {
            "location": "/health/02_health_in_k8s",
            "text": " This document describes how to use the Helidon health check API with Kubernetes. ",
            "title": "preambule"
        },
        {
            "location": "/health/02_health_in_k8s",
            "text": " The liveness probe is used to verify the container has become unresponsive. For example, it can be used to detect deadlocks or analyze heap usage. When Kubernetes gives up on a liveness probe, the corresponding pod is restarted. The liveness probe can result in repeated restarts in certain cases. For example, if the probe is implemented to check all the dependencies strictly, then it can fail repeatedly for temporary issues. Repeated restarts can also occur if timeoutSeconds or periodSeconds is too low. We recommend the following: Avoid checking dependencies in a liveness probe. Set timeoutSeconds to avoid excessive probe failures. Acknowledge startup times with initialDelaySeconds . ",
            "title": "Liveness probe"
        },
        {
            "location": "/health/02_health_in_k8s",
            "text": " The readiness probe is used to avoid routing requests to the pod until it is ready to accept traffic. When Kubernetes gives up on a readiness probe, the pod is not restarted, traffic is not routed to the pod anymore. In certain cases, the readiness probe can cause all the pods to be removed from service routing. For example, if the probe is implemented to check all the dependencies strictly, then it can fail repeatedly for temporary issues. This issue can also occur if timeoutSeconds or periodSeconds is too low. We recommend the following: Be conservative when checking shared dependencies. Be aggressive when checking local dependencies. Set failureThreshold according to periodSeconds in order to accommodate temporary errors. ",
            "title": "Readiness probe"
        },
        {
            "location": "/health/02_health_in_k8s",
            "text": " Probes is the term used by Kubernetes to describe health checks for containers ( Kubernetes documentation ). There are two types of probes: liveness : Indicates whether the container is running readiness : Indicates whether the container is ready to service requests You can implement probes using the following mechanisms: Running a command inside a container Sending an HTTP request to a container Opening a TCP socket to a container A microservice exposed to HTTP traffic will typically implement both the liveness probe and the readiness probe using HTTP requests. You can configure several parameters for probes. The following are the most relevant parameters: <div class=\"table__overflow elevation-1 flex sm7 \"> initialDelaySeconds Number of seconds after the container has started before liveness or readiness probes are initiated. periodSeconds Probe interval. Default to 10 seconds. Minimum value is 1. timeoutSeconds Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1 failureThreshold Number of consecutive failures after which the probe should stop. Default: 3. Minimum: 1. Liveness probe The liveness probe is used to verify the container has become unresponsive. For example, it can be used to detect deadlocks or analyze heap usage. When Kubernetes gives up on a liveness probe, the corresponding pod is restarted. The liveness probe can result in repeated restarts in certain cases. For example, if the probe is implemented to check all the dependencies strictly, then it can fail repeatedly for temporary issues. Repeated restarts can also occur if timeoutSeconds or periodSeconds is too low. We recommend the following: Avoid checking dependencies in a liveness probe. Set timeoutSeconds to avoid excessive probe failures. Acknowledge startup times with initialDelaySeconds . Readiness probe The readiness probe is used to avoid routing requests to the pod until it is ready to accept traffic. When Kubernetes gives up on a readiness probe, the pod is not restarted, traffic is not routed to the pod anymore. In certain cases, the readiness probe can cause all the pods to be removed from service routing. For example, if the probe is implemented to check all the dependencies strictly, then it can fail repeatedly for temporary issues. This issue can also occur if timeoutSeconds or periodSeconds is too low. We recommend the following: Be conservative when checking shared dependencies. Be aggressive when checking local dependencies. Set failureThreshold according to periodSeconds in order to accommodate temporary errors. ",
            "title": "About Kubernetes probes"
        },
        {
            "location": "/health/02_health_in_k8s",
            "text": " Failed probes are recorded as events associated with their corresponding pods. The event message contains only the status code. <markup lang=\"bash\" title=\"Get the events of a single pod:\" >POD_NAME=$(kubectl get pod -l app=acme -o jsonpath='{.items[0].metadata.name}') kubectl get event --field-selector involvedObject.name=${POD_NAME} Get the effective pod name by filtering pods with the label app=acme . Filter the events for the pod. Create log messages in your health check implementation when setting a DOWN status. This will allow you to correlate the cause of a failed probe. ",
            "title": "Troubleshooting probes"
        },
        {
            "location": "/health/02_health_in_k8s",
            "text": " This example shows the usage of the Helidon health API in an application that implements health endpoints for the liveness and readiness probes. Note that the application code dissociates the health endpoints from the default routes, so that the health endpoints are not exposed by the service. An example YAML specification is also provided for the Kubernetes service and deployment. <markup lang=\"java\" title=\"Application code:\" >Routing healthRouting = Routing.builder() .register(JsonSupport.create()) .register(HealthSupport.builder() .webContext(\"/live\") .add(HealthChecks.healthChecks()) .build()) .register(HealthSupport.builder() .webContext(\"/ready\") .add(() -&gt; HealthCheckResponse.named(\"database\").up().build()) .build()) .build(); Routing defaultRouting = Routing.builder() .any((req, res) -&gt; res.send(\"It works!\")) .build(); WebServer server = WebServer.builder(defaultRouting) .config(ServerConfiguration.builder() .port(8080) .addSocket(\"health\", SocketConfiguration.builder() .port(8081) .build()) .build()) .addNamedRouting(\"health\", healthRouting) .build(); server.start(); The health service for the liveness probe is exposed at /live . Using the built-in health checks for the liveness probe. The health service for the readiness probe is exposed at /ready . Using a custom health check for a pseudo database that is always UP . The default route: returns It works! for any request. The server uses port 8080 for the default routes. A socket configuration named health using port 8081 . Route the health services exclusively on the health socket. <markup lang=\"yaml\" title=\"Kubernetes descriptor:\" >kind: Service apiVersion: v1 metadata: name: acme labels: app: acme spec: type: NodePort selector: app: acme ports: - port: 8080 targetPort: 8080 name: http --- kind: Deployment apiVersion: extensions/v1beta1 metadata: name: acme spec: replicas: 1 template: metadata: name: acme labels: name: acme spec: containers: - name: acme image: acme imagePullPolicy: IfNotPresent ports: - containerPort: 8080 livenessProbe: httpGet: path: /live port: 8081 initialDelaySeconds: 3 periodSeconds: 10 timeoutSeconds: 3 failureThreshold: 3 readinessProbe: httpGet: path: /ready port: 8081 initialDelaySeconds: 10 periodSeconds: 30 timeoutSeconds: 10 --- A service of type NodePort that serves the default routes on port 8080 . A deployment with one replica of a pod. The HTTP endpoint for the liveness probe. The liveness probe configuration. The HTTP endpoint for the readiness probe. The readiness probe configuration. ",
            "title": "Example"
        },
        {
            "location": "/microprofile/03_application-configuration",
            "text": " Your application can use the MicroProfile Config or Helidon Config (or both). MicroProfile Config offers portability to other MicroProfile servers. Helidon Config supports a full tree structure, including repeating elements. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/03_application-configuration",
            "text": " You can inject values that the application can access from both MicroProfile Config and from Helidon Config. <markup lang=\"java\" title=\"JAX-RS - inject a single config property\" >@Inject public MyResource(@ConfigProperty(name=\"app.name\") String appName) { this.applicationName = appName; } You can also inject the whole configuration instance, either io.helidon.config.Config or org.eclipse.microprofile.config.Config . <markup lang=\"java\" title=\"JAX-RS - inject config\" >@Inject public MyResource(Config config) { this.config = config; } ",
            "title": "Configuring the Application"
        },
        {
            "location": "/guides/06_Oracle_Kubernetes",
            "text": " Push a Docker image of your Helidon application to Oracle Cloud Infrastructure Registry (OCIR), and deploy the image from the registry to Oracle Cloud Infrastructure Container Engine for Kubernetes (OKE). ",
            "title": "preambule"
        },
        {
            "location": "/guides/06_Oracle_Kubernetes",
            "text": " About 10 minutes Helidon prerequisites An OKE cluster. See the OKE documentation . A Helidon project created from the quickstart Maven archetype. See quickstart Maven archetype . ",
            "title": "What You Need"
        },
        {
            "location": "/guides/06_Oracle_Kubernetes",
            "text": " Your account must be in the Administrators group or another group that has the REPOSITORY_CREATE permission. Sign in to the Oracle Cloud Infrastructure (OCI) web console and generate an authentication token. See Getting an Auth Token . Remember to copy the generated token. You won&#8217;t be able to access it again. <markup lang=\"bash\" title=\"Log in to the OCIR Docker registry:\" >docker login \\ -u &lt;username&gt; \\ -p &lt;password&gt; \\ &lt;region-code&gt;.ocir.io The user name in the format &lt;tenancy_name&gt;/&lt;username&gt; . The password is the generated token. &lt;region-code&gt; is the code for the OCI region that you&#8217;re using. For example, the region code for Phoenix is phx . See Regions and Availability Domains . <markup lang=\"bash\" title=\"Tag the image that you want to push to the registry:\" >docker tag \\ helidon-quickstart-se:latest \\ &lt;region-code&gt;.ocir.io/&lt;tenancy-name&gt;/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;tag&gt; the local image to tag &lt;repo-name&gt; is optional. It is the name of a repository to which you want to push the image (for example, project01 ). <markup lang=\"bash\" title=\"Push the image to the Registry:\" >docker push \\ &lt;region-code&gt;.ocir.io/&lt;tenancy-name&gt;/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;tag&gt; You can pull your image with the image path used above, for example: phx.ocir.io/helidon/example/helidon-quickstart-se:latest ",
            "title": "Push Your Image to OCIR"
        },
        {
            "location": "/guides/06_Oracle_Kubernetes",
            "text": " First, change to the helidon-quickstart-se directory. Then edit src/main/k8s/app.yaml and add the following under spec in the deployment section: <markup lang=\"yaml\" >spec: imagePullSecrets: - name: ocirsecret containers: - name: helidon-quickstart-se image: phx.ocir.io/helidon/example/helidon-quickstart-se:latest imagePullPolicy: Always ports: - containerPort: 8080 The config secret name The image path The file at src/main/k8s/app.yaml is configured as a Maven resource to allow for substituting Maven properties, the Maven build generates a substituted file at target/app.yaml . <markup lang=\"bash\" title=\"Deploy the application:\" >kubectl create -f target/app.yaml -n helidon <markup lang=\"bash\" title=\"Get the NodePort number for your new pod:\" >kubectl get svc -n helidon <markup lang=\"bash\" title=\"Get the IP address for your cluster nodes:\" >kubectl get nodes You can now access the application at http://&lt;NodeIpAddress&gt;:&lt;NodePort&gt;/greet . ",
            "title": "Deploy the Image to Kubernetes"
        },
        {
            "location": "/guides/06_Oracle_Kubernetes",
            "text": " Create a namespace (for example, helidon ) for the project: <markup lang=\"bash\" >kubectl create namespace helidon The repository that you created is private. To allow Kubernetes to authenticate with the container registry and pull the private image, you must create and use an image-pull secret. <markup lang=\"bash\" title=\"Create an image-pull secret:\" >kubectl create secret docker-registry \\ ocirsecret \\ --docker-server=&lt;region-code&gt;.ocir.io \\ --docker-username='&lt;tenancy-name&gt;/&lt;oci-username&gt;' \\ --docker-password='&lt;oci-auth-token&gt;' \\ --docker-email='&lt;email-address&gt;' \\ --namespace helidon The name of the config secret The docker registry (see docker tag step above) The user name (see docker login step above) The password (see docker login step above) The namespace created in the previous step Deploy the Image to Kubernetes First, change to the helidon-quickstart-se directory. Then edit src/main/k8s/app.yaml and add the following under spec in the deployment section: <markup lang=\"yaml\" >spec: imagePullSecrets: - name: ocirsecret containers: - name: helidon-quickstart-se image: phx.ocir.io/helidon/example/helidon-quickstart-se:latest imagePullPolicy: Always ports: - containerPort: 8080 The config secret name The image path The file at src/main/k8s/app.yaml is configured as a Maven resource to allow for substituting Maven properties, the Maven build generates a substituted file at target/app.yaml . <markup lang=\"bash\" title=\"Deploy the application:\" >kubectl create -f target/app.yaml -n helidon <markup lang=\"bash\" title=\"Get the NodePort number for your new pod:\" >kubectl get svc -n helidon <markup lang=\"bash\" title=\"Get the IP address for your cluster nodes:\" >kubectl get nodes You can now access the application at http://&lt;NodeIpAddress&gt;:&lt;NodePort&gt;/greet . ",
            "title": "Setup your K8s Cluster"
        },
        {
            "location": "/security/01_introduction",
            "text": " Helidon Security provides the following features Authentication - support for authenticating incoming requests, creating a security Subject with Principal and Grants. Principal represents current user/service. Grant may represent a Role, Scope etc. Responsibility to create Principals and Grants lies with with AuthenticationProvider SPI. The following Principals are expected and supported out of the box: UserPrincipal - the party is an end-user (e.g. a person) - there can be zero to one user principals in a subject ServicePrincipal - the party is a service (e.g. a computer program) - there can be zero to one service principals in a subject Authorization - support for authorizing incoming requests. Out-of-the-box the security module supports ABAC and RBAC (Attribute based access control and Role based access control). RBAC is handled through RolesAllowed annotation (for integrations that support injection). Outbound security - support for propagating identity or (in general) securing outbound requests. Modification of a request to include outbound security is responsibility of OutboundSecurityProvider SPI Audit - security module audits most important events through its own API (e.g. Authentication events, Authorization events, outbound security events). A default AuditProvider is provided as well, logging to Java util logging (JUL) logger called \"AUDIT\" (may be overridden through configuration). AuditProvider SPI may be implemented to support other auditing options. Security module is quite HTTP centric (as most common use cases are related to HTTP REST), though it is not HTTP specific (the security module may be used to secure even other transports, such as JMS, Kafka messages etc. if an appropriate integration module is developed, as all APIs can be mapped to a non-HTTP protocol). Nevertheless there may be security providers that only make sense with HTTP (such as HTTP digest authentication). ",
            "title": "preambule"
        },
        {
            "location": "/security/01_introduction",
            "text": "<markup lang=\"java\" title=\"Security through a builder\" >Security security = Security.builder() // create a provider instance based on the provider documentation .addProvider(...) .build(); ",
            "title": "Builder pattern"
        },
        {
            "location": "/security/01_introduction",
            "text": " See Secure config for details about encrypting passwords in configuration files. <markup lang=\"java\" title=\"Security from configuration\" >// uses io.helidon.Config Security security = Security.create(config); <markup lang=\"conf\" title=\"Security from configuration - configuration\" ># Uses config encryption filter to encrypt passwords security.providers: [ { http-basic-auth { realm = \"helidon\" user-store { users: [ { login = \"aUser\" password = \"${CLEAR=somePassword}\" roles = [\"theRole\"] }, { login = \"noRoles\" password = \"${CLEAR=somePassword}\" roles = [] } ] } } } ] ",
            "title": "Configuration pattern"
        },
        {
            "location": "/security/01_introduction",
            "text": "<markup lang=\"java\" title=\"Security from configuration and builder\" >// uses io.helidon.Config Security security = Security.builder(config) .addProvider(...) .build(); // or reverse order: Security security = Security.builder() .addProvider() .config(config) .build(); ",
            "title": "Hybrid pattern (Builder &amp; Configuration)"
        },
        {
            "location": "/security/01_introduction",
            "text": " To integrate with a container, or to use Security standalone, we must create an instance of security. In general, Security supports three approaches a fluent-API builder pattern - you configure everything \"by hand\" a configuration based pattern - you configure everything in a configuration file hybrid - you load a builder from configuration and update it in a program Once a security instance is built, it can be used to initialize an integration with a container , or to use security from a program directly: <markup lang=\"java\" title=\"Security direct usage\" >// create a security context SecurityContext context = security.contextBuilder(UUID.randomUUID().toString()) .env(SecurityEnvironment.builder() .method(\"get\") .path(\"/test\") .transport(\"http\") .header(\"Authorization\", \"Bearer abcdefgh\") .build()) .build(); // use the context to authenticate a request context.atnClientBuilder() .submit() .whenComplete((response, exception) -&gt; { // this is to show the features, not a real-world production code... if (null == exception) { if (response.getStatus().isSuccess()) { System.out.println(response.getUser()); System.out.println(response.getService()); } else { System.out.println(\"Authentication failed: \" + response.getDescription()); } } else { exception.printStackTrace(); } }); Builder pattern <markup lang=\"java\" title=\"Security through a builder\" >Security security = Security.builder() // create a provider instance based on the provider documentation .addProvider(...) .build(); Configuration pattern See Secure config for details about encrypting passwords in configuration files. <markup lang=\"java\" title=\"Security from configuration\" >// uses io.helidon.Config Security security = Security.create(config); <markup lang=\"conf\" title=\"Security from configuration - configuration\" ># Uses config encryption filter to encrypt passwords security.providers: [ { http-basic-auth { realm = \"helidon\" user-store { users: [ { login = \"aUser\" password = \"${CLEAR=somePassword}\" roles = [\"theRole\"] }, { login = \"noRoles\" password = \"${CLEAR=somePassword}\" roles = [] } ] } } } ] Hybrid pattern (Builder &amp; Configuration) <markup lang=\"java\" title=\"Security from configuration and builder\" >// uses io.helidon.Config Security security = Security.builder(config) .addProvider(...) .build(); // or reverse order: Security security = Security.builder() .addProvider() .config(config) .build(); ",
            "title": "How to use"
        },
        {
            "location": "/security/01_introduction",
            "text": " You need to declare the following dependency in your project: <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.security&lt;/groupId&gt; &lt;artifactId&gt;helidon-security&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/guides/02_quickstart-se",
            "text": " This guide describes a basic example of an Helidon SE application using Docker and Kubernetes. ",
            "title": "preambule"
        },
        {
            "location": "/guides/02_quickstart-se",
            "text": " <div class=\"table__overflow elevation-1 flex sm7 \"> About 5 minutes Helidon Prerequisites ",
            "title": "What you need"
        },
        {
            "location": "/guides/02_quickstart-se",
            "text": " Generate the project sources using one (or both) of the Helidon Maven archetypes. The result is a simple project that shows the basics of configuring the WebServer and implementing basic routing rules. <markup lang=\"bash\" title=\"Run the Maven archetype\" >mvn archetype:generate -DinteractiveMode=false \\ -DarchetypeGroupId=io.helidon.archetypes \\ -DarchetypeArtifactId=helidon-quickstart-se \\ -DarchetypeVersion=1.0.2 \\ -DgroupId=io.helidon.examples \\ -DartifactId=helidon-quickstart-se \\ -Dpackage=io.helidon.examples.quickstart.se The archetype generates a Maven project in your current directory (for example, helidon-quickstart-se ). Change into this directory. <markup lang=\"bash\" >cd helidon-quickstart-se If you want to use the generated project as a starter for your own application, then you can replace groupId, artifactId and package with values appropriate for your application. <markup lang=\"bash\" title=\"Build the Application\" >mvn package The project builds an application jar for the example and saves all runtime dependencies in the target/libs directory. This means you can easily start the application by running the application jar file: <markup lang=\"bash\" title=\"Run the application\" >java -jar target/helidon-quickstart-se.jar The example is a very simple \"Hello World\" greeting service. It supports GET requests for generating a greeting message, and a PUT request for changing the greeting itself. The response is encoded using JSON. For example: <markup lang=\"bash\" title=\"Try the Application\" >curl -X GET http://localhost:8080/greet {\"message\":\"Hello World!\"} curl -X GET http://localhost:8080/greet/Joe {\"message\":\"Hello Joe!\"} curl -X PUT -H \"Content-Type: application/json\" -d '{\"greeting\" : \"Hola\"}' http://localhost:8080/greet/greeting curl -X GET http://localhost:8080/greet/Jose {\"message\":\"Hola Jose!\"} ",
            "title": "Generate The Project"
        },
        {
            "location": "/guides/02_quickstart-se",
            "text": " The project also contains a Dockerfile so that you can easily build and run a Docker image. Because the example&#8217;s runtime dependencies are already in target/libs , the Dockerfile is pretty simple (see target/Dockerfile ). To build the Docker image, you need to have Docker installed and running on your system. <markup lang=\"bash\" title=\"Docker build\" >docker build -t helidon-quickstart-se target <markup lang=\"bash\" title=\"Run Docker Image\" >docker run --rm -p 8080:8080 quickstart-se:latest Then you can try the application as you did before. ",
            "title": "Build a Docker Image"
        },
        {
            "location": "/guides/02_quickstart-se",
            "text": " If you don&#8217;t have access to a Kubernetes cluster, you can install one on your desktop . Then deploy the example: <markup lang=\"bash\" title=\"Verify connectivity to cluster\" >kubectl cluster-info kubectl get nodes <markup lang=\"bash\" title=\"Deploy the application to Kubernetes\" >kubectl create -f target/app.yaml kubectl get pods # Wait for quickstart pod to be RUNNING The step above created a service that is exposed into any node port. Lookup the service to find the port. <markup lang=\"bash\" title=\"Lookup the service\" >kubectl get service helidon-quickstart-se Note the PORTs. You can now exercise the application as you did before but use the second port number (the NodePort) instead of 8080. For example: <markup lang=\"bash\" >curl -X GET http://localhost:31431/greet After you&#8217;re done, cleanup. <markup lang=\"bash\" title=\"Remove the application from Kubernetes\" >kubectl delete -f target/app.yaml ",
            "title": "Deploy the application to Kubernetes"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " When security requires a configuration with repeating complex elements, use Helidon Config. This example configures a basic authentication provider and protects static content on the web server. It also includes annotations in Jersey. ",
            "title": "preambule"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " In Helidon MP, the config encryption filter enabled by default . However, if you don&#8217;t configure it, the filter only supports a template for aliasing that checks that no clear text passwords are present (template ${CLEAR=&#8230;&#8203;}. In Helidon SE, you may add support for this filter with dependency (loaded through a java service mechanism): <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-encryption&lt;/artifactId&gt; &lt;/dependency&gt; Put encrypted values into your configuration file so that it can be stored in a public repository with no danger of exposing the secret values. Be sure to use a strong and secret password. The supported templates are: Templates Template Description Example ${CLEAR=&#8230;&#8203;} Secret in clear text (for testing) - requiresEncryption must be disabled ${CLEAR=knownSecret} ${RSA=&#8230;&#8203;} Public/private key encryption, base64 value ${RSA=aGr3sFCMQznixrgbIk9qNfoLnO1cdi3H86qweCNjxFvH4dYg5IQM1EuoyTjJaXcSCG5MBskpeA3bjnWYrzeAFFlZHuYSPsb+wJVzGLrfUColTn+BPJjpJ3rmEd3AVkJl1ASfBBMh3q3deC+rvUdhfoTGBO8sC0teUATklCQSxfHOnIxswxqrplnoGXToGiTIfehiN2IZNulRKeoDQ0AeoKREmq5au4L8OOmS+D9BqnlKMc0F1tULZ7+h3Cxla4lXC5WRPoPfHBU4vzRZOGzeDvLkRgrD60caw/wKn5M0Wy1A1cKR8E46ceBXCjJ2eWIcLyhZSAZWDe3ceNrawHZtCg==} ${AES=&#8230;&#8203;} Shared secret ecryption, base64 value ${AES=D/UgMzsNb265HU1NDvdzm7tACHdsW6u1PjYEcRkV/OLiWcI+ET6Q4MKCz0zHyEh9} ${ALIAS=&#8230;&#8203;} Reference to another key ${ALIAS=someOtherKey} ",
            "title": "Protecting Configuration Secrets"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " The config encryption filter has an option that defines whether encryption is required or not. If it&#8217;s set to true, which is the default, then: Configuration values with ${CLEAR=&#8230;&#8203;} template will cause an exception when requested. The filter fails during bootstrap if security.config.aes.insecure-passphrase is configured. ",
            "title": "Requiring encryption"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " The config encryption filter provides a Main class io.helidon.config.encryption.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using shared secret masterPassword \" >java io.helidon.config.encryption.Main aes masterPassword secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. ",
            "title": "Encrypting values (AES)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " You can provide a shared secret in a couple of ways: in configuration - for testing/demo purposes only - key is security.config.aes.insecure-passphrase as an environment variable - SECURE_CONFIG_AES_MASTER_PWD ",
            "title": "Shared Secret (AES)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " Symmetric encryption is based on a shared secret that is known by the person encrypting the value and is also provided to the application. Encrypting values (AES) The config encryption filter provides a Main class io.helidon.config.encryption.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using shared secret masterPassword \" >java io.helidon.config.encryption.Main aes masterPassword secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Shared Secret (AES) You can provide a shared secret in a couple of ways: in configuration - for testing/demo purposes only - key is security.config.aes.insecure-passphrase as an environment variable - SECURE_CONFIG_AES_MASTER_PWD ",
            "title": "Using symmetric encryption (AES)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " The config encryption filter provides a Main class io.helidon.config.encryption.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using public certificate in a keystore\" >java io.helidon.config.encryption Main rsa /path/to/keystore.p12 keystorePassword publicCertAlias secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. ",
            "title": "Encrypting values (RSA)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " You can configure the properties of a private key. These keys are prefixed with security.config.rsa RSA Configuration Options: Keystore What Configuration Key Environment Variable Description Keystore path keystore-path SECURE_CONFIG_RSA_PRIVATE_KEY Keystore is located in file system Keystore keystore-resource-path N/A Keystore is located on classpath Private key alias key-alias SECURE_CONFIG_PRIVATE_KEY_ALIAS Alias of the private key (such as \"1\", which is usually the default) Keystore passphrase keystore-passphrase SECURE_CONFIG_PRIVATE_KEYSTORE_PASSPHRASE Password for the keystore (and private key). RSA Configuration Options: PEM (PKCS#8) private key What Configuration Key Environment Variable Description Path pem-key-path SECURE_CONFIG_RSA_PEM_KEY Key is located on file system Resource path pem-key-resource-path N/A Key is located on classpath Passphrase pem-key-passphrase SECURE_CONFIG_PRIVATE_KEY_PASSPHRASE Password protecting the private key <markup lang=\"yaml\" title=\"Example yaml configuration\" >security.config: # Set to true for production - if set to true, clear text passwords will cause failure require-encryption: false # The \"master\" password for AES decryption. For production, set this via system property or environment variable. aes.insecure-passphrase: \"myMasterPasswordForEncryption\" # See documentation of pki-util rsa: # load from classpath keystore-resource-path: \".ssh/keystore.p12\" # If keystore is used, alias to use from the keystore (in this example, it is \"1\") key-alias: \"1\" # Password of keystore keystore-passphrase: \"helidon\" ",
            "title": "Configure config encryption filter (RSA)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": " This approach is based on a pair of keys: a public key which is known to anybody, and a private key which is known to a limited set of parties (usually a single person or process). For asymmetric encryption, the following is true: a value encrypted by a public key can only be decrypted by the private key a value encrypted by a private key can only be decrypted by the public key When using the config encryption filter, you should encrypt the configuration values using the public key, and give the application process access to the private key to decrypt the values. Encrypting values (RSA) The config encryption filter provides a Main class io.helidon.config.encryption.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using public certificate in a keystore\" >java io.helidon.config.encryption Main rsa /path/to/keystore.p12 keystorePassword publicCertAlias secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Configure config encryption filter (RSA) You can configure the properties of a private key. These keys are prefixed with security.config.rsa RSA Configuration Options: Keystore What Configuration Key Environment Variable Description Keystore path keystore-path SECURE_CONFIG_RSA_PRIVATE_KEY Keystore is located in file system Keystore keystore-resource-path N/A Keystore is located on classpath Private key alias key-alias SECURE_CONFIG_PRIVATE_KEY_ALIAS Alias of the private key (such as \"1\", which is usually the default) Keystore passphrase keystore-passphrase SECURE_CONFIG_PRIVATE_KEYSTORE_PASSPHRASE Password for the keystore (and private key). RSA Configuration Options: PEM (PKCS#8) private key What Configuration Key Environment Variable Description Path pem-key-path SECURE_CONFIG_RSA_PEM_KEY Key is located on file system Resource path pem-key-resource-path N/A Key is located on classpath Passphrase pem-key-passphrase SECURE_CONFIG_PRIVATE_KEY_PASSPHRASE Password protecting the private key <markup lang=\"yaml\" title=\"Example yaml configuration\" >security.config: # Set to true for production - if set to true, clear text passwords will cause failure require-encryption: false # The \"master\" password for AES decryption. For production, set this via system property or environment variable. aes.insecure-passphrase: \"myMasterPasswordForEncryption\" # See documentation of pki-util rsa: # load from classpath keystore-resource-path: \".ssh/keystore.p12\" # If keystore is used, alias to use from the keystore (in this example, it is \"1\") key-alias: \"1\" # Password of keystore keystore-passphrase: \"helidon\" ",
            "title": "Using asymmetric encryption (RSA)"
        },
        {
            "location": "/microprofile/06_configuration",
            "text": "<markup lang=\"yaml\" title=\"application.yaml\" >security: providers: # Attribute based access control, validates roles - abac: # HTTP Basic authentication provider - http-basic-auth: realm: \"helidon\" users: - login: \"jack\" password: \"password\" roles: [\"user\", \"admin\"] - login: \"jill\" password: \"password\" roles: [\"user\"] - login: \"john\" password: \"password\" # Protect static content - require authenticated user web-server: paths: - path: \"/static-cp[/{*}]\" authenticate: true Protecting Configuration Secrets In Helidon MP, the config encryption filter enabled by default . However, if you don&#8217;t configure it, the filter only supports a template for aliasing that checks that no clear text passwords are present (template ${CLEAR=&#8230;&#8203;}. In Helidon SE, you may add support for this filter with dependency (loaded through a java service mechanism): <markup lang=\"xml\" title=\"Maven Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.config&lt;/groupId&gt; &lt;artifactId&gt;helidon-config-encryption&lt;/artifactId&gt; &lt;/dependency&gt; Put encrypted values into your configuration file so that it can be stored in a public repository with no danger of exposing the secret values. Be sure to use a strong and secret password. The supported templates are: Templates Template Description Example ${CLEAR=&#8230;&#8203;} Secret in clear text (for testing) - requiresEncryption must be disabled ${CLEAR=knownSecret} ${RSA=&#8230;&#8203;} Public/private key encryption, base64 value ${RSA=aGr3sFCMQznixrgbIk9qNfoLnO1cdi3H86qweCNjxFvH4dYg5IQM1EuoyTjJaXcSCG5MBskpeA3bjnWYrzeAFFlZHuYSPsb+wJVzGLrfUColTn+BPJjpJ3rmEd3AVkJl1ASfBBMh3q3deC+rvUdhfoTGBO8sC0teUATklCQSxfHOnIxswxqrplnoGXToGiTIfehiN2IZNulRKeoDQ0AeoKREmq5au4L8OOmS+D9BqnlKMc0F1tULZ7+h3Cxla4lXC5WRPoPfHBU4vzRZOGzeDvLkRgrD60caw/wKn5M0Wy1A1cKR8E46ceBXCjJ2eWIcLyhZSAZWDe3ceNrawHZtCg==} ${AES=&#8230;&#8203;} Shared secret ecryption, base64 value ${AES=D/UgMzsNb265HU1NDvdzm7tACHdsW6u1PjYEcRkV/OLiWcI+ET6Q4MKCz0zHyEh9} ${ALIAS=&#8230;&#8203;} Reference to another key ${ALIAS=someOtherKey} Requiring encryption The config encryption filter has an option that defines whether encryption is required or not. If it&#8217;s set to true, which is the default, then: Configuration values with ${CLEAR=&#8230;&#8203;} template will cause an exception when requested. The filter fails during bootstrap if security.config.aes.insecure-passphrase is configured. Using symmetric encryption (AES) Symmetric encryption is based on a shared secret that is known by the person encrypting the value and is also provided to the application. Encrypting values (AES) The config encryption filter provides a Main class io.helidon.config.encryption.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using shared secret masterPassword \" >java io.helidon.config.encryption.Main aes masterPassword secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Shared Secret (AES) You can provide a shared secret in a couple of ways: in configuration - for testing/demo purposes only - key is security.config.aes.insecure-passphrase as an environment variable - SECURE_CONFIG_AES_MASTER_PWD Using asymmetric encryption (RSA) This approach is based on a pair of keys: a public key which is known to anybody, and a private key which is known to a limited set of parties (usually a single person or process). For asymmetric encryption, the following is true: a value encrypted by a public key can only be decrypted by the private key a value encrypted by a private key can only be decrypted by the public key When using the config encryption filter, you should encrypt the configuration values using the public key, and give the application process access to the private key to decrypt the values. Encrypting values (RSA) The config encryption filter provides a Main class io.helidon.config.encryption.Main that can be used to encrypt values. <markup lang=\"bash\" title=\"Encrypt secret secretToEncrypt using public certificate in a keystore\" >java io.helidon.config.encryption Main rsa /path/to/keystore.p12 keystorePassword publicCertAlias secretToEncrypt The tool returns the string to be entered into configuration as the value of a property. Configure config encryption filter (RSA) You can configure the properties of a private key. These keys are prefixed with security.config.rsa RSA Configuration Options: Keystore What Configuration Key Environment Variable Description Keystore path keystore-path SECURE_CONFIG_RSA_PRIVATE_KEY Keystore is located in file system Keystore keystore-resource-path N/A Keystore is located on classpath Private key alias key-alias SECURE_CONFIG_PRIVATE_KEY_ALIAS Alias of the private key (such as \"1\", which is usually the default) Keystore passphrase keystore-passphrase SECURE_CONFIG_PRIVATE_KEYSTORE_PASSPHRASE Password for the keystore (and private key). RSA Configuration Options: PEM (PKCS#8) private key What Configuration Key Environment Variable Description Path pem-key-path SECURE_CONFIG_RSA_PEM_KEY Key is located on file system Resource path pem-key-resource-path N/A Key is located on classpath Passphrase pem-key-passphrase SECURE_CONFIG_PRIVATE_KEY_PASSPHRASE Password protecting the private key <markup lang=\"yaml\" title=\"Example yaml configuration\" >security.config: # Set to true for production - if set to true, clear text passwords will cause failure require-encryption: false # The \"master\" password for AES decryption. For production, set this via system property or environment variable. aes.insecure-passphrase: \"myMasterPasswordForEncryption\" # See documentation of pki-util rsa: # load from classpath keystore-resource-path: \".ssh/keystore.p12\" # If keystore is used, alias to use from the keystore (in this example, it is \"1\") key-alias: \"1\" # Password of keystore keystore-passphrase: \"helidon\" ",
            "title": "Protecting Static Content"
        },
        {
            "location": "/about/02_introduction",
            "text": " Helidon is a collection of Java libraries for writing microservices. There&#8217;s no need for any specific tooling or deployment model. Simply use your favorite tools ! Your microservice is a plain Java application. You do not need an application server. ",
            "title": "A collection of Java libraries"
        },
        {
            "location": "/about/02_introduction",
            "text": " Helidon libraries interoperate with popular tools from the cloud-native space: Docker Kubernetes Prometheus OpenTracing Etcd The Helidon Quickstart Examples contain support for Docker and Kubernetes. ",
            "title": "Cloud-native Java"
        },
        {
            "location": "/about/02_introduction",
            "text": " Helidon SE is the functional programming style provided by all Helidon libraries. Helidon SE gives you full transparency and puts you in control. There is no magic! ",
            "title": "Helidon SE"
        },
        {
            "location": "/about/02_introduction",
            "text": " Helidon MP is our MicroProfile implementation. MicroProfile is a platform definition that is familiar to enterprise Java developers. It provides a declarative programming style that is portable. It includes popular Java APIs such as JAX-RS and CDI . Helidon MP is built on top of the Helidon libraries. ",
            "title": "Helidon MP"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " Declare the following dependency in your project: <markup lang=\"xml\" title=\"WebServer Jersey Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-jersey&lt;/artifactId&gt; &lt;/dependency&gt; ",
            "title": "Maven Coordinates"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " You can also register the JAX-RS Application object. <markup lang=\"java\" title=\"Register the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder(new MyApplication()) .build()) .build(); Register the Jersey application at /jersey context root MyApplication handles requests made to /jersey context root. ",
            "title": "Registering JAX-RS Application"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " To access WebServer internals, inject the following beans into the Jersey managed beans: request scoped ServerRequest and/or request scoped ServerResponse <markup lang=\"java\" title=\"Injection of WebServer internal objects\" >@Path(\"/\") public class HelloWorld { @Inject private ServerRequest request; @Inject private ServerResponse response; } ",
            "title": "Accessing WebServer internals from a Jersey application"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " To register a Jersey application at a context root, use the JerseySupport class and its JerseySupport.Builder builder. JerseySupport can register the JAX-RS resources directly. <markup lang=\"java\" title=\"Jersey (JAX-RS) HelloWorld resource\" >@Path(\"/\") public class HelloWorld { @GET @Path(\"hello\") public Response hello() { return Response.ok(\"Hello World!\").build(); } } <markup lang=\"java\" title=\"Registering the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder() .register(HelloWorld.class) .build()) .build(); Register the Jersey application at /jersey context root The Jersey Application stays hidden and consists of a single HelloWorld resource class As a result, an HTTP GET request to /jersey/hello would yield a Hello World! response string. Registering JAX-RS Application You can also register the JAX-RS Application object. <markup lang=\"java\" title=\"Register the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder(new MyApplication()) .build()) .build(); Register the Jersey application at /jersey context root MyApplication handles requests made to /jersey context root. Accessing WebServer internals from a Jersey application To access WebServer internals, inject the following beans into the Jersey managed beans: request scoped ServerRequest and/or request scoped ServerResponse <markup lang=\"java\" title=\"Injection of WebServer internal objects\" >@Path(\"/\") public class HelloWorld { @Inject private ServerRequest request; @Inject private ServerResponse response; } ",
            "title": "Registering a Jersey Application"
        },
        {
            "location": "/webserver/07_jersey-support",
            "text": " You can register a Jersey (JAX-RS) application at a context root using the JerseySupport class. Maven Coordinates Declare the following dependency in your project: <markup lang=\"xml\" title=\"WebServer Jersey Dependency\" >&lt;dependency&gt; &lt;groupId&gt;io.helidon.webserver&lt;/groupId&gt; &lt;artifactId&gt;helidon-webserver-jersey&lt;/artifactId&gt; &lt;/dependency&gt; Registering a Jersey Application To register a Jersey application at a context root, use the JerseySupport class and its JerseySupport.Builder builder. JerseySupport can register the JAX-RS resources directly. <markup lang=\"java\" title=\"Jersey (JAX-RS) HelloWorld resource\" >@Path(\"/\") public class HelloWorld { @GET @Path(\"hello\") public Response hello() { return Response.ok(\"Hello World!\").build(); } } <markup lang=\"java\" title=\"Registering the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder() .register(HelloWorld.class) .build()) .build(); Register the Jersey application at /jersey context root The Jersey Application stays hidden and consists of a single HelloWorld resource class As a result, an HTTP GET request to /jersey/hello would yield a Hello World! response string. Registering JAX-RS Application You can also register the JAX-RS Application object. <markup lang=\"java\" title=\"Register the HelloWorld resource\" >Routing.builder() .register(\"/jersey\", JerseySupport.builder(new MyApplication()) .build()) .build(); Register the Jersey application at /jersey context root MyApplication handles requests made to /jersey context root. Accessing WebServer internals from a Jersey application To access WebServer internals, inject the following beans into the Jersey managed beans: request scoped ServerRequest and/or request scoped ServerResponse <markup lang=\"java\" title=\"Injection of WebServer internal objects\" >@Path(\"/\") public class HelloWorld { @Inject private ServerRequest request; @Inject private ServerResponse response; } ",
            "title": "JAX-RS Support"
        },
        {
            "location": "/config/07_extensions",
            "text": " Developer-provided extensions influence how the config system behaves. The config system introduction explains the design of the config system and how its parts work together to read and parse config data, convert it to Java types, fine-tune the look-up of config data, and reload and reprocess data when it changes. Config extensions provided by the application modify and expand the way the config system performs these steps. ",
            "title": "preambule"
        },
        {
            "location": "/config/07_extensions",
            "text": " The config system invokes extensions of a given type in priority order. Developers can express the relative importance of an extension by annotating the implementation class with @javax.annotation.Priority . The default value is 100. A lower priority value represents greater importance. The sections below for each interface tell which SPIs support @Priority . ",
            "title": "About Priority"
        },
        {
            "location": "/config/07_extensions",
            "text": " Each config extension implements one of the interfaces defined in the Configuration SPI: ConfigSource - Loads raw configuration data from a given type of source and delegates to a ConfigParser , producing the in-memory data structure which represents the loaded and parsed configuration. ConfigParser - Translates configuration content in a given format into the corresponding internal config data structures. OverrideSource - Provides key/value pairs which override config values loaded from any ConfigSource , given the key and ignoring the original value. ConfigFilter - Transforms config String values returned from any value-type Config node, given the key and the original value. ConfigMapperProvider - Provides one or more ConfigMapper s each of which converts a Config object tree to a Java type specific to the application. PollingStrategy - Implements a custom technique for notifying the Config system when the data underlying a ConfigSource or OverrideSource has changed. The config system itself implements several of these SPIs, as noted in the sections below. About Priority The config system invokes extensions of a given type in priority order. Developers can express the relative importance of an extension by annotating the implementation class with @javax.annotation.Priority . The default value is 100. A lower priority value represents greater importance. The sections below for each interface tell which SPIs support @Priority . ",
            "title": "Introduction"
        },
        {
            "location": "/config/07_extensions",
            "text": " The config system includes built-in support for several types of sources (for example, Java String , Readable , Properties , and Map objects - see ConfigSources ). Implement a ConfigSource to load raw configuration data from a type of source that the config system does not already support. ConfigSource SPI The interfaces ConfigNode , ObjectNode , ValueNode and ListNode represent the in-memory data structure for loaded and parsed configuration data. ",
            "title": "ConfigSource SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The parsing step converts config data in some format into the corresponding in-memory representation of config ObjectNode s. The config system can already parse several data formats (for example Java Properties , YAML, and HOCON). Implement the ConfigParser SPI to allow the config system to handle additional formats. ConfigParser SPI The ConfigParser.Content interface defines operations on the content that is to to be parsed by a ConfigParser implementation: getStamp() - Returns a stamp (for example, a time stamp) that is different for different values of the content. getMediaType() - Reports the media type of the content. asReadable() - Provides a Readable and Autocloseable object from which the content can be read. The application can register parsers for a builder by invoking Config.Builder#addParser(ConfigParser) . The config system also uses the Java service loader mechanism to load automatically, for all builders, any parsers listed in the META-INF/services/io.helidon.config.spi.ConfigParser resource on the runtime classpath. Prevent autoloading of parsers for a given builder by invoking Config.Builder#disableParserServices() . ConfigParser accepts @Priority . See About Priority . <markup lang=\"java\" title=\"Example custom parser implementation listed in META-INF/services/io.helidon.config.spi.ConfigParser \" >myModule.MyConfigParser <markup lang=\"java\" title=\"Example custom parser definition in module-info.java \" >module myModule { requires transitive io.helidon.config; provides io.helidon.config.spi.ConfigParser with myModule.MyConfigParser; } ",
            "title": "ConfigParser SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " When the application retrieves a configuration value the config system first uses the relevant config sources and filters. It then applies any overrides the application has provided. Each override has: a Predicate&lt;Config.Key&gt; (a boolean-valued function that operates on the config key), and a replacement, overriding , String value the config system should use if the predicate evaluates to true. To furnish overrides to the config system, implement the OverrideSource SPI one or more times and pass instances of those implementations to the config builder&#8217;s overrides method. The config system will apply the overrides returned from each OverrideSource to each config key requested from a Config that is based on that Config.Builder . OverrideSource SPI ",
            "title": "OverrideSource SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The ConfigFilter JavaDoc describes multiple methods for adding filters to a Config.Builder . Some accept a ConfigFilter directly and some accept a provider function which, when passed a Config instance, returns a ConfigFilter . Neither a ConfigFilter nor a provider function which furnishes one should access the Config instance passed to the provider function. Instead, implement the ConfigFilter.init(Config) method on the filter. The config system invokes the filters' init methods according to the filters' @Priority order. Recall that whenever any code invokes Config.get , the Config instance invokes the apply method of all registered filters. By the time the application retrieves config this way the config system will have run the init method on all the filters. But note that when a filter&#8217;s init method invokes Config.get , the init methods of lower-priority filters will not yet have run. ConfigFilter SPI ",
            "title": "Initializing Filters"
        },
        {
            "location": "/config/07_extensions",
            "text": " Before returning a String from Config.value() the config system applies any filters set up on the Config.Builder used to create the config tree that contains the config node of interest. The application provides filters as implementations of the ConfigFilter interface. Each filter is a function which accepts a Config.Key and an input String value and returns a String value the config system should use for that key going forward. The filter can return the original value or return some other value. The application registers filters and filter providers by passing ConfigFilter implementations to one of the config builder addFilter methods . The config system also uses the Java service loader mechanism to load additional filters automatically, for all builders, using the service interface described in the following table. Prevent a given builder from using the auto-loaded filters by invoking the disableFilterServices method. Config SPI Interfaces for Filtering Interface Method Usage ConfigFilter Accepts @Priority . See About Priority . String apply(Config.Key key, String stringValue); Accepts a key and the corresponding String value and returns the String which the config system should use for that key. Initializing Filters The ConfigFilter JavaDoc describes multiple methods for adding filters to a Config.Builder . Some accept a ConfigFilter directly and some accept a provider function which, when passed a Config instance, returns a ConfigFilter . Neither a ConfigFilter nor a provider function which furnishes one should access the Config instance passed to the provider function. Instead, implement the ConfigFilter.init(Config) method on the filter. The config system invokes the filters' init methods according to the filters' @Priority order. Recall that whenever any code invokes Config.get , the Config instance invokes the apply method of all registered filters. By the time the application retrieves config this way the config system will have run the init method on all the filters. But note that when a filter&#8217;s init method invokes Config.get , the init methods of lower-priority filters will not yet have run. ConfigFilter SPI ",
            "title": "ConfigFilter SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The config system provides built-in mappings from String values to various Java types. (See ConfigMappers .) To handle mappings to other types the application can register custom mappers with the config system by implementing the ConfigMapperProvider SPI. Such providers return a map, with entries in which: the key is the Java type (a Class object) the mapper produces, and the value is a ConfigMapper that converts the config in-memory data structure into the type in the key. The provider may also implement other methods for finer tuned conversion mechanisms: genericTypeMappers() returns a map with entries for specific GenericType conversions, for example when the provider supports only mapping for GenericType&lt;Map&lt;String, Integer&gt;&gt; mapper(Class) returns a conversion function (optional) that converts a config node to the typed instance (if supported by this provider) mapper(GenericType) returns a conversion function (optional) that coverts a config node to the GenericType (if supported by this provider) - for example in case this provider supports any Map&lt;String, ?&gt; type, such as Map&lt;String, Integer&gt; and Map&lt;String, Double&gt; The config conversion system works as follows: For Config.as(Class) : Check whether a conversion function exists for the class requested (from method mappers() ). Check whether a conversion function is provided by any ConfigMapperProvider with method mapper(Class) . Check whether a conversion function exists for a generic type for the class requested (from method genericTypeMappers ). Check whether a conversion function is provided by any ConfigMapperProvider with method mapper(GenericType) for a generic type for the class requested. For Config.as(GenericType) - the first two steps are skipped. The config system also uses the Java ServiceLoader mechanism to load automatically, for all builders, any mappers returned by the providers listed in the META-INF/services/io.helidon.config.spi.ConfigMapperProvider resource on the runtime classpath. The application can prevent autoloading of mappers for a given builder by invoking Config.Builder#disableMapperServices() . Note that the built-in mappers described in ConfigMappers still operate. Mapper providers accept @Priority . See About Priority . ConfigMapperProvider SPI A mapper provider can specify a @javax.annotation.Priority . If no priority is explicitly assigned, the value of 100 is assumed. <markup lang=\"java\" title=\"Reference custom mapper provider implementation in META-INF/services/io.helidon.config.spi.ConfigMapperProvider \" >myModule.MyConfigMapperProvider <markup lang=\"java\" title=\"Reference custom mapper provider implementation in module-info.java \" >module myModule { requires transitive io.helidon.config; provides io.helidon.config.spi.ConfigMapperProvider with myModule.MyConfigMapperProvider; } ",
            "title": "ConfigMapperProvider SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " Once it loads a Config tree from ConfigSource s the config system does not itself change the in-memory Config tree. Even so, the underlying data available via the tree&#8217;s ConfigSource s can change. Implementations of PollingStrategy informs other interested code when changes to that underlying data might have occurred. In implementations of PollingStrategy the #ticks() method returns a Flow.Publisher of PollingEvent s to which the application or the ConfigSource s themselves can subscribe. Generally, each event is a hint to the subscriber that it should check to see if any of the underlying config data it relies on has changed. Note that a PollingStrategy 's publication of an event does not necessarily guarantee that the underlying data has in fact changed, although this might be true for some PollingStrategy implementations. The config system offers polling strategies for periodic time-based checks and for a file watcher. Often an application can create a config source simply by using one of the methods on ConfigSources (for example, ConfigSources#file(path) to get a builder and then invoke pollingStrategy passing one of the predefined strategies. But the application can implement its own PollingStrategy and set it on the config source builder instead. PollingStrategy SPI The PollingStrategy ticks() method returns a Publisher of PollingEvent s. Each event becomes available as the particular PollingStrategy publishes it. Depending on the implementation of the polling strategy, such events might indicate that the underlying source data has changed or that it might have changed. In either case the subscribers to the publisher are notified. If the ConfigSource itself subscribes to the publisher, for example, then it might choose to reload the underlying data when its subscriber receives an event. ",
            "title": "PollingStrategy SPI"
        },
        {
            "location": "/config/07_extensions",
            "text": " The builder for each ConfigSource and OverrideSource accepts a RetryPolicy governing if and how the source should deal with failures loading the underlying data. A retry policy accepts a function, the invocation of which the policy will govern according to its own implementation. Applications can use the predefined policies in RetryPolicies , such as RetryPolicies.justCall which simply invokes the function without any retry. That class also exposes a builder for constructing a time-based retry policy, with several parameters: Parameters Controlling Built-in RetryPolicy Parameter Usage Default delay Initial delay between calls to the function 200 ms delayFactor Multiplier applied to delay on each successive call 2 callTimeout Time limit for each individual call of the function 500 ms overallTimeout Limit for the total elapsed time attempting to call the function successfully, including delays between calls 2 s The actual delay between function call starts as delay and changes by the factor delayFactor on each successive attempt. Note that the job of each retry policy is to call the provided function successfully. As such, the policy must perform the first attempt as well as any retries. RetryPolicy SPI The application can try to cancel the overall execution of a RetryPolicy by invoking the RetryPolicy#cancel(boolean mayInterruptIfRunning) method. Ideally the retry policy implementation should be able to abort the execution of the retry policy, even while a function call is in progress, but the policy must respond to cancels between function calls. In either case cancel returns true if the retry was aborted without a successful call to the function, and false otherwise, including if the function call had already completed successfully or had previously been successfully canceled. ",
            "title": "RetryPolicy SPI"
        }
 ]
}